// ═══════════════════════════════════════════════════════════════
// core/persistence.ts
// 存档系统 - 现代化、可扩展、健壮的序列化与反序列化实现
// ═══════════════════════════════════════════════════════════════

import { 领主实体, 冠军实体, 母畜实体, 可袭击地点实体, 喽啰池实体 } from './entities';
import { 工厂管理器 } from './factories';
import type { 游戏总控接口 } from '../types/systems';
import type { 武装等级 } from '../types/common';

// 当前存档格式版本（重大变更时递增）
const 当前存档版本 = '1.0.0';

// ═══════════════════════════════════════════════════════════════
// 存档数据结构（纯数据，无类实例）
// ═══════════════════════════════════════════════════════════════

export interface 领主存档数据 {
  版本?: string;
  实体ID: string;
  姓名: string;
  魔力: number;
  最大魔力: number;
  元数据?: Record<string, unknown>;
}

export interface 喽啰池存档数据 {
  实体ID: string;
  将领ID: string | null;
  武装分组: Array<{
    等级: 武装等级;
    数量: number;
  }>;
  元数据?: Record<string, unknown>;
}

export interface 冠军存档数据 {
  实体ID: string;
  姓名: string;
  性别: string;
  力量: number;
  敏捷: number;
  智力: number;
  来源: string;
  生母: string | null;
  喽啰池?: 喽啰池存档数据 | null;
  元数据?: Record<string, unknown>;
}

export interface 母畜存档数据 {
  实体ID: string;
  姓名: string;
  种族: string;
  年龄: number;
  原身份: string;
  来源: string;
  描述: string;
  总生育力: number;
  剩余生育力: number;
  淫乱度: number;
  臣服度: number;
  魅力: number;
  特性列表: string[];
  来源地点ID: string | null;
  冠军生育记录: string[];
  喽啰生育记录: number;
  元数据?: Record<string, unknown>;
}

export interface 地点存档数据 {
  实体ID: string;
  地点名称: string;
  地点类型: string;
  描述: string;
  侦察最大值: number;
  侦察进度: number;
  战斗力: number;
  战斗力估值: number | null;
  已侦察母畜: 母畜存档数据[];
  潜在母畜: 母畜存档数据[];
  元数据?: Record<string, unknown>;
}

export interface 资源存档数据 {
  士气: number;
  最大士气: number;
  催淫母乳: number;
}

export interface 游戏存档数据 {
  版本: string;
  存档时间: number;
  存档名称: string;
  回合数: number;

  领主: 领主存档数据;
  冠军列表: 冠军存档数据[];
  母畜列表: 母畜存档数据[];
  地点列表: 地点存档数据[];
  无将领喽啰池: 喽啰池存档数据;

  资源状态: 资源存档数据;

  // 可选：未来扩展字段
  扩展数据?: Record<string, unknown>;
}

// ═══════════════════════════════════════════════════════════════
// 存档管理器
// ═══════════════════════════════════════════════════════════════

export class 存档管理器 {
  private 工厂管理器: 工厂管理器;
  private 游戏总控: 游戏总控接口 | null = null;

  constructor(工厂管理器实例: 工厂管理器) {
    this.工厂管理器 = 工厂管理器实例;
  }

  设置游戏总控(总控: 游戏总控接口): void {
    this.游戏总控 = 总控;
  }

  // ─── 序列化：游戏状态 → 纯数据 ───
  序列化游戏(领主: 领主实体, 当前回合: number, 资源状态: 资源存档数据, 存档名称: string): 游戏存档数据 {
    if (!this.游戏总控) throw new Error('游戏总控未设置');

    const 冠军列表 = this.游戏总控.冠军管理.获取所有冠军();
    const 母畜列表 = this.游戏总控.母畜管理.获取所有母畜();
    const 地点列表 = this.游戏总控.地点管理.获取所有地点();
    const 无将领喽啰池 = this.游戏总控.喽啰池管理.获取无将领喽啰池();

    return {
      版本: 当前存档版本,
      存档时间: Date.now(),
      存档名称,
      回合数: 当前回合,

      领主: this.序列化领主(领主),
      冠军列表: 冠军列表.map(c => this.序列化冠军(c)),
      母畜列表: 母畜列表.map(m => this.序列化母畜(m)),
      地点列表: 地点列表.map(l => this.序列化地点(l)),
      无将领喽啰池: this.序列化喽啰池(无将领喽啰池),

      资源状态,
    };
  }

  private 序列化领主(领主: 领主实体): 领主存档数据 {
    return {
      版本: 当前存档版本,
      实体ID: 领主.实体ID,
      姓名: 领主.获取属性('姓名'),
      魔力: 领主.获取属性('魔力'),
      最大魔力: 领主.获取属性('最大魔力'),
      元数据: 领主['元数据'],
    };
  }

  private 序列化冠军(冠军: 冠军实体): 冠军存档数据 {
    const 喽啰池 = 冠军.获取喽啰池?.();
    return {
      实体ID: 冠军.实体ID,
      姓名: 冠军.获取属性('姓名'),
      性别: 冠军.获取属性('性别'),
      力量: 冠军.获取属性('力量'),
      敏捷: 冠军.获取属性('敏捷'),
      智力: 冠军.获取属性('智力'),
      来源: 冠军.获取属性('来源'),
      生母: 冠军['生母'],
      喽啰池: 喽啰池 ? this.序列化喽啰池(喽啰池) : null,
      元数据: 冠军['元数据'],
    };
  }

  private 序列化母畜(母畜: 母畜实体): 母畜存档数据 {
    return {
      实体ID: 母畜.实体ID,
      姓名: 母畜.获取属性('姓名'),
      种族: 母畜.获取属性('种族'),
      年龄: 母畜.获取属性('年龄'),
      原身份: 母畜.获取属性('原身份'),
      来源: 母畜.获取属性('来源'),
      描述: 母畜.获取属性('描述'),
      总生育力: 母畜.获取属性('总生育力'),
      剩余生育力: 母畜.获取属性('剩余生育力'),
      淫乱度: 母畜.获取属性('淫乱度'),
      臣服度: 母畜.获取属性('臣服度'),
      魅力: 母畜.获取属性('魅力'),
      特性列表: Array.from(母畜['特性列表']),
      来源地点ID: 母畜['来源地点ID'],
      冠军生育记录: 母畜['冠军生育记录'],
      喽啰生育记录: 母畜['喽啰生育记录'],
      元数据: 母畜['元数据'],
    };
  }

  private 序列化喽啰池(池: 喽啰池实体): 喽啰池存档数据 {
    const 分组数组: Array<{等级: 武装等级; 数量: number}> = [];
    池['武装分组'].forEach((数据, 等级) => {
      分组数组.push({ 等级, 数量: 数据.数量 });
    });

    return {
      实体ID: 池.实体ID,
      将领ID: 池['将领']?.实体ID ?? null,
      武装分组: 分组数组,
      元数据: 池['元数据'],
    };
  }

  private 序列化地点(地点: 可袭击地点实体): 地点存档数据 {
    return {
      实体ID: 地点.实体ID,
      地点名称: 地点.地点名称,
      地点类型: 地点.地点类型,
      描述: 地点.描述,
      侦察最大值: 地点.侦察最大值,
      侦察进度: 地点.侦察进度,
      战斗力: 地点.获取属性('战斗力'),
      战斗力估值: 地点['战斗力估值'],
      已侦察母畜: Array.from(地点['已侦察母畜'].values()).map(m => this.序列化母畜(m)),
      潜在母畜: Array.from(地点['潜在地点母畜池'].values()).map(m => this.序列化母畜(m)),
      元数据: 地点['元数据'],
    };
  }

  // ─── 反序列化：纯数据 → 游戏实体 ───
  反序列化游戏(存档数据: 游戏存档数据): { 成功: boolean; 原因?: string } {
    try {
      // 版本兼容性检查（可扩展）
      if (!存档数据.版本) {
        console.warn('旧版存档，无版本号，尝试兼容加载');
      } else if (存档数据.版本 !== 当前存档版本) {
        console.warn(`存档版本 ${存档数据.版本} 与当前 ${当前存档版本} 不一致，尝试兼容加载`);
      }

      if (!this.游戏总控) throw new Error('游戏总控未设置');

      // 清空现有实体
      this.游戏总控.冠军管理.获取所有冠军().forEach(c => c.销毁());
      this.游戏总控.母畜管理.获取所有母畜().forEach(m => m.销毁());
      this.游戏总控.地点管理.获取所有地点().forEach(l => l.销毁?.());

      // 重建领主
      const 领主 = this.反序列化领主(存档数据.领主);
      this.游戏总控.领主管理.设置领主(领主);

      // 重建无将领喽啰池
      const 无将领池 = this.反序列化喽啰池(存档数据.无将领喽啰池, null);
      this.游戏总控.喽啰池管理.获取无将领喽啰池 = () => 无将领池; // 注意：实际项目中应有 setter

      // 重建冠军（含喽啰池）
      const 冠军映射 = new Map<string, 冠军实体>();
      存档数据.冠军列表.forEach(数据 => {
        const 冠军 = this.反序列化冠军(数据, null);
        冠军映射.set(冠军.实体ID, 冠军);
        this.游戏总控!.冠军管理.添加冠军(冠军);
      });

      // 关联冠军的喽啰池将领
      存档数据.冠军列表.forEach(数据 => {
        if (数据.喽啰池 && 数据.喽啰池.将领ID) {
          const 冠军 = 冠军映射.get(数据.喽啰池.将领ID);
          if (冠军) {
            const 池 = this.反序列化喽啰池(数据.喽啰池, 冠军);
            冠军['管理喽啰池'] = 池;
          }
        }
      });

      // 重建母畜
      存档数据.母畜列表.forEach(数据 => {
        const 母畜 = this.反序列化母畜(数据);
        this.游戏总控!.母畜管理.添加母畜(母畜);
      });

      // 重建地点（含母畜引用）
      存档数据.地点列表.forEach(数据 => {
        const 地点 = this.反序列化地点(数据);
        this.游戏总控!.地点管理.添加地点(地点);
      });

      // 恢复资源与回合（需由游戏总控处理）
      // 这里仅返回成功，实际资源恢复应在 controller 中处理

      return { 成功: true };
    } catch (错误) {
      console.error('存档加载失败:', 错误);
      return { 成功: false, 原因: (错误 as Error).message || '未知错误' };
    }
  }

  private 反序列化领主(数据: 领主存档数据): 领主实体 {
    return new 领主实体({
      实体ID: 数据.实体ID,
      姓名: 数据.姓名,
      魔力: 数据.魔力,
      最大魔力: 数据.最大魔力,
      元数据: 数据.元数据,
    });
  }

  private 反序列化冠军(数据: 冠军存档数据, 临时喽啰池: 喽啰池实体 | null): 冠军实体 {
    const 冠军 = new 冠军实体({
      实体ID: 数据.实体ID,
      姓名: 数据.姓名,
      性别: 数据.性别,
      力量: 数据.力量,
      敏捷: 数据.敏捷,
      智力: 数据.智力,
      来源: 数据.来源,
      生母: 数据.生母,
      管理喽啰池: 临时喽啰池?? undefined,
      元数据: 数据.元数据,
    });
    return 冠军;
  }

  private 反序列化母畜(数据: 母畜存档数据): 母畜实体 {
    const 母畜 = new 母畜实体({
      实体ID: 数据.实体ID,
      姓名: 数据.姓名,
      种族: 数据.种族,
      年龄: 数据.年龄,
      原身份: 数据.原身份,
      来源: 数据.来源,
      描述: 数据.描述,
      总生育力: 数据.总生育力,
      剩余生育力: 数据.剩余生育力,
      淫乱度: 数据.淫乱度,
      臣服度: 数据.臣服度,
      魅力: 数据.魅力,
      特性列表: 数据.特性列表,
      来源地点ID: 数据.来源地点ID,
      冠军生育记录: 数据.冠军生育记录,
      喽啰生育记录: 数据.喽啰生育记录,
      元数据: 数据.元数据,
    });
    return 母畜;
  }

  private 反序列化喽啰池(数据: 喽啰池存档数据, 将领: 冠军实体 | null): 喽啰池实体 {
    const 池 = new 喽啰池实体({
      实体ID: 数据.实体ID,
      将领,
    });

    // 恢复武装分组
    const 分组映射 = 池['武装分组'];
    数据.武装分组.forEach(({等级, 数量}) => {
      const 分组 = 分组映射.get(等级);
      if (分组) 分组.数量 = 数量;
    });

    return 池;
  }

  private 反序列化地点(数据: 地点存档数据): 可袭击地点实体 {
    const 地点 = new 可袭击地点实体({
      实体ID: 数据.实体ID,
      地点名称: 数据.地点名称,
      地点类型: 数据.地点类型,
      描述: 数据.描述,
      侦察最大值: 数据.侦察最大值,
      侦察进度: 数据.侦察进度,
      战斗力: 数据.战斗力,
    });

    // 恢复已侦察与潜在母畜
    数据.已侦察母畜.forEach(m => {
      const 母畜 = this.反序列化母畜(m);
      地点['已侦察母畜'].set(母畜.实体ID, 母畜);
    });
    数据.潜在母畜.forEach(m => {
      const 母畜 = this.反序列化母畜(m);
      地点['潜在地点母畜池'].set(母畜.实体ID, 母畜);
    });

    地点['战斗力估值'] = 数据.战斗力估值;

    return 地点;
  }

  加载自变量(): { 成功: boolean; 原因?: string } {
    const 存档名称 = 'Muv变量'
    try {
      const json = localStorage.getItem(`save_${存档名称}`);
      if (!json) throw new Error('存档不存在');

      const 存档数据: 游戏存档数据 = JSON.parse(json);
      return this.反序列化游戏(存档数据);
    } catch (错误) {
      return { 成功: false, 原因: (错误 as Error).message };
    }
  }

  保存至变量():{ 成功: boolean; 原因?: string }{ 
    const 存档名称 = 'Muv变量'
    try {
        if (!this.游戏总控) throw new Error('游戏未初始化');
  
        const 资源状态 = {
          士气: this.游戏总控.资源管理.获取士气(),
          最大士气: this.游戏总控.资源管理.获取最大士气(),
          催淫母乳: this.游戏总控.资源管理.获取催淫母乳数量(),
        };
  
        const 存档数据 = this.序列化游戏(
          this.游戏总控.领主管理.获取领主(),
          this.游戏总控.回合管理.获取当前回合(),
          资源状态,
          存档名称,
        );
  
        console.log(存档数据);
        return { 成功: true };
      } catch (错误) {
        return { 成功: false, 原因: (错误 as Error).message };
      }
  }

  // ─── 对外保存/加载接口（通常由 gameStore 调用）───
  保存游戏(存档名称: string): { 成功: boolean; 原因?: string } {
    try {
      if (!this.游戏总控) throw new Error('游戏未初始化');

      const 资源状态 = {
        士气: this.游戏总控.资源管理.获取士气(),
        最大士气: this.游戏总控.资源管理.获取最大士气(),
        催淫母乳: this.游戏总控.资源管理.获取催淫母乳数量(),
      };

      const 存档数据 = this.序列化游戏(
        this.游戏总控.领主管理.获取领主(),
        this.游戏总控.回合管理.获取当前回合(),
        资源状态,
        存档名称
      );
      console.log(存档数据);
      localStorage.setItem(`save_${存档名称}`, JSON.stringify(存档数据));
      return { 成功: true };
    } catch (错误) {
      return { 成功: false, 原因: (错误 as Error).message };
    }
  }

  加载存档(存档名称: string): { 成功: boolean; 原因?: string } {
    try {
      const json = localStorage.getItem(`save_${存档名称}`);
      if (!json) throw new Error('存档不存在');

      const 存档数据: 游戏存档数据 = JSON.parse(json);
      return this.反序列化游戏(存档数据);
    } catch (错误) {
      return { 成功: false, 原因: (错误 as Error).message };
    }
  }
}
