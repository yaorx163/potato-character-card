// ═══════════════════════════════════════════════════════════════
// core/registries.js
// 注册表系统 - 管理游戏中的各类定义
// ═══════════════════════════════════════════════════════════════

/**
 * 属性定义注册表
 * 管理所有属性类型的定义、范围、阶段
 */
class 属性定义注册表 {
  constructor() {
    this.属性类型映射 = new Map();
    this.属性计算器映射 = new Map();
    this.属性验证器映射 = new Map();
  }

  // ─── 属性类型注册 ───

  注册属性类型(属性名, 配置) {
    this.属性类型映射.set(属性名, {
      默认值: 配置.默认值 ?? 0,
      最小值: 配置.最小值 ?? 0,
      最大值: 配置.最大值 ?? Infinity,
      阶段定义: 配置.阶段定义 ?? [],
      衰减配置: 配置.衰减配置 ?? null,
      增长配置: 配置.增长配置 ?? null,
      描述: 配置.描述 ?? '',
      单位: 配置.单位 ?? '',
      ...配置,
    });
  }

  注册属性计算器(属性名, 计算函数) {
    /**
     * 计算函数签名: (上下文) => 计算值
     * 用于派生属性的动态计算
     */
    this.属性计算器映射.set(属性名, 计算函数);
  }

  注册属性验证器(属性名, 验证函数) {
    /**
     * 验证函数签名: (新值, 上下文) => { 有效: boolean, 原因?: string }
     */
    if (!this.属性验证器映射.has(属性名)) {
      this.属性验证器映射.set(属性名, []);
    }
    this.属性验证器映射.get(属性名).push(验证函数);
  }

  // ─── 属性查询 ───

  获取属性配置(属性名) {
    return this.属性类型映射.get(属性名);
  }

  获取所有属性() {
    return Array.from(this.属性类型映射.entries()).map(([名称, 配置]) => ({
      名称,
      ...配置,
    }));
  }

  是否已注册(属性名) {
    return this.属性类型映射.has(属性名);
  }

  // ─── 属性阶段 ───

  获取属性阶段(属性名, 当前值) {
    const 配置 = this.属性类型映射.get(属性名);
    if (!配置?.阶段定义?.length) return null;

    for (const 阶段 of 配置.阶段定义) {
      if (当前值 >= 阶段.下限 && 当前值 <= 阶段.上限) {
        return { ...阶段 };
      }
    }

    return null;
  }

  获取下一阶段(属性名, 当前值) {
    const 配置 = this.属性类型映射.get(属性名);
    if (!配置?.阶段定义?.length) return null;

    const 当前阶段 = this.获取属性阶段(属性名, 当前值);
    if (!当前阶段) return null;

    const 当前索引 = 配置.阶段定义.findIndex(阶段 => 阶段.名称 === 当前阶段.名称);

    if (当前索引 < 配置.阶段定义.length - 1) {
      return { ...配置.阶段定义[当前索引 + 1] };
    }

    return null; // 已是最高阶段
  }

  // ─── 派生属性计算 ───

  计算派生属性(属性名, 上下文) {
    const 计算器 = this.属性计算器映射.get(属性名);
    return 计算器 ? 计算器(上下文) : null;
  }

  // ─── 属性验证 ───

  验证属性值(属性名, 新值, 上下文 = {}) {
    // 范围验证
    const 配置 = this.属性类型映射.get(属性名);
    if (配置) {
      if (新值 < 配置.最小值) {
        return { 有效: false, 原因: `低于最小值 ${配置.最小值}` };
      }
      if (新值 > 配置.最大值) {
        return { 有效: false, 原因: `超过最大值 ${配置.最大值}` };
      }
    }

    // 自定义验证器
    const 验证器列表 = this.属性验证器映射.get(属性名) ?? [];
    for (const 验证器 of 验证器列表) {
      const 结果 = 验证器(新值, 上下文);
      if (!结果.有效) {
        return 结果;
      }
    }

    return { 有效: true };
  }

  // ─── 值规范化 ───

  规范化属性值(属性名, 值) {
    const 配置 = this.属性类型映射.get(属性名);
    if (!配置) return 值;

    return Math.max(配置.最小值, Math.min(配置.最大值, 值));
  }
}

// ═══════════════════════════════════════════════════════════════
// 任务定义注册表
// ═══════════════════════════════════════════════════════════════

/**
 * 任务定义注册表
 * 管理所有任务类型的定义、条件、执行器
 */
class 任务定义注册表 {
  constructor() {
    // 核心映射
    this.任务类型映射 = new Map();
    this.任务执行器映射 = new Map();
    this.任务验证器映射 = new Map();

    // 系统依赖
    this.系统依赖 = new Map();

    // 任务分类索引
    this.分类索引 = new Map();

    // 任务统计
    this.执行统计 = new Map();
  }

  // ─── 系统依赖管理 ───

  注入系统依赖(依赖配置) {
    Object.entries(依赖配置).forEach(([名称, 系统]) => {
      this.系统依赖.set(名称, 系统);
    });
  }

  获取系统(系统名) {
    return this.系统依赖.get(系统名);
  }

  移除系统依赖(系统名) {
    this.系统依赖.delete(系统名);
  }

  更新系统依赖(系统名, 新系统) {
    this.系统依赖.set(系统名, 新系统);
  }

  // ─── 任务类型注册 ───

  注册任务类型(任务名, 定义) {
    const 完整定义 = {
      // 基础配置
      行动点消耗: 定义.行动点消耗 ?? 1,
      负责人类型: 定义.负责人类型 ?? [],
      负责人条件: 定义.负责人条件 ?? (() => true),

      // 效果配置
      效率属性: 定义.效率属性 ?? [],
      产出类型: 定义.产出类型 ?? [],
      副作用: 定义.副作用 ?? [],

      // 条件配置
      前置条件: 定义.前置条件 ?? (() => true),
      冷却周期: 定义.冷却周期 ?? 0,
      每周限制: 定义.每周限制 ?? Infinity,

      // 分类与描述
      分类: 定义.分类 ?? '通用',
      描述: 定义.描述 ?? '',
      图标: 定义.图标 ?? null,

      // 目标配置
      需要目标: 定义.需要目标 ?? false,
      目标类型: 定义.目标类型 ?? null,
      目标条件: 定义.目标条件 ?? null,

      // 资源配置
      消耗资源: 定义.消耗资源 ?? null,
      产出资源: 定义.产出资源 ?? null,

      // 动态计算
      动态行动点计算: 定义.动态行动点计算 ?? null,

      ...定义,
    };

    this.任务类型映射.set(任务名, 完整定义);

    // 更新分类索引
    const 分类 = 完整定义.分类;
    if (!this.分类索引.has(分类)) {
      this.分类索引.set(分类, new Set());
    }
    this.分类索引.get(分类).add(任务名);

    // 初始化统计
    this.执行统计.set(任务名, {
      总执行次数: 0,
      成功次数: 0,
      失败次数: 0,
    });
  }

  注册任务执行器(任务名, 执行函数) {
    this.任务执行器映射.set(任务名, 执行函数);
  }

  注册任务验证器(任务名, 验证函数) {
    if (!this.任务验证器映射.has(任务名)) {
      this.任务验证器映射.set(任务名, []);
    }
    this.任务验证器映射.get(任务名).push(验证函数);
  }

  // ─── 任务查询 ───

  获取任务定义(任务名) {
    return this.任务类型映射.get(任务名);
  }

  获取分类任务列表(分类) {
    const 任务名集合 = this.分类索引.get(分类);
    if (!任务名集合) return [];

    return Array.from(任务名集合).map(名称 => ({
      名称,
      ...this.任务类型映射.get(名称),
    }));
  }

  获取所有分类() {
    return Array.from(this.分类索引.keys());
  }

  获取所有任务列表() {
    return Array.from(this.任务类型映射.entries()).map(([名称, 定义]) => ({
      名称,
      ...定义,
    }));
  }

  是否已注册(任务名) {
    return this.任务类型映射.has(任务名);
  }

  // ─── 上下文构建 ───

  构建执行上下文(基础上下文) {
    const 扩展上下文 = { ...基础上下文 };

    // 注入所有系统依赖
    this.系统依赖.forEach((系统, 名称) => {
      扩展上下文[名称] = 系统;
    });

    return 扩展上下文;
  }

  // ─── 任务验证 ───

  验证任务可执行性(任务名, 上下文) {
    const 定义 = this.任务类型映射.get(任务名);
    if (!定义) {
      return { 可执行: false, 原因: '未知任务类型' };
    }

    const { 负责人, 时间系统 } = 上下文;

    // 检查负责人类型
    if (负责人 && !定义.负责人类型.includes(负责人.实体类型)) {
      return { 可执行: false, 原因: '负责人类型不匹配' };
    }

    // 检查负责人条件
    if (负责人 && !定义.负责人条件(上下文)) {
      return { 可执行: false, 原因: '负责人条件不满足' };
    }

    // 检查前置条件
    if (!定义.前置条件(上下文)) {
      return { 可执行: false, 原因: '前置条件不满足' };
    }

    // 检查行动点
    const 实际消耗 = this.计算实际行动点(任务名, 上下文);
    if (时间系统 && 时间系统.剩余行动点 < 实际消耗) {
      return { 可执行: false, 原因: '行动点不足' };
    }

    // 检查资源消耗
    if (定义.消耗资源) {
      const 资源系统 = this.获取系统('资源系统');
      if (资源系统) {
        for (const [资源名, 数量] of Object.entries(定义.消耗资源)) {
          if (资源系统.获取资源(资源名) < 数量) {
            return { 可执行: false, 原因: `${资源名}不足` };
          }
        }
      }
    }

    // 检查目标
    if (定义.需要目标 && !上下文.额外参数?.目标ID) {
      return { 可执行: false, 原因: '需要指定目标' };
    }

    // 执行自定义验证器
    const 验证器列表 = this.任务验证器映射.get(任务名) ?? [];
    for (const 验证器 of 验证器列表) {
      const 结果 = 验证器(上下文);
      if (!结果.通过) {
        return { 可执行: false, 原因: 结果.原因 };
      }
    }

    return { 可执行: true };
  }

  计算实际行动点(任务名, 上下文) {
    const 定义 = this.任务类型映射.get(任务名);
    if (!定义) return 1;

    if (定义.动态行动点计算) {
      return 定义.动态行动点计算(上下文);
    }

    return 定义.行动点消耗;
  }

  // ─── 负责人筛选 ───

  获取负责人可执行任务(负责人, 游戏状态) {
    const 可执行任务 = [];

    this.任务类型映射.forEach((定义, 任务名) => {
      if (!定义.负责人类型.includes(负责人.实体类型)) return;

      const 上下文 = this.构建执行上下文({
        任务名,
        负责人,
        游戏状态,
      });

      const 验证结果 = this.验证任务可执行性(任务名, 上下文);
      if (验证结果.可执行) {
        可执行任务.push({
          名称: 任务名,
          行动点消耗: this.计算实际行动点(任务名, 上下文),
          ...定义,
        });
      }
    });

    return 可执行任务;
  }

  // ─── 统计 ───

  记录执行结果(任务名, 成功) {
    const 统计 = this.执行统计.get(任务名);
    if (统计) {
      统计.总执行次数++;
      if (成功) {
        统计.成功次数++;
      } else {
        统计.失败次数++;
      }
    }
  }

  获取任务统计(任务名) {
    return this.执行统计.get(任务名);
  }

  获取所有统计() {
    return Object.fromEntries(this.执行统计);
  }

  重置统计() {
    this.执行统计.forEach(统计 => {
      统计.总执行次数 = 0;
      统计.成功次数 = 0;
      统计.失败次数 = 0;
    });
  }
}

// ═══════════════════════════════════════════════════════════════
// 法术定义注册表
// ═══════════════════════════════════════════════════════════════

/**
 * 法术定义注册表
 * 管理所有法术的定义和效果处理器
 */
class 法术定义注册表 {
  constructor() {
    this.法术映射 = new Map();
    this.法术效果处理器 = new Map();
    this.法术分类索引 = new Map();
  }

  // ─── 法术注册 ───

  注册法术(法术名, 定义) {
    const 完整定义 = {
      魔力消耗: 定义.魔力消耗 ?? 1,
      目标类型: 定义.目标类型 ?? '无', // '母畜' | '冠军' | '军队' | '无'
      效果描述: 定义.效果描述 ?? '',
      效果参数: 定义.效果参数 ?? {},
      施放条件: 定义.施放条件 ?? (() => true),
      冷却周期: 定义.冷却周期 ?? 0,
      分类: 定义.分类 ?? '通用',
      图标: 定义.图标 ?? null,
      ...定义,
    };

    this.法术映射.set(法术名, 完整定义);

    // 更新分类索引
    const 分类 = 完整定义.分类;
    if (!this.法术分类索引.has(分类)) {
      this.法术分类索引.set(分类, new Set());
    }
    this.法术分类索引.get(分类).add(法术名);
  }

  注册效果处理器(法术名, 处理函数) {
    /**
     * 处理函数签名: (目标, 上下文) => 效果结果
     */
    this.法术效果处理器.set(法术名, 处理函数);
  }

  // ─── 法术查询 ───

  获取法术定义(法术名) {
    return this.法术映射.get(法术名);
  }

  获取分类法术列表(分类) {
    const 法术名集合 = this.法术分类索引.get(分类);
    if (!法术名集合) return [];

    return Array.from(法术名集合).map(名称 => ({
      名称,
      ...this.法术映射.get(名称),
    }));
  }

  获取所有法术列表() {
    return Array.from(this.法术映射.entries()).map(([名称, 定义]) => ({
      名称,
      ...定义,
    }));
  }

  是否已注册(法术名) {
    return this.法术映射.has(法术名);
  }

  // ─── 法术执行 ───

  执行法术效果(法术名, 目标, 上下文) {
    const 处理器 = this.法术效果处理器.get(法术名);
    if (!处理器) {
      return { 成功: false, 原因: '效果处理器未注册' };
    }

    try {
      return 处理器(目标, 上下文);
    } catch (错误) {
      console.error(`法术效果执行错误 [${法术名}]:`, 错误);
      return { 成功: false, 原因: '效果执行异常' };
    }
  }

  // ─── 法术验证 ───

  验证施放条件(法术名, 目标, 上下文) {
    const 定义 = this.法术映射.get(法术名);
    if (!定义) {
      return { 可施放: false, 原因: '未知法术' };
    }

    // 检查目标类型
    if (定义.目标类型 !== '无') {
      if (!目标) {
        return { 可施放: false, 原因: '需要指定目标' };
      }
      if (定义.目标类型 !== 目标.实体类型) {
        return { 可施放: false, 原因: '目标类型不匹配' };
      }
    }

    // 检查施放条件
    if (!定义.施放条件({ 目标, ...上下文 })) {
      return { 可施放: false, 原因: '施放条件不满足' };
    }

    return { 可施放: true };
  }
}

// ═══════════════════════════════════════════════════════════════
// 商品定义注册表
// ═══════════════════════════════════════════════════════════════

/**
 * 商品定义注册表
 * 管理黑市商品的定义和刷新规则
 */
class 商品定义注册表 {
  constructor() {
    this.商品分类 = new Map();
    this.商品映射 = new Map();
    this.刷新规则映射 = new Map();
  }

  // ─── 分类管理 ───

  注册商品分类(分类名, 配置) {
    this.商品分类.set(分类名, {
      刷新周期: 配置.刷新周期 ?? 1,
      随机刷新: 配置.随机刷新 ?? false,
      限购规则: 配置.限购规则 ?? null,
      描述: 配置.描述 ?? '',
      排序权重: 配置.排序权重 ?? 0,
      ...配置,
    });
  }

  获取分类配置(分类名) {
    return this.商品分类.get(分类名);
  }

  获取所有分类() {
    return Array.from(this.商品分类.entries())
      .sort((a, b) => (b[1].排序权重 ?? 0) - (a[1].排序权重 ?? 0))
      .map(([名称, 配置]) => ({ 名称, ...配置 }));
  }

  // ─── 商品注册 ───

  注册商品(商品名, 定义) {
    this.商品映射.set(商品名, {
      分类: 定义.分类 ?? '通用',
      价格: 定义.价格 ?? 1,
      效果: 定义.效果 ?? {},
      每周限购: 定义.每周限购 ?? Infinity,
      稀有度: 定义.稀有度 ?? 1,
      刷新权重: 定义.刷新权重 ?? 100,
      购买条件: 定义.购买条件 ?? (() => true),
      描述: 定义.描述 ?? '',
      图标: 定义.图标 ?? null,
      ...定义,
    });
  }

  注册刷新规则(分类名, 规则函数) {
    /**
     * 规则函数签名: (周次, 上下文) => 商品列表
     */
    this.刷新规则映射.set(分类名, 规则函数);
  }

  // ─── 商品查询 ───

  获取商品定义(商品名) {
    return this.商品映射.get(商品名);
  }

  获取分类商品列表(分类名) {
    return Array.from(this.商品映射.entries())
      .filter(([_, 定义]) => 定义.分类 === 分类名)
      .map(([名称, 定义]) => ({ 名称, ...定义 }));
  }

  获取所有商品列表() {
    return Array.from(this.商品映射.entries()).map(([名称, 定义]) => ({
      名称,
      ...定义,
    }));
  }

  // ─── 刷新逻辑 ───

  执行分类刷新(分类名, 周次, 上下文 = {}) {
    const 刷新规则 = this.刷新规则映射.get(分类名);
    if (刷新规则) {
      return 刷新规则(周次, 上下文);
    }

    // 默认：返回该分类的所有商品
    return this.获取分类商品列表(分类名);
  }

  // ─── 随机商品生成 ───

  按权重随机选择(商品列表, 数量) {
    if (商品列表.length === 0) return [];
    if (商品列表.length <= 数量) return [...商品列表];

    const 结果 = [];
    const 候选池 = [...商品列表];

    for (let i = 0; i < 数量 && 候选池.length > 0; i++) {
      const 总权重 = 候选池.reduce((sum, item) => sum + (item.刷新权重 ?? 100), 0);
      let 随机值 = Math.random() * 总权重;

      for (let j = 0; j < 候选池.length; j++) {
        随机值 -= 候选池[j].刷新权重 ?? 100;
        if (随机值 <= 0) {
          结果.push(候选池[j]);
          候选池.splice(j, 1);
          break;
        }
      }
    }

    return 结果;
  }
}

// ═══════════════════════════════════════════════════════════════
// 事件定义注册表
// ═══════════════════════════════════════════════════════════════

/**
 * 事件定义注册表
 * 管理游戏中所有可触发事件的定义
 */
class 事件定义注册表 {
  constructor() {
    this.事件类型映射 = new Map();
    this.事件处理器映射 = new Map();
    this.事件条件映射 = new Map();
    this.事件权重映射 = new Map();
    this.事件冷却映射 = new Map();
    this.事件分类索引 = new Map();
  }

  // ─── 事件注册 ───

  注册事件类型(事件名, 定义) {
    const 完整定义 = {
      分类: 定义.分类 ?? '通用',
      触发时机: 定义.触发时机 ?? 'manual',
      优先级: 定义.优先级 ?? 0,
      可重复: 定义.可重复 ?? true,
      冷却周期: 定义.冷却周期 ?? 0,
      前置事件: 定义.前置事件 ?? [],
      互斥事件: 定义.互斥事件 ?? [],
      参与者类型: 定义.参与者类型 ?? [],
      效果描述: 定义.效果描述 ?? '',
      ...定义,
    };

    this.事件类型映射.set(事件名, 完整定义);

    // 更新分类索引
    const 分类 = 完整定义.分类;
    if (!this.事件分类索引.has(分类)) {
      this.事件分类索引.set(分类, new Set());
    }
    this.事件分类索引.get(分类).add(事件名);
  }

  注册事件条件(事件名, 条件函数) {
    if (!this.事件条件映射.has(事件名)) {
      this.事件条件映射.set(事件名, []);
    }
    this.事件条件映射.get(事件名).push(条件函数);
  }

  注册事件处理器(事件名, 处理函数) {
    this.事件处理器映射.set(事件名, 处理函数);
  }

  注册事件权重(事件名, 权重计算函数) {
    this.事件权重映射.set(事件名, 权重计算函数);
  }

  // ─── 事件查询 ───

  获取事件定义(事件名) {
    return this.事件类型映射.get(事件名);
  }

  获取分类事件列表(分类) {
    const 事件名集合 = this.事件分类索引.get(分类);
    if (!事件名集合) return [];

    return Array.from(事件名集合).map(名称 => ({
      名称,
      ...this.事件类型映射.get(名称),
    }));
  }

  // ─── 事件检查 ───

  检查事件条件(事件名, 上下文) {
    const 条件列表 = this.事件条件映射.get(事件名) ?? [];

    for (const 条件 of 条件列表) {
      const 结果 = 条件(上下文);
      if (!结果.满足) {
        return { 可触发: false, 原因: 结果.原因 };
      }
    }

    // 检查冷却
    const 定义 = this.事件类型映射.get(事件名);
    if (定义?.冷却周期 > 0) {
      const 上次触发 = this.事件冷却映射.get(事件名);
      if (上次触发 && 上下文.当前周次 - 上次触发 < 定义.冷却周期) {
        return { 可触发: false, 原因: '事件冷却中' };
      }
    }

    // 检查互斥事件
    if (定义?.互斥事件?.length > 0) {
      for (const 互斥事件名 of 定义.互斥事件) {
        if (上下文.本周已触发事件?.includes(互斥事件名)) {
          return { 可触发: false, 原因: `与事件[${互斥事件名}]互斥` };
        }
      }
    }

    return { 可触发: true };
  }

  // ─── 事件执行 ───

  执行事件(事件名, 上下文) {
    const 处理器 = this.事件处理器映射.get(事件名);
    if (!处理器) {
      return { 成功: false, 原因: '事件处理器未注册' };
    }

    const 结果 = 处理器(上下文);

    // 记录冷却
    const 定义 = this.事件类型映射.get(事件名);
    if (定义?.冷却周期 > 0) {
      this.事件冷却映射.set(事件名, 上下文.当前周次);
    }

    return 结果;
  }

  // ─── 随机事件池 ───

  计算事件权重(事件名, 上下文) {
    const 权重函数 = this.事件权重映射.get(事件名);
    return 权重函数 ? 权重函数(上下文) : 100;
  }

  获取可触发随机事件池(上下文) {
    const 随机事件列表 = this.获取分类事件列表('随机');
    const 可触发事件 = [];

    for (const 事件 of 随机事件列表) {
      const 检查结果 = this.检查事件条件(事件.名称, 上下文);
      if (检查结果.可触发) {
        const 权重 = this.计算事件权重(事件.名称, 上下文);
        可触发事件.push({ ...事件, 权重 });
      }
    }

    return 可触发事件;
  }

  // ─── 冷却管理 ───

  重置所有冷却() {
    this.事件冷却映射.clear();
  }

  重置事件冷却(事件名) {
    this.事件冷却映射.delete(事件名);
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 事件定义注册表, 任务定义注册表, 商品定义注册表, 属性定义注册表, 法术定义注册表 };
