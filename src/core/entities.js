// ═══════════════════════════════════════════════════════════════
// core/entities.js
// 实体基类与所有实体类型定义
// ═══════════════════════════════════════════════════════════════

/**
 * 实体基类
 * 所有游戏实体的基础，提供属性管理和事件钩子
 */
class 实体基类 {
  constructor(实体类型, 初始数据 = {}) {
    this.实体ID = this.生成唯一ID();
    this.实体类型 = 实体类型;
    this.属性容器 = new Map();
    this.状态标签 = new Set();
    this.元数据 = {
      创建时间: Date.now(),
      ...初始数据.元数据,
    };
    this.事件监听器 = new Map();
  }

  // ─── ID生成 ───

  static #idCounter = 0;

  生成唯一ID() {
    return `${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
  }

  // ─── 属性操作 ───

  设置属性(属性名, 值) {
    const 旧值 = this.属性容器.get(属性名);
    this.属性容器.set(属性名, 值);
    this.触发事件('属性变更', {
      属性名,
      旧值,
      新值: 值,
    });
  }

  获取属性(属性名, 默认值 = null) {
    return this.属性容器.has(属性名) ? this.属性容器.get(属性名) : 默认值;
  }

  修改属性(属性名, 增量, 属性注册表 = null) {
    const 当前值 = this.获取属性(属性名, 0);
    let 新值 = 当前值 + 增量;

    // 如果有属性注册表，应用范围限制
    if (属性注册表) {
      const 配置 = 属性注册表.获取属性配置(属性名);
      if (配置) {
        新值 = Math.max(配置.最小值, Math.min(配置.最大值, 新值));
      }
    }

    this.设置属性(属性名, 新值);
    return 新值;
  }

  批量设置属性(属性对象) {
    Object.entries(属性对象).forEach(([属性名, 值]) => {
      this.设置属性(属性名, 值);
    });
  }

  获取所有属性() {
    return Object.fromEntries(this.属性容器);
  }

  // ─── 状态标签操作 ───

  添加标签(标签) {
    if (!this.状态标签.has(标签)) {
      this.状态标签.add(标签);
      this.触发事件('标签添加', { 标签 });
    }
  }

  移除标签(标签) {
    if (this.状态标签.has(标签)) {
      this.状态标签.delete(标签);
      this.触发事件('标签移除', { 标签 });
    }
  }

  拥有标签(标签) {
    return this.状态标签.has(标签);
  }

  获取所有标签() {
    return Array.from(this.状态标签);
  }

  切换标签(标签) {
    if (this.拥有标签(标签)) {
      this.移除标签(标签);
      return false;
    } else {
      this.添加标签(标签);
      return true;
    }
  }

  // ─── 事件系统 ───

  监听事件(事件名, 处理器) {
    if (!this.事件监听器.has(事件名)) {
      this.事件监听器.set(事件名, []);
    }
    this.事件监听器.get(事件名).push(处理器);

    // 返回取消监听函数
    return () => {
      const 列表 = this.事件监听器.get(事件名);
      const 索引 = 列表?.indexOf(处理器);
      if (索引 !== undefined && 索引 !== -1) {
        列表.splice(索引, 1);
      }
    };
  }

  触发事件(事件名, 数据 = {}) {
    const 处理器列表 = this.事件监听器.get(事件名) ?? [];
    处理器列表.forEach(处理器 => {
      try {
        处理器(数据, this);
      } catch (错误) {
        console.error(`实体事件处理错误 [${事件名}]:`, 错误);
      }
    });
  }

  // ─── 序列化 ───

  序列化() {
    return {
      实体ID: this.实体ID,
      实体类型: this.实体类型,
      属性: Object.fromEntries(this.属性容器),
      标签: Array.from(this.状态标签),
      元数据: { ...this.元数据 },
    };
  }

  static 从序列化恢复(数据, 构造器 = null) {
    const 目标构造器 = 构造器 ?? this;
    const 实体 = new 目标构造器({});

    实体.实体ID = 数据.实体ID;
    实体.实体类型 = 数据.实体类型;

    if (数据.属性) {
      Object.entries(数据.属性).forEach(([k, v]) => {
        实体.属性容器.set(k, v);
      });
    }

    if (数据.标签) {
      数据.标签.forEach(t => 实体.状态标签.add(t));
    }

    实体.元数据 = 数据.元数据 ?? {};

    return 实体;
  }

  // ─── 克隆 ───

  克隆() {
    const 数据 = this.序列化();
    数据.实体ID = this.生成唯一ID(); // 新ID
    return this.constructor.从序列化恢复(数据, this.constructor);
  }
}

// ═══════════════════════════════════════════════════════════════
// 领主实体
// ═══════════════════════════════════════════════════════════════

/**
 * 领主实体
 * 玩家控制的主角，拥有魔力资源
 */
class 领主实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('领主', 初始数据);

    // 核心属性
    this.设置属性('魔力', 初始数据.魔力 ?? 0);
    this.设置属性('最大魔力', 初始数据.最大魔力 ?? 100);
    this.设置属性('姓名', 初始数据.姓名 ?? '无名领主');
  }

  // ─── 魔力操作 ───

  消耗魔力(数量) {
    const 当前魔力 = this.获取属性('魔力');
    if (当前魔力 < 数量) {
      return { 成功: false, 原因: '魔力不足', 当前: 当前魔力, 需要: 数量 };
    }
    this.设置属性('魔力', 当前魔力 - 数量);
    return { 成功: true, 剩余: 当前魔力 - 数量 };
  }

  获得魔力(数量) {
    const 当前魔力 = this.获取属性('魔力');
    const 最大魔力 = this.获取属性('最大魔力');
    const 新魔力 = Math.min(当前魔力 + 数量, 最大魔力);
    const 实际获得 = 新魔力 - 当前魔力;

    this.设置属性('魔力', 新魔力);

    return { 实际获得, 当前: 新魔力, 溢出: 数量 - 实际获得 };
  }

  获取魔力百分比() {
    const 当前 = this.获取属性('魔力');
    const 最大 = this.获取属性('最大魔力');
    return 最大 > 0 ? (当前 / 最大) * 100 : 0;
  }
}

// ═══════════════════════════════════════════════════════════════
// 冠军实体
// ═══════════════════════════════════════════════════════════════

/**
 * 冠军实体
 * 部落的精英战士，拥有三维属性，可统帅喽啰
 */
class 冠军实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('冠军', 初始数据);

    // 基础信息
    this.设置属性('姓名', 初始数据.姓名 ?? '无名冠军');
    this.设置属性('外貌描述', 初始数据.外貌描述 ?? '');
    this.设置属性('性别', 初始数据.性别 ?? '男');

    // 三维属性
    this.设置属性('力量', 初始数据.力量 ?? 10);
    this.设置属性('敏捷', 初始数据.敏捷 ?? 10);
    this.设置属性('智力', 初始数据.智力 ?? 10);

    // 状态属性
    this.设置属性('经验', 初始数据.经验 ?? 0);
    this.设置属性('等级', 初始数据.等级 ?? 1);

    // 成长记录
    this.成长日志 = [];

    // 来源信息
    this.来源信息 = 初始数据.来源信息 ?? null;
  }

  // ─── 属性计算 ───

  计算可统帅喽啰数() {
    return this.获取属性('力量');
  }

  计算总属性值() {
    return this.获取属性('力量') + this.获取属性('敏捷') + this.获取属性('智力');
  }

  获取主属性() {
    const 力量 = this.获取属性('力量');
    const 敏捷 = this.获取属性('敏捷');
    const 智力 = this.获取属性('智力');

    if (力量 >= 敏捷 && 力量 >= 智力) return '力量';
    if (敏捷 >= 力量 && 敏捷 >= 智力) return '敏捷';
    return '智力';
  }

  // ─── 成长系统 ───

  记录成长事件(事件描述, 属性变化 = {}) {
    this.成长日志.push({
      时间戳: Date.now(),
      描述: 事件描述,
      属性变化,
    });
  }

  增加经验(数量) {
    const 当前经验 = this.获取属性('经验');
    const 当前等级 = this.获取属性('等级');
    const 新经验 = 当前经验 + 数量;

    this.设置属性('经验', 新经验);

    // 检查升级（每100经验升一级）
    const 升级阈值 = 当前等级 * 100;
    if (新经验 >= 升级阈值) {
      this.设置属性('等级', 当前等级 + 1);
      this.设置属性('经验', 新经验 - 升级阈值);
      return { 升级: true, 新等级: 当前等级 + 1 };
    }

    return { 升级: false };
  }

  // ─── 状态检查 ───

  是否可战斗() {
    return !this.拥有标签('负伤') && !this.拥有标签('外出');
  }

  是否可执行任务() {
    return !this.拥有标签('休息中') && !this.拥有标签('外出');
  }

  // ─── 序列化扩展 ───

  序列化() {
    const 基础数据 = super.序列化();
    return {
      ...基础数据,
      成长日志: [...this.成长日志],
      来源信息: this.来源信息 ? { ...this.来源信息 } : null,
    };
  }

  static 从序列化恢复(数据) {
    const 实体 = super.从序列化恢复(数据, 冠军实体);
    实体.成长日志 = 数据.成长日志 ?? [];
    实体.来源信息 = 数据.来源信息 ?? null;
    return 实体;
  }
}

// ═══════════════════════════════════════════════════════════════
// 母畜实体
// ═══════════════════════════════════════════════════════════════

/**
 * 母畜实体
 * 被俘获的女性，拥有雌性价值、臣服度、淫乱度
 */
class 母畜实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('母畜', 初始数据);

    // 身份信息
    this.设置属性('姓名', 初始数据.姓名 ?? '无名母畜');
    this.设置属性('原身份', 初始数据.原身份 ?? '普通人');
    this.设置属性('种族', 初始数据.种族 ?? '人类');
    this.设置属性('外貌描述', 初始数据.外貌描述 ?? '');
    this.设置属性('年龄', 初始数据.年龄 ?? 20);

    // 核心属性
    const 总雌性价值 = 初始数据.总雌性价值 ?? 100;
    this.设置属性('总雌性价值', 总雌性价值);
    this.设置属性('剩余雌性价值', 初始数据.剩余雌性价值 ?? 总雌性价值);
    this.设置属性('臣服度', 初始数据.臣服度 ?? 0);
    this.设置属性('淫乱度', 初始数据.淫乱度 ?? 0);

    // 特殊标签
    if (初始数据.特殊标签) {
      初始数据.特殊标签.forEach(标签 => this.添加标签(标签));
    }

    // 生育记录
    this.生育记录 = {
      冠军: [],
      喽啰总数: 0,
    };
  }

  // ─── 阶段判定 ───

  获取臣服阶段() {
    const 臣服度 = this.获取属性('臣服度');

    if (臣服度 >= 90) return { 名称: '忠诚期', 等级: 5 };
    if (臣服度 >= 75) return { 名称: '归心期', 等级: 4 };
    if (臣服度 >= 50) return { 名称: '顺从期', 等级: 3 };
    if (臣服度 >= 25) return { 名称: '动摇期', 等级: 2 };
    return { 名称: '抗拒期', 等级: 1 };
  }

  获取淫乱阶段() {
    const 淫乱度 = this.获取属性('淫乱度');

    if (淫乱度 >= 100) return { 名称: '完全淫堕', 等级: 5 };
    if (淫乱度 >= 75) return { 名称: '淫堕期', 等级: 4 };
    if (淫乱度 >= 50) return { 名称: '渴求期', 等级: 3 };
    if (淫乱度 >= 25) return { 名称: '泌乳期', 等级: 2 };
    return { 名称: '常态期', 等级: 1 };
  }

  // ─── 能力判定 ───

  可担任任务类型列表() {
    const 臣服度 = this.获取属性('臣服度');
    const 淫乱度 = this.获取属性('淫乱度');
    const 剩余价值 = this.获取属性('剩余雌性价值');
    const 可用任务 = [];

    // 基础：繁殖相关
    if (剩余价值 > 0) {
      if (臣服度 >= 25) {
        可用任务.push('生育喽啰');
      }
      if (剩余价值 >= 100) {
        可用任务.push('生育冠军');
      }
    }

    // 泌乳期以上：泌乳
    if (淫乱度 >= 25) {
      可用任务.push('泌乳');
    }

    // 归心期以上：提振士气、劝慰
    if (臣服度 >= 75) {
      可用任务.push('提振士气');
      可用任务.push('劝慰');
    }

    // 忠诚期：潜入类任务
    if (臣服度 >= 90) {
      可用任务.push('潜入侦察');
      可用任务.push('潜入劝诱');
    }

    // 完全淫堕：可献祭
    if (淫乱度 >= 100) {
      可用任务.push('献祭母畜');
    }

    return 可用任务;
  }

  // ─── 资源消耗 ───

  消耗雌性价值(数量) {
    const 剩余 = this.获取属性('剩余雌性价值');
    if (剩余 < 数量) {
      return { 成功: false, 原因: '剩余雌性价值不足', 当前: 剩余, 需要: 数量 };
    }
    this.设置属性('剩余雌性价值', 剩余 - 数量);
    return { 成功: true, 剩余: 剩余 - 数量 };
  }

  获取雌性价值百分比() {
    const 剩余 = this.获取属性('剩余雌性价值');
    const 总量 = this.获取属性('总雌性价值');
    return 总量 > 0 ? (剩余 / 总量) * 100 : 0;
  }

  // ─── 产出计算 ───

  计算泌乳产量() {
    const 淫乱度 = this.获取属性('淫乱度');
    if (淫乱度 < 25) return 0;
    return Math.floor((淫乱度 + 45) / 20);
  }

  // ─── 生育记录 ───

  记录生育冠军(冠军ID, 冠军姓名) {
    this.生育记录.冠军.push({
      冠军ID,
      冠军姓名,
      时间戳: Date.now(),
    });
  }

  记录生育喽啰(数量) {
    this.生育记录.喽啰总数 += 数量;
  }

  获取生育统计() {
    return {
      冠军数量: this.生育记录.冠军.length,
      喽啰总数: this.生育记录.喽啰总数,
      冠军详情: [...this.生育记录.冠军],
    };
  }

  // ─── 序列化扩展 ───

  序列化() {
    const 基础数据 = super.序列化();
    return {
      ...基础数据,
      生育记录: {
        冠军: [...this.生育记录.冠军],
        喽啰总数: this.生育记录.喽啰总数,
      },
    };
  }

  static 从序列化恢复(数据) {
    const 实体 = super.从序列化恢复(数据, 母畜实体);
    实体.生育记录 = 数据.生育记录 ?? { 冠军: [], 喽啰总数: 0 };
    return 实体;
  }
}

// ═══════════════════════════════════════════════════════════════
// 喽啰池
// ═══════════════════════════════════════════════════════════════

/**
 * 喽啰池
 * 喽啰以数值形式存在，按武装等级分组管理
 */
class 喽啰池 {
  constructor() {
    this.武装分组 = new Map();

    // 默认分组：未武装
    this.武装分组.set('未武装', {
      数量: 0,
      战斗力: 100,
      描述: '未经武装的喽啰',
    });
  }

  // ─── 武装等级管理 ───

  注册武装等级(等级名, 配置) {
    if (!this.武装分组.has(等级名)) {
      this.武装分组.set(等级名, {
        数量: 0,
        战斗力: 配置.战斗力 ?? 100,
        描述: 配置.描述 ?? '',
        升级自: 配置.升级自 ?? null,
        升级消耗: 配置.升级消耗 ?? null,
      });
    }
  }

  获取武装等级配置(等级名) {
    return this.武装分组.get(等级名);
  }

  获取所有武装等级() {
    return Array.from(this.武装分组.keys());
  }

  // ─── 数量操作 ───

  增加喽啰(数量, 武装等级 = '未武装') {
    const 分组 = this.武装分组.get(武装等级);
    if (!分组) {
      console.warn(`未知武装等级: ${武装等级}，添加到未武装`);
      this.武装分组.get('未武装').数量 += 数量;
      return;
    }
    分组.数量 += 数量;
  }

  减少喽啰(数量, 武装等级 = '未武装') {
    const 分组 = this.武装分组.get(武装等级);
    if (!分组) return { 成功: false, 原因: '未知武装等级' };

    const 实际减少 = Math.min(数量, 分组.数量);
    分组.数量 -= 实际减少;

    return {
      成功: true,
      实际减少,
      剩余: 分组.数量,
    };
  }

  获取分组数量(武装等级) {
    return this.武装分组.get(武装等级)?.数量 ?? 0;
  }

  // ─── 武装升级 ───

  武装升级(数量, 从等级, 到等级) {
    const 源分组 = this.武装分组.get(从等级);
    const 目标分组 = this.武装分组.get(到等级);

    if (!源分组) return { 成功: false, 原因: `未知来源等级: ${从等级}` };
    if (!目标分组) return { 成功: false, 原因: `未知目标等级: ${到等级}` };
    if (源分组.数量 < 数量) {
      return {
        成功: false,
        原因: '来源分组数量不足',
        当前: 源分组.数量,
        需要: 数量,
      };
    }

    源分组.数量 -= 数量;
    目标分组.数量 += 数量;

    return {
      成功: true,
      升级数量: 数量,
      来源剩余: 源分组.数量,
      目标当前: 目标分组.数量,
    };
  }

  批量武装升级(配置列表, 事务模式 = false) {
    /**
     * 配置列表格式: [{ 数量, 从等级, 到等级 }, ...]
     */
    const 结果列表 = [];

    if (事务模式) {
      // 先验证全部可行
      for (const 配置 of 配置列表) {
        if (this.获取分组数量(配置.从等级) < 配置.数量) {
          return { 成功: false, 原因: `${配置.从等级} 数量不足` };
        }
      }
    }

    for (const 配置 of 配置列表) {
      const 结果 = this.武装升级(配置.数量, 配置.从等级, 配置.到等级);
      结果列表.push({ ...配置, ...结果 });

      if (!结果.成功) break; // 失败时中断
    }

    return 结果列表;
  }

  // ─── 统计 ───

  获取总数量() {
    let 总数 = 0;
    this.武装分组.forEach(分组 => {
      总数 += 分组.数量;
    });
    return 总数;
  }

  获取分组详情() {
    return Array.from(this.武装分组.entries()).map(([等级, 数据]) => ({
      等级,
      ...数据,
    }));
  }

  计算加权战斗力() {
    let 加权总和 = 0;
    let 总数量 = 0;

    this.武装分组.forEach(分组 => {
      加权总和 += 分组.数量 * 分组.战斗力;
      总数量 += 分组.数量;
    });

    return 总数量 > 0 ? 加权总和 / 总数量 : 100;
  }

  计算总战斗力() {
    let 总战力 = 0;
    this.武装分组.forEach(分组 => {
      总战力 += 分组.数量 * (分组.战斗力 / 100);
    });
    return 总战力;
  }

  // ─── 分配喽啰 ───

  分配喽啰(需求数量, 优先等级列表 = null) {
    /**
     * 按优先级分配喽啰，返回分配结果
     * 优先等级列表: ['高级', '中级', '低级', '未武装']
     */
    const 等级顺序 = 优先等级列表 ?? Array.from(this.武装分组.keys()).reverse();
    const 分配结果 = [];
    let 剩余需求 = 需求数量;

    for (const 等级 of 等级顺序) {
      if (剩余需求 <= 0) break;

      const 分组 = this.武装分组.get(等级);
      if (!分组 || 分组.数量 === 0) continue;

      const 分配数量 = Math.min(剩余需求, 分组.数量);
      分配结果.push({
        等级,
        数量: 分配数量,
        战斗力: 分组.战斗力,
      });

      剩余需求 -= 分配数量;
    }

    return {
      分配详情: 分配结果,
      已分配: 需求数量 - 剩余需求,
      未满足: 剩余需求,
    };
  }

  // ─── 序列化 ───

  序列化() {
    return {
      分组: Array.from(this.武装分组.entries()).map(([等级, 数据]) => ({
        等级,
        ...数据,
      })),
    };
  }

  static 从序列化恢复(数据) {
    const 池 = new 喽啰池();
    池.武装分组.clear();

    if (数据.分组) {
      数据.分组.forEach(分组数据 => {
        const { 等级, ...配置 } = 分组数据;
        池.武装分组.set(等级, 配置);
      });
    }

    return 池;
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 实体基类, 领主实体, 冠军实体, 母畜实体, 喽啰池 };
