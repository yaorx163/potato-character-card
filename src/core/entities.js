// ═══════════════════════════════════════════════════════════════
// core/entities.js
// 实体基类与所有实体类型定义
// ═══════════════════════════════════════════════════════════════
/**
 * 实体基类
 * 所有游戏实体的基础，提供属性管理和事件钩子
 */
class 实体基类 {
  constructor(实体类型, 初始数据 = {}) {
    this.实体ID = this.生成唯一ID();
    this.实体类型 = 实体类型;
    this.属性容器 = new Map();
    this.元数据 = {
      创建时间: Date.now(),
      ...初始数据.元数据,
    };
    this.事件监听器 = new Map();
    this.属性约束 = 初始数据.属性约束 ?? new Map();
  }

  // ─── ID生成 ───

  生成唯一ID() {
    return `${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
  }

  // ─── 属性操作 ───
  
  设置属性约束(属性名, 最小值, 最大值) {
    this.属性约束.set(属性名, { 最小值, 最大值 });
  }

  设置属性(属性名, 值) {
    const 旧值 = this.属性容器.get(属性名);
    this.属性容器.set(属性名, 值);
    this.触发事件('属性变更', {
      属性名,
      旧值,
      新值: 值,
    });
  }

  获取属性(属性名, 默认值 = null) {
    return this.属性容器.has(属性名) ? this.属性容器.get(属性名) : 默认值;
  }

  修改属性(属性名, 增量) {
    const 当前值 = this.获取属性(属性名, 0);
    let 新值 = 当前值 + 增量;

    const 约束 = this.属性约束.get(属性名);
    if (约束) {
      新值 = Math.max(约束.最小值, Math.min(约束.最大值, 新值));
    }

    this.设置属性(属性名, 新值);
    return 新值;
  }

  批量设置属性(属性对象) {
    Object.entries(属性对象).forEach(([属性名, 值]) => {
      this.设置属性(属性名, 值);
    });
  }

  获取所有属性() {
    return Object.fromEntries(this.属性容器);
  }

  // ─── 事件系统 ───

  监听事件(事件名, 处理器) {
    if (!this.事件监听器.has(事件名)) {
      this.事件监听器.set(事件名, []);
    }
    this.事件监听器.get(事件名).push(处理器);

    // 返回取消监听函数
    return () => {
      const 列表 = this.事件监听器.get(事件名);
      const 索引 = 列表?.indexOf(处理器);
      if (索引 !== undefined && 索引 !== -1) {
        列表.splice(索引, 1);
      }
    };
  }

  触发事件(事件名, 数据 = {}) {
    const 处理器列表 = this.事件监听器.get(事件名) ?? [];
    处理器列表.forEach(处理器 => {
      try {
        处理器(数据, this);
      } catch (错误) {
        console.error(`实体事件处理错误 [${事件名}]:`, 错误);
      }
    });
  }

  销毁() {
    this.触发事件('实体销毁');
    this.事件监听器.clear();
  }
}

// ═══════════════════════════════════════════════════════════════
// 领主实体
// ═══════════════════════════════════════════════════════════════

/**
 * 领主实体
 * 玩家控制的主角，拥有魔力资源
 */
class 领主实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('领主', 初始数据);

    // 核心属性
    this.设置属性('魔力', 初始数据.魔力 ?? 0);
    this.设置属性('最大魔力', 初始数据.最大魔力 ?? 100);
    this.设置属性('姓名', 初始数据.姓名 ?? '无名领主');
  }

  // ─── 魔力操作 ───

  消耗魔力(数量) {
    const 当前魔力 = this.获取属性('魔力');
    if (当前魔力 < 数量) {
      return { 成功: false, 原因: '魔力不足', 当前: 当前魔力, 需要: 数量 };
    }
    this.设置属性('魔力', 当前魔力 - 数量);
    return { 成功: true, 剩余: 当前魔力 - 数量 };
  }

  获得魔力(数量) {
    const 当前魔力 = this.获取属性('魔力');
    const 最大魔力 = this.获取属性('最大魔力');
    const 新魔力 = Math.min(当前魔力 + 数量, 最大魔力);
    const 实际获得 = 新魔力 - 当前魔力;

    this.设置属性('魔力', 新魔力);

    return { 实际获得, 当前: 新魔力, 溢出: 数量 - 实际获得 };
  }

  获取魔力百分比() {
    const 当前 = this.获取属性('魔力');
    const 最大 = this.获取属性('最大魔力');
    return 最大 > 0 ? (当前 / 最大) * 100 : 0;
  }
}

// ═══════════════════════════════════════════════════════════════
// 冠军实体
// ═══════════════════════════════════════════════════════════════

/**
 * 冠军实体
 * 部落的精英战士，拥有三维属性，可统帅喽啰
 */
class 冠军实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('冠军', 初始数据);

    // 基础信息
    this.设置属性('姓名', 初始数据.姓名 ?? '无名冠军');
    this.设置属性('外貌描述', 初始数据.外貌描述 ?? '');
    this.设置属性('性别', 初始数据.性别 ?? '男');

    // 三维属性
    this.设置属性('力量', 初始数据.力量 ?? 10);
    this.设置属性('敏捷', 初始数据.敏捷 ?? 10);
    this.设置属性('智力', 初始数据.智力 ?? 10);

    // 来源信息
    this.来源信息 = 初始数据.来源信息 ?? {};
  }

  // ─── 属性计算 ───

  计算可统帅喽啰数() {
    return this.获取属性('力量');
  }

  计算总属性值() {
    return this.获取属性('力量') + this.获取属性('敏捷') + this.获取属性('智力');
  }

  获取主属性() {
    const 力量 = this.获取属性('力量');
    const 敏捷 = this.获取属性('敏捷');
    const 智力 = this.获取属性('智力');

    if (力量 >= 敏捷 && 力量 >= 智力) return '力量';
    if (敏捷 >= 力量 && 敏捷 >= 智力) return '敏捷';
    return '智力';
  }

}

// ═══════════════════════════════════════════════════════════════
// 母畜实体
// ═══════════════════════════════════════════════════════════════


/**
 * 母畜实体 - 统一表示所有女性目标（无论是否已捕获）
 */
class 母畜实体 extends 实体基类 {
  // 捕获状态枚举
  static 捕获状态 = {
    未发现: 'undiscovered',
    已侦察: 'scouted',
    已锁定: 'locked',
    已捕获: 'captured'
  };

  constructor(配置 = {}) {
    super('母畜');

    // ===== 基础身份信息 =====
    this.设置属性('姓名', 配置.姓名 ?? '无名');
    this.设置属性('种族', 配置.种族 ?? '人类');
    this.设置属性('年龄', 配置.年龄 ?? 20);
    this.设置属性('原身份', 配置.原身份 ?? '平民');
    this.设置属性('来源', 配置.来源 ?? '未知');
    this.设置属性('描述', 配置.描述 ?? '');


    // ===== 捕获状态管理 =====
    this.捕获状态 = 配置.捕获状态 || 母畜实体.捕获状态.未发现;
    this.来源地点ID = 配置.来源地点ID || null;      // 来自哪个可袭击地点
    this.侦察回合 = 配置.侦察回合 || null;          // 何时被发现
    this.锁定回合 = 配置.锁定回合 || null;          // 何时被锁定
    this.捕获回合 = 配置.捕获回合 || null;          // 何时被捕获
    this.锁定负责人ID = 配置.锁定负责人ID || null;  // 谁负责锁定/抓捕

    // ===== 核心属性（修复初始化顺序） =====
    const 总值 = 配置.总雌性价值 ?? 100;
    const 剩余值 = 配置.剩余雌性价值 ?? 总值;
    this.设置属性('总雌性价值', 总值);
    this.设置属性('剩余雌性价值', Math.max(0, Math.min(剩余值, 总值)));

    this.设置属性('淫乱度', 配置.淫乱度 ?? 0);
    this.设置属性('臣服度', 配置.臣服度 ?? 0);

    // ===== 特性与状态 =====
    this.特性列表 = new Set(配置.特性列表 || []);
    this.冠军生育记录 = 配置.冠军生育记录 || [];
    this.喽啰生育记录 = 配置.喽啰生育记录 || 0;

  }

  // ===== 捕获状态查询 =====

  是否已捕获() {
    return this.捕获状态 === 母畜实体.捕获状态.已捕获;
  }

  是否已锁定() {
    return this.捕获状态 === 母畜实体.捕获状态.已锁定;
  }

  是否已侦察() {
    return this.捕获状态 === 母畜实体.捕获状态.已侦察 ||
           this.捕获状态 === 母畜实体.捕获状态.已锁定;
  }

  是否可锁定() {
    return this.捕获状态 === 母畜实体.捕获状态.已侦察;
  }

  是否可抓捕() {
    return this.捕获状态 === 母畜实体.捕获状态.已锁定;
  }

  // ===== 捕获状态转换 =====

  /**
   * 标记为已侦察
   */
  标记侦察(回合数) {
    if (this.捕获状态 !== 母畜实体.捕获状态.未发现) {
      return { 成功: false, 原因: '目标母畜已被侦察过' };
    }

    this.捕获状态 = 母畜实体.捕获状态.已侦察;
    this.侦察回合 = 回合数;

    return { 成功: true };
  }

  /**
   * 锁定母畜
   */
  锁定(回合数, 负责人ID) {
    if (!this.是否可锁定()) {
      return { 成功: false, 原因: '目标母畜状态不允许锁定' };
    }

    this.捕获状态 = 母畜实体.捕获状态.已锁定;
    this.锁定回合 = 回合数;
    this.锁定负责人ID = 负责人ID;

    return { 成功: true };
  }

  /**
   * 解除锁定
   */
  解除锁定() {
    if (!this.是否已锁定()) {
      return { 成功: false, 原因: '目标母畜未被锁定' };
    }

    this.捕获状态 = 母畜实体.捕获状态.已侦察;
    this.锁定回合 = null;
    this.锁定负责人ID = null;

    return { 成功: true };
  }

  /**
   * 标记为已捕获
   */
  标记捕获(回合数) {
    if (this.是否已捕获()) {
      return { 成功: false, 原因: '目标母畜已被捕获' };
    }

    this.捕获状态 = 母畜实体.捕获状态.已捕获;
    this.捕获回合 = 回合数;

    return { 成功: true };
  }

  消耗雌性价值(数量) {
    const 当前 = this.获取属性('剩余雌性价值');
    if (当前 < 数量) {
      return { 成功: false, 原因: '雌性价值不足', 当前, 需要: 数量 };
    }
    this.设置属性('剩余雌性价值', 当前 - 数量);
    return { 成功: true, 剩余: 当前 - 数量 };
  }

  添加特性(特性名) {
    this.特性列表.add(特性名);
  }

  移除特性(特性名) {
    this.特性列表.delete(特性名);
  }

  拥有特性(特性名) {
    return this.特性列表.has(特性名);
  }


  记录生育冠军(冠军实体ID) {
    this.冠军生育记录.push(冠军实体ID);
  }

  记录生育喽啰(实际产出) {
    if (实际产出 <= 0){
      return;
    }
    this.喽啰生育记录 += 实际产出;
  }
}


// ═══════════════════════════════════════════════════════════════
// 喽啰池
// ═══════════════════════════════════════════════════════════════

/**
 * 喽啰池
 * 喽啰以数值形式存在，按武装等级分组管理
 */
class 喽啰池 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('喽啰池', 初始数据);
    this.武装分组 = new Map();
    this.将领 = 初始数据.将领 ?? null;

    // 默认分组：未武装
    this.武装分组.set('未武装', {
      数量: 0,
      战斗力: 100,
      描述: '未经武装的喽啰',
    });
  }

  // ─── 武装等级管理 ───

  注册武装等级(等级名, 配置) {
    if (!this.武装分组.has(等级名)) {
      this.武装分组.set(等级名, {
        数量: 0,
        战斗力: 配置.战斗力 ?? 100,
        描述: 配置.描述 ?? '',
      });
    }
  }

  获取武装等级配置(等级名) {
    return this.武装分组.get(等级名);
  }

  获取所有武装等级() {
    return Array.from(this.武装分组.keys());
  }

  // ─── 数量操作 ───

  增加喽啰(数量, 武装等级 = '未武装') {
    const 分组 = this.武装分组.get(武装等级);
    if (!分组) {
      console.warn(`未知武装等级: ${武装等级}，添加到未武装`);
      this.武装分组.get('未武装').数量 += 数量;
      return;
    }
    分组.数量 += 数量;
  }

  减少喽啰(数量, 武装等级 = '未武装') {
    const 分组 = this.武装分组.get(武装等级);
    if (!分组) return { 成功: false, 原因: '未知武装等级' };

    const 实际减少 = Math.min(数量, 分组.数量);
    分组.数量 -= 实际减少;

    return {
      成功: true,
      实际减少,
      剩余: 分组.数量,
    };
  }

  获取分组数量(武装等级) {
    return this.武装分组.get(武装等级)?.数量 ?? 0;
  }

  // ─── 武装升级 ───

  武装升级(数量, 目标等级, 优先等级列表 = null) {
    if (!this.武装分组.has(目标等级)) {
      return { 升级数量: 0, 溢出数量: 数量 };
    }
  
    const 等级顺序 = 优先等级列表 || ['未武装'];
    const 目标索引 = 等级顺序.indexOf(目标等级);
  
    if (目标索引 <= 0) {
      return { 升级数量: 0, 溢出数量: 数量 };
    }
  
    let 剩余需求 = 数量;
    let 总升级数量 = 0;
  
    // 从低到高遍历目标等级之前的所有等级
    for (let i = 0; i < 目标索引 && 剩余需求 > 0; i++) {
      if (!this.武装分组.has(目标等级)) {
        return { 升级数量: 0, 溢出数量: 数量 };
      }
    
      const 目标分组 = this.武装分组.get(目标等级);
      const 来源等级 = 等级顺序[i];
      const 来源分组 = this.武装分组.get(来源等级);
  
      if (!来源分组 || 来源分组.数量 <= 0) continue;
  
      const 可升级数量 = Math.min(来源分组.数量, 剩余需求);
  
      // 从来源等级扣除
      来源分组.数量 -= 可升级数量;
      // 添加到目标等级
      目标分组.数量 += 可升级数量;
  
      总升级数量 += 可升级数量;
      剩余需求 -= 可升级数量;
    }
  
    return {
      升级数量: 总升级数量,
      溢出数量: 剩余需求
    };
  }

  // ─── 统计 ───

  获取最大数量() {
    if (this.将领){
      return this.将领.计算可统帅喽啰数();
    }
    return Infinity
  }

  获取总数量() {
    let 总数 = 0;
    this.武装分组.forEach(分组 => {
      总数 += 分组.数量;
    });
    return 总数;
  }

  获取分组详情() {
    return Array.from(this.武装分组.entries()).map(([等级, 数据]) => ({
      等级,
      ...数据,
    }));
  }

  计算总战斗力() {
    let 总战力 = 0;
    this.武装分组.forEach(分组 => {
      总战力 += 分组.数量 * (分组.战斗力 / 100);
    });
    return 总战力;
  }

  // ─── 分配喽啰 ───

  分配喽啰(目标喽啰池, 需求数量, 优先等级列表 = null) {
    const 等级顺序 = 优先等级列表 || this.获取所有武装等级();
    const 目标容量 = 目标喽啰池.获取最大数量();
    const 目标当前数量 = 目标喽啰池.获取总数量();
    const 可接收数量 = Math.min(需求数量, 目标容量 - 目标当前数量);
  
    if (可接收数量 <= 0) {
      return {
        成功: false,
        原因: '目标喽啰池已满或无需分配',
        分配数量: 0,
        分配详情: []
      };
    }
  
    let 剩余分配 = 可接收数量;
    const 分配详情 = [];
  
    // 按优先级从高到低遍历等级
    for (const 等级 of 等级顺序) {
      if (剩余分配 <= 0) break;
  
      const 来源分组 = this.武装分组.get(等级);
      if (!来源分组 || 来源分组.数量 <= 0) continue;

      if (目标喽啰池.武装分组.get(等级) === undefined) {
        目标喽啰池.注册武装等级(等级, {
          战斗力: 来源分组.战斗力,
          描述: 来源分组.描述
        });
      }
  
      const 本次分配 = Math.min(来源分组.数量, 剩余分配);
  
      // 从自身扣除
      来源分组.数量 -= 本次分配;
      // 添加到目标
      目标喽啰池.增加喽啰(本次分配, 等级);
  
      分配详情.push({
        等级,
        数量: 本次分配
      });
  
      剩余分配 -= 本次分配;
    }
  
    const 总分配数量 = 可接收数量 - 剩余分配;
  
    return {
      成功: 总分配数量 > 0,
      分配数量: 总分配数量,
      未满足数量: 需求数量 - 总分配数量,
      分配详情
    };
  }
}

// ═══════════════════════════════════════════════════════════════
// 可袭击地点实体
// ═══════════════════════════════════════════════════════════════

/**
 * 可袭击地点实体
 * 表示一个可被袭击的地点（村庄、商队、城市等）
 */
class 可袭击地点实体 extends 实体基类 {
  constructor(配置 = {}) {
    super('可袭击地点');

    // ===== 基础信息 =====
    this.地点名称 = 配置.地点名称 || '未知地点';
    this.地点类型 = 配置.地点类型 || '村庄';
    this.描述 = 配置.描述 || '';
    this.侦察最大值 = 配置.侦察最大值 ?? 100;
    this.侦察进度 = 配置.侦察进度 ?? 0;

    // ===== 战斗相关 =====
    this.设置属性('战斗力', 配置.战斗力 ?? 100);

    // ===== 地点内的母畜 =====
    this.潜在地点母畜池 = new Map();
    this.已侦察母畜 = new Map();

  }

  // ===== 潜在母畜管理 =====

  /**
   * 添加潜在母畜（创建母畜时使用）
   */
  添加潜在母畜(母畜实体) {
    母畜实体.来源地点ID = this.实体ID;
    this.潜在地点母畜池.set(母畜实体.实体ID, 母畜实体);
  }

  /**
   * 获取一个随机未侦察母畜用于侦察
   */
  获取随机潜在母畜() {
    const 母畜列表 = [...this.潜在地点母畜池.values()];
    if (母畜列表.length === 0) return null;

    return 母畜列表[Math.floor(Math.random() * 母畜列表.length)];
  }

  /**
   * 将母畜从潜在池移动到已侦察
   */
  标记母畜已侦察(母畜实体ID) {
    const 母畜 = this.潜在地点母畜池.get(母畜实体ID);
    if (!母畜) return null;

    this.潜在地点母畜池.delete(母畜实体ID);
    this.已侦察母畜.set(母畜实体ID, 母畜);

    return 母畜;
  }

  /**
   * 母畜被捕获后从已侦察列表移除
   */
  移除已捕获母畜(母畜实体ID) {
    return this.已侦察母畜.delete(母畜实体ID);
  }

  增加侦察进度(增量) {
    this.侦察进度 = Math.min(this.侦察进度 + 增量, this.侦察最大值);
    return this.侦察进度;
  }
  
  是否侦察完成() {
    if (this.潜在地点母畜池.size === 0) {
      return true;
    }
    return this.侦察进度 >= this.侦察最大值;
  }
  // ===== 母畜查询 =====

  获取所有已侦察母畜() {
    return [...this.已侦察母畜.values()];
  }

  获取已锁定母畜() {
    return [...this.已侦察母畜.values()].filter(m => m.是否已锁定());
  }

  获取可锁定母畜() {
    return [...this.已侦察母畜.values()].filter(m => m.是否可锁定());
  }

  获取母畜(母畜实体ID) {
    return this.已侦察母畜.get(母畜实体ID) || this.潜在地点母畜池.get(母畜实体ID);
  }

  获取潜在母畜数量() {
    return this.潜在地点母畜池.size;
  }

  获取已侦察母畜数量() {
    return this.已侦察母畜.size;
  }
}


// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 实体基类, 领主实体, 冠军实体, 母畜实体, 喽啰池, 可袭击地点实体 };
