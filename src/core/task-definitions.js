// ═══════════════════════════════════════════════════════════════
// core/task-definitions.js
// 具体任务定义 - 所有任务的详细逻辑实现
// ═══════════════════════════════════════════════════════════════

import { 任务基类, 任务注册表 } from './task-system.js';

// ═══════════════════════════════════════════════════════════════
// 调教类任务
// ═══════════════════════════════════════════════════════════════

/**
 * 调教任务
 * 行动者：冠军 → 目标：母畜
 * 效果：增加母畜淫乱度
 */
class 调教任务 extends 任务基类 {
  constructor(配置 = {}) {
    super({
      任务ID: 'train_breeder',
      任务名称: '调教',
      描述: '让冠军调教母畜，增加其淫乱度',
      行动点消耗: 1,
      需要行动者类型: 任务基类.行动者类型.冠军,
      需要目标类型: 任务基类.目标类型.母畜,
      标签: ['调教', '母畜操作'],
      ...配置
    });

    this.基础增幅 = 配置.基础增幅 ?? 5;
    this.智力系数 = 配置.智力系数 ?? 0.5;
    this.力量系数 = 配置.力量系数 ?? 0.3;
  }

  验证前置条件(上下文) {
    const { 目标 } = 上下文;

    if (!目标.是否已捕获()) {
      return { 有效: false, 原因: '目标母畜尚未被捕获' };
    }

    return { 有效: true };
  }

  计算淫乱度增量(冠军, 母畜) {
    const 冠军智力 = 冠军.获取属性('智力');
    const 冠军力量 = 冠军.获取属性('力量');
    const 母畜臣服度 = 母畜.获取属性('臣服度');

    const 臣服系数 = 1 + (母畜臣服度 / 100) * 0.5;

    const 增量 = Math.floor(
      (this.基础增幅 +
       冠军智力 * this.智力系数 +
       冠军力量 * this.力量系数) * 臣服系数
    );

    return Math.max(1, 增量);
  }

  执行(上下文) {
    const { 行动者: 冠军, 目标: 母畜 } = 上下文;

    const 增量 = this.计算淫乱度增量(冠军, 母畜);
    const 原值 = 母畜.获取属性('淫乱度');
    母畜.修改属性('淫乱度', 增量);
    const 新值 = 母畜.获取属性('淫乱度');

    return this.创建成功结果(
      {
        类型: '属性变更',
        目标: 母畜.实体ID,
        属性: '淫乱度',
        原值,
        增量,
        新值
      },
      `${冠军.获取属性('姓名')}调教了${母畜.获取属性('姓名')}，淫乱度+${增量}`
    );
  }

  预览效果(上下文) {
    const { 行动者: 冠军, 目标: 母畜 } = 上下文;

    if (!冠军 || !母畜) {
      return { 描述: this.描述 };
    }

    const 预估增量 = this.计算淫乱度增量(冠军, 母畜);

    return {
      描述: this.描述,
      预估: {
        淫乱度增量: {
          最小: Math.floor(预估增量 * 0.8),
          期望: 预估增量,
          最大: Math.floor(预估增量 * 1.2)
        }
      }
    };
  }
}

/**
 * 驯服任务
 * 行动者：冠军 → 目标：母畜
 * 效果：增加母畜臣服度
 */
class 驯服任务 extends 任务基类 {
  constructor(配置 = {}) {
    super({
      任务ID: 'tame_breeder',
      任务名称: '驯服',
      描述: '让冠军驯服母畜，增加其臣服度',
      行动点消耗: 1,
      需要行动者类型: 任务基类.行动者类型.冠军,
      需要目标类型: 任务基类.目标类型.母畜,
      标签: ['调教', '母畜操作'],
      ...配置
    });

    this.基础增幅 = 配置.基础增幅 ?? 3;
    this.智力系数 = 配置.智力系数 ?? 0.4;
  }

  验证前置条件(上下文) {
    const { 目标 } = 上下文;

    if (!目标.是否已捕获()) {
      return { 有效: false, 原因: '目标母畜尚未被捕获' };
    }

    return { 有效: true };
  }

  计算臣服度增量(冠军, 母畜) {
    const 冠军智力 = 冠军.获取属性('智力');
    const 当前臣服度 = 母畜.获取属性('臣服度');

    // 臣服度越高，越难继续提升
    const 递减系数 = Math.max(0.2, 1 - 当前臣服度 / 150);

    const 增量 = Math.floor(
      (this.基础增幅 + 冠军智力 * this.智力系数) * 递减系数
    );

    return Math.max(1, 增量);
  }

  执行(上下文) {
    const { 行动者: 冠军, 目标: 母畜 } = 上下文;

    const 增量 = this.计算臣服度增量(冠军, 母畜);
    const 原值 = 母畜.获取属性('臣服度');
    母畜.修改属性('臣服度', 增量);
    const 新值 = 母畜.获取属性('臣服度');

    return this.创建成功结果(
      {
        类型: '属性变更',
        目标: 母畜.实体ID,
        属性: '臣服度',
        原值,
        增量,
        新值
      },
      `${冠军.获取属性('姓名')}驯服了${母畜.获取属性('姓名')}，臣服度+${增量}`
    );
  }

  预览效果(上下文) {
    const { 行动者: 冠军, 目标: 母畜 } = 上下文;

    if (!冠军 || !母畜) {
      return { 描述: this.描述 };
    }

    const 预估增量 = this.计算臣服度增量(冠军, 母畜);

    return {
      描述: this.描述,
      预估: {
        臣服度增量: { 期望: 预估增量 }
      }
    };
  }
}

// ═══════════════════════════════════════════════════════════════
// 侦察与抓捕类任务
// ═══════════════════════════════════════════════════════════════

/**
 * 侦察任务
 * 行动者：母畜 → 目标：地点
 * 效果：增加地点侦察进度，可能发现新母畜
 */
class 侦察任务 extends 任务基类 {
  constructor(配置 = {}) {
    super({
      任务ID: 'scout_location',
      任务名称: '侦察',
      描述: '派遣母畜前往目标地点侦察，收集情报并可能发现新的目标',
      行动点消耗: 1,
      需要行动者类型: 任务基类.行动者类型.母畜,
      需要目标类型: 任务基类.目标类型.地点,
      标签: ['侦察', '外勤'],
      ...配置
    });

    this.基础侦察效率 = 配置.基础侦察效率 ?? 10;
    this.发现母畜基础概率 = 配置.发现母畜基础概率 ?? 0.3;

    // 身份对侦察效率的影响
    this.身份系数表 = 配置.身份系数表 ?? {
      '间谍': 2.0,
      '商人': 1.5,
      '贵族': 1.3,
      '侍女': 1.2,
      '平民': 1.0,
      '奴隶': 0.8
    };
  }

  验证前置条件(上下文) {
    const { 行动者, 目标 } = 上下文;

    if (!行动者.是否已捕获()) {
      return { 有效: false, 原因: '行动者母畜尚未被捕获' };
    }

    if (目标.是否侦察完成()) {
      return { 有效: false, 原因: '该地点已侦察完毕' };
    }

    return { 有效: true };
  }

  计算侦察效率(母畜) {
    const 身份 = 母畜.获取属性('原身份');
    const 身份系数 = this.身份系数表[身份] ?? 1.0;

    const 臣服度 = 母畜.获取属性('臣服度');
    const 臣服系数 = 0.5 + (臣服度 / 100) * 0.5;

    return Math.floor(this.基础侦察效率 * 身份系数 * 臣服系数);
  }

  计算发现概率(母畜, 地点) {
    const 剩余母畜数 = 地点.获取潜在母畜数量();
    const 数量修正 = Math.min(1.5, 1 + 剩余母畜数 * 0.1);

    return Math.min(0.9, this.发现母畜基础概率 * 数量修正);
  }

  执行(上下文) {
    const { 行动者: 母畜, 目标: 地点, 当前回合 } = 上下文;

    const 侦察效率 = this.计算侦察效率(母畜);
    const 原进度 = 地点.侦察进度;
    地点.增加侦察进度(侦察效率);
    const 新进度 = 地点.侦察进度;

    const 效果列表 = [{
      类型: '侦察进度',
      目标: 地点.实体ID,
      原值: 原进度,
      增量: 侦察效率,
      新值: 新进度
    }];

    let 描述 = `${母畜.获取属性('姓名')}侦察了${地点.地点名称}，进度+${侦察效率}`;
    let 发现母畜 = null;

    // 尝试发现母畜
    const 发现概率 = this.计算发现概率(母畜, 地点);
    if (Math.random() < 发现概率) {
      const 潜在母畜 = 地点.获取随机潜在母畜();
      if (潜在母畜) {
        潜在母畜.标记侦察(当前回合);
        地点.标记母畜已侦察(潜在母畜.实体ID);

        发现母畜 = 潜在母畜;
        效果列表.push({
          类型: '发现母畜',
          母畜ID: 潜在母畜.实体ID,
          姓名: 潜在母畜.获取属性('姓名')
        });
        描述 += `，发现了${潜在母畜.获取属性('姓名')}`;
      }
    }

    return this.创建成功结果(效果列表, 描述, { 发现母畜 });
  }

  预览效果(上下文) {
    const { 行动者: 母畜, 目标: 地点 } = 上下文;

    if (!母畜 || !地点) {
      return { 描述: this.描述 };
    }

    return {
      描述: this.描述,
      预估: {
        侦察进度增量: this.计算侦察效率(母畜),
        发现母畜概率: `${Math.floor(this.计算发现概率(母畜, 地点) * 100)}%`
      }
    };
  }
}

/**
 * 锁定目标任务
 * 行动者：冠军 → 目标：母畜（已侦察状态）
 * 效果：锁定母畜，使其可被抓捕
 */
class 锁定目标任务 extends 任务基类 {
  constructor(配置 = {}) {
    super({
      任务ID: 'lock_target',
      任务名称: '锁定目标',
      描述: '派遣冠军锁定已侦察的母畜，为抓捕做准备',
      行动点消耗: 1,
      需要行动者类型: 任务基类.行动者类型.冠军,
      需要目标类型: 任务基类.目标类型.母畜,
      标签: ['抓捕', '外勤'],
      ...配置
    });
  }

  验证前置条件(上下文) {
    const { 目标 } = 上下文;

    if (目标.是否已锁定()) {
      return { 有效: false, 原因: '该母畜已被锁定' };
    }
    if (目标.是否已捕获()) {
      return { 有效: false, 原因: '该母畜已被捕获' };
    }
    if (!目标.是否已侦察()) {
      return { 有效: false, 原因: '该母畜尚未被侦察' };
    }

    return { 有效: true };
  }

  执行(上下文) {
    const { 行动者: 冠军, 目标: 母畜, 当前回合 } = 上下文;

    const 锁定结果 = 母畜.锁定(当前回合, 冠军.实体ID);

    if (!锁定结果.成功) {
      return this.创建失败结果(锁定结果.原因);
    }

    return this.创建成功结果(
      {
        类型: '状态变更',
        目标: 母畜.实体ID,
        新状态: '已锁定',
        负责人: 冠军.实体ID
      },
      `${冠军.获取属性('姓名')}锁定了${母畜.获取属性('姓名')}`
    );
  }
}

/**
 * 抓捕任务
 * 行动者：冠军 → 目标：母畜（已锁定状态）
 * 效果：概率捕获母畜
 */
class 抓捕任务 extends 任务基类 {
  constructor(配置 = {}) {
    super({
      任务ID: 'capture_target',
      任务名称: '抓捕',
      描述: '派遣冠军抓捕已锁定的母畜',
      行动点消耗: 2,
      需要行动者类型: 任务基类.行动者类型.冠军,
      需要目标类型: 任务基类.目标类型.母畜,
      标签: ['抓捕', '外勤', '高消耗'],
      ...配置
    });

    this.基础成功率 = 配置.基础成功率 ?? 0.7;
    this.力量系数 = 配置.力量系数 ?? 0.02;
    this.敏捷系数 = 配置.敏捷系数 ?? 0.01;
  }

  验证前置条件(上下文) {
    const { 目标 } = 上下文;

    if (目标.是否已捕获()) {
      return { 有效: false, 原因: '该母畜已被捕获' };
    }
    if (!目标.是否已锁定()) {
      return { 有效: false, 原因: '该母畜尚未被锁定' };
    }

    return { 有效: true };
  }

  计算成功率(冠军, 母畜) {
    const 力量 = 冠军.获取属性('力量');
    const 敏捷 = 冠军.获取属性('敏捷');

    const 能力加成 = 力量 * this.力量系数 + 敏捷 * this.敏捷系数;

    return Math.min(0.95, this.基础成功率 + 能力加成);
  }

  执行(上下文) {
    const { 行动者: 冠军, 目标: 母畜, 当前回合, 可袭击地点 } = 上下文;

    const 成功率 = this.计算成功率(冠军, 母畜);
    const 是否成功 = Math.random() < 成功率;

    if (!是否成功) {
      母畜.解除锁定();

      return this.创建成功结果(
        { 类型: '抓捕失败', 目标: 母畜.实体ID },
        `${冠军.获取属性('姓名')}试图抓捕${母畜.获取属性('姓名')}，但目标逃脱了`,
        { 抓捕成功: false }
      );
    }

    母畜.标记捕获(当前回合);

    if (可袭击地点) {
      可袭击地点.移除已捕获母畜(母畜.实体ID);
    }

    return this.创建成功结果(
      { 类型: '捕获成功', 目标: 母畜.实体ID },
      `${冠军.获取属性('姓名')}成功抓捕了${母畜.获取属性('姓名')}`,
      { 抓捕成功: true, 捕获母畜: 母畜 }
    );
  }

  预览效果(上下文) {
    const { 行动者: 冠军, 目标: 母畜 } = 上下文;

    if (!冠军 || !母畜) {
      return { 描述: this.描述 };
    }

    return {
      描述: this.描述,
      预估: {
        成功率: `${Math.floor(this.计算成功率(冠军, 母畜) * 100)}%`
      }
    };
  }
}

// ═══════════════════════════════════════════════════════════════
// 生育类任务
// ═══════════════════════════════════════════════════════════════

/**
 * 生育冠军任务
 * 行动者：无 → 目标：母畜
 * 效果：消耗雌性价值，产出冠军
 */
class 生育冠军任务 extends 任务基类 {
  constructor(配置 = {}) {
    super({
      任务ID: 'breed_champion',
      任务名称: '生育冠军',
      描述: '命令母畜生育冠军，消耗雌性价值',
      行动点消耗: 2,
      需要行动者类型: 任务基类.行动者类型.无,
      需要目标类型: 任务基类.目标类型.母畜,
      标签: ['生育', '高消耗'],
      ...配置
    });

    this.雌性价值消耗 = 配置.雌性价值消耗 ?? 10;
  }

  验证前置条件(上下文) {
    const { 目标, 工厂管理器 } = 上下文;

    if (!目标.是否已捕获()) {
      return { 有效: false, 原因: '目标母畜尚未被捕获' };
    }

    const 剩余价值 = 目标.获取属性('剩余雌性价值');
    if (剩余价值 < this.雌性价值消耗) {
      return { 有效: false, 原因: `雌性价值不足，需要${this.雌性价值消耗}，当前${剩余价值}` };
    }

    if (!工厂管理器) {
      return { 有效: false, 原因: '系统错误：缺少工厂管理器' };
    }

    return { 有效: true };
  }

  执行(上下文) {
    const { 目标: 母畜, 工厂管理器 } = 上下文;

    const 生育结果 = 工厂管理器.从母畜生育冠军(母畜);

    if (!生育结果.成功) {
      return this.创建失败结果(生育结果.原因);
    }

    return this.创建成功结果(
      {
        类型: '生育冠军',
        母畜ID: 母畜.实体ID,
        冠军ID: 生育结果.冠军.实体ID,
        消耗雌性价值: 生育结果.消耗雌性价值
      },
      `${母畜.获取属性('姓名')}生育了冠军${生育结果.冠军.获取属性('姓名')}`,
      { 新冠军: 生育结果.冠军 }
    );
  }

  预览效果(上下文) {
    const { 目标: 母畜, 工厂管理器 } = 上下文;

    if (!母畜 || !工厂管理器) {
      return { 描述: this.描述 };
    }

    const 预估属性 = 工厂管理器.获取冠军工厂().预估生育属性(母畜);

    return {
      描述: this.描述,
      预估: {
        雌性价值消耗: this.雌性价值消耗,
        属性范围: 预估属性
      }
    };
  }
}

/**
 * 生育喽啰任务
 * 行动者：无 → 目标：母畜
 * 效果：消耗雌性价值，产出喽啰到指定喽啰池
 */
class 生育喽啰任务 extends 任务基类 {
  constructor(配置 = {}) {
    super({
      任务ID: 'breed_minions',
      任务名称: '生育喽啰',
      描述: '命令母畜生育喽啰',
      行动点消耗: 1,
      需要行动者类型: 任务基类.行动者类型.无,
      需要目标类型: 任务基类.目标类型.母畜,
      标签: ['生育'],
      ...配置
    });

    this.雌性价值消耗 = 配置.雌性价值消耗 ?? 5;
    this.基础产出 = 配置.基础产出 ?? 3;
    this.淫乱度系数 = 配置.淫乱度系数 ?? 0.05;
  }

  验证前置条件(上下文) {
    const { 目标, 喽啰池 } = 上下文;

    if (!目标.是否已捕获()) {
      return { 有效: false, 原因: '目标母畜尚未被捕获' };
    }

    const 剩余价值 = 目标.获取属性('剩余雌性价值');
    if (剩余价值 < this.雌性价值消耗) {
      return { 有效: false, 原因: `雌性价值不足，需要${this.雌性价值消耗}，当前${剩余价值}` };
    }

    if (!喽啰池) {
      return { 有效: false, 原因: '需要指定目标喽啰池' };
    }

    return { 有效: true };
  }

  计算产出(母畜) {
    const 淫乱度 = 母畜.获取属性('淫乱度');
    const 加成 = Math.floor(淫乱度 * this.淫乱度系数);
    return this.基础产出 + 加成;
  }

  执行(上下文) {
    const { 目标: 母畜, 喽啰池 } = 上下文;

    const 消耗结果 = 母畜.消耗雌性价值(this.雌性价值消耗);
    if (!消耗结果.成功) {
      return this.创建失败结果(消耗结果.原因);
    }

    const 产出数量 = this.计算产出(母畜);
    喽啰池.增加喽啰(产出数量, '未武装');
    母畜.记录生育喽啰(产出数量);

    return this.创建成功结果(
      {
        类型: '生育喽啰',
        母畜ID: 母畜.实体ID,
        产出数量,
        消耗雌性价值: this.雌性价值消耗
      },
      `${母畜.获取属性('姓名')}生育了${产出数量}名喽啰`
    );
  }

  预览效果(上下文) {
    const { 目标: 母畜 } = 上下文;

    if (!母畜) {
      return { 描述: this.描述 };
    }

    return {
      描述: this.描述,
      预估: {
        雌性价值消耗: this.雌性价值消耗,
        产出数量: this.计算产出(母畜)
      }
    };
  }
}

// ═══════════════════════════════════════════════════════════════
// 杂项任务
// ═══════════════════════════════════════════════════════════════

/**
 * 休息任务
 * 占位任务
 */
class 休息任务 extends 任务基类 {
  constructor(配置 = {}) {
    super({
      任务ID: 'rest',
      任务名称: '休息',
      描述: '让单位休息，不执行任何行动',
      行动点消耗: 0,
      需要行动者类型: 任务基类.行动者类型.无,
      需要目标类型: 任务基类.目标类型.无,
      标签: ['杂项'],
      ...配置
    });
  }

  执行(上下文) {
    return this.创建成功结果({ 类型: '休息' }, '休息中...');
  }
}

// ═══════════════════════════════════════════════════════════════
// 任务集合 & 工厂函数
// ═══════════════════════════════════════════════════════════════

/**
 * 获取所有默认任务实例
 */
function 获取默认任务列表(自定义配置 = {}) {
  return [
    new 调教任务(自定义配置.调教),
    new 驯服任务(自定义配置.驯服),
    new 侦察任务(自定义配置.侦察),
    new 锁定目标任务(自定义配置.锁定目标),
    new 抓捕任务(自定义配置.抓捕),
    new 生育冠军任务(自定义配置.生育冠军),
    new 生育喽啰任务(自定义配置.生育喽啰),
    new 休息任务(自定义配置.休息)
  ];
}

/**
 * 创建预配置的任务注册表
 */
function 创建默认任务注册表(自定义配置 = {}) {
  const 注册表 = new 任务注册表();
  注册表.批量注册(获取默认任务列表(自定义配置));
  return 注册表;
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export {
  // 具体任务类
  调教任务,
  驯服任务,
  侦察任务,
  锁定目标任务,
  抓捕任务,
  生育冠军任务,
  生育喽啰任务,
  休息任务,

  // 工厂函数
  获取默认任务列表,
  创建默认任务注册表
};
