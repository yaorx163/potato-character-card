// ═══════════════════════════════════════════════════════════════
// core/factories.ts
// 工厂类 - 负责创建游戏实体
// ═══════════════════════════════════════════════════════════════

import {
    冠军实体,
    母畜实体,
    可袭击地点实体,
    领主实体
  } from './entities';
  
  // ═══════════════════════════════════════════════════════════════
  // 类型定义
  // ═══════════════════════════════════════════════════════════════
  
  interface 姓名池配置 {
    前缀: string[];
    主名: string[];
    后缀: string[];
  }
  
  interface 属性系数 {
    力量: number;
    敏捷: number;
    智力: number;
  }
  
  interface 冠军工厂配置 {
    冠军姓名池?: 姓名池配置;
    生育消耗?: number;
    属性随机浮动范围?: number;
    前缀概率?: number;
    后缀概率?: number;
    效率系数表?: Map<string, 属性系数>;
    种族系数表?: Map<string, 属性系数>;
  }
  
  interface 生育选项 {
    姓名?: string;
    性别?: string;
  }
  
  interface 生育结果 {
    成功: boolean;
    冠军?: 冠军实体;
    消耗雌性价值?: number;
    属性?: { 力量: number; 敏捷: number; 智力: number };
    原因?: string;
    当前?: number;
    需要?: number;
  }
  
  interface 属性预估范围 {
    最小: number;
    最大: number;
    期望: number;
  }
  
  interface 生育属性预估 {
    力量: 属性预估范围;
    敏捷: 属性预估范围;
    智力: 属性预估范围;
  }
  
  interface 种族配置数据 {
    姓名池?: 姓名池配置;
    前缀概率?: number;
    后缀概率?: number;
  }
  
  interface 身份配置数据 {
    最小年龄?: number;
    最大年龄?: number;
  }
  
  interface 母畜工厂配置 {
    种族配置?: Map<string, 种族配置数据>;
    身份配置?: Map<string, 身份配置数据>;
  }
  
  interface 母畜创建配置 {
    姓名?: string;
    种族?: string;
    身份?: string;
    年龄?: number;
    来源?: string;
    描述?: string;
    来源地点ID?: string;
    总雌性价值?: number;
    剩余雌性价值?: number;
    捕获回合?: number;
  }
  
  interface 领主工厂配置 {
    初始魔力?: number;
    最大魔力?: number;
    默认姓名?: string;
  }
  
  interface 领主创建配置 {
    魔力?: number;
    最大魔力?: number;
    姓名?: string;
  }
  
  interface 地点类型配置数据 {
    描述模板?: string;
    基础战斗力?: number;
    侦察最大值?: number;
    母畜数量?: number;
    身份分布?: Record<string, number>;
    前缀?: string[];
    中缀?: string[];
    后缀?: string[];
  }
  
  interface 可袭击地点工厂配置 {
    地点类型配置?: Map<string, 地点类型配置数据>;
  }
  
  interface 地点创建配置 {
    名称?: string;
    描述?: string;
    战斗力?: number;
    侦察进度?: number;
    侦察最大值?: number;
    母畜数量?: number;
  }
  
  interface 运行时配置 {
    冠军配置?: 冠军工厂配置;
    母畜配置?: 母畜工厂配置;
    领主配置?: 领主工厂配置;
    地点配置?: 可袭击地点工厂配置;
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 冠军工厂
  // ═══════════════════════════════════════════════════════════════
  
  class 冠军工厂 {
    private 姓名池: 姓名池配置;
    private 生育消耗: number;
    private 随机浮动范围: number;
    private 前缀概率: number;
    private 后缀概率: number;
    private 效率系数表: Map<string, 属性系数>;
    private 种族系数表: Map<string, 属性系数>;
  
    constructor(配置: 冠军工厂配置 = {}) {
      this.姓名池 = 配置.冠军姓名池 ?? {
        前缀: [],
        主名: [],
        后缀: [],
      };
      this.生育消耗 = 配置.生育消耗 ?? 10;
      this.随机浮动范围 = 配置.属性随机浮动范围 ?? 3;
      this.前缀概率 = 配置.前缀概率 ?? 0.3;
      this.后缀概率 = 配置.后缀概率 ?? 0.2;
      this.效率系数表 = 配置.效率系数表 ?? new Map();
      this.种族系数表 = 配置.种族系数表 ?? new Map();
    }
  
    // ─── 配置方法 ───
  
    生成随机姓名(): string {
      if (this.姓名池?.主名?.length > 0) {
        const 随机选择 = <T>(数组: T[]): T | string => {
          if (!数组 || 数组.length === 0) return '';
          return 数组[Math.floor(Math.random() * 数组.length)];
        };
  
        const 前缀 = Math.random() < this.前缀概率 ? 随机选择(this.姓名池.前缀) : '';
        const 主名 = 随机选择(this.姓名池.主名);
        const 后缀 = Math.random() < this.后缀概率 ? 随机选择(this.姓名池.后缀) : '';
  
        return `${前缀}${主名}${后缀}`.trim();
      }
  
      return `冠军_${Date.now().toString(36).slice(-4)}`;
    }
  
    // ─── 属性计算辅助 ───
  
    private 计算随机浮动(): number {
      const 范围 = this.随机浮动范围;
      return Math.floor(Math.random() * (范围 * 2 + 1)) - 范围;
    }
  
    private 计算属性值(基础值: number, 身份系数: number = 1.0, 种族系数: number = 1.0): number {
      const 浮动 = this.计算随机浮动();
      const 原始值 = (基础值 + 浮动) * 身份系数 * 种族系数;
      return Math.max(1, Math.round(原始值));
    }
  
    private 获取效率系数(身份: string): 属性系数 {
      return this.效率系数表.get(身份) ?? { 力量: 1.0, 敏捷: 1.0, 智力: 1.0 };
    }
  
    private 获取种族系数(种族: string): 属性系数 {
      return this.种族系数表.get(种族) ?? { 力量: 1.0, 敏捷: 1.0, 智力: 1.0 };
    }
  
    // ─── 创建方法 ───
  
    从母畜生育(母畜: 母畜实体, 选项: 生育选项 = {}): 生育结果 {
      const 消耗结果 = 母畜.消耗雌性价值(this.生育消耗);
      if (!消耗结果.成功) {
        return {
          成功: false,
          原因: 消耗结果.原因,
          当前: 消耗结果.当前,
          需要: 消耗结果.需要,
        };
      }
  
      const 母畜身份 = 母畜.获取属性<string>('原身份');
      const 母畜种族 = 母畜.获取属性<string>('种族');
      const 总雌性价值 = 母畜.获取属性<number>('总雌性价值');
  
      const 身份系数 = this.获取效率系数(母畜身份);
      const 种族系数 = this.获取种族系数(母畜种族);
  
      const 基础值 = 总雌性价值 / 10;
  
      const 力量 = this.计算属性值(基础值, 身份系数.力量, 种族系数.力量);
      const 敏捷 = this.计算属性值(基础值, 身份系数.敏捷, 种族系数.敏捷);
      const 智力 = this.计算属性值(基础值, 身份系数.智力, 种族系数.智力);
  
      const 姓名 = 选项.姓名 ?? this.生成随机姓名();
  
      const 冠军数据 = {
        姓名,
        性别: 选项.性别 ?? '男',
        力量,
        敏捷,
        智力,
        来源信息: {
          类型: '生育',
          母畜ID: 母畜.实体ID,
        },
      };
  
      const 新冠军 = new 冠军实体(冠军数据);
      母畜.记录生育冠军(新冠军.实体ID);
  
      return {
        成功: true,
        冠军: 新冠军,
        消耗雌性价值: this.生育消耗,
        属性: { 力量, 敏捷, 智力 },
      };
    }
  
    // ─── 预估方法 ───
  
    预估生育属性(母畜: 母畜实体): 生育属性预估 {
      const 母畜身份 = 母畜.获取属性<string>('原身份');
      const 母畜种族 = 母畜.获取属性<string>('种族');
      const 总雌性价值 = 母畜.获取属性<number>('总雌性价值');
  
      const 身份系数 = this.获取效率系数(母畜身份);
      const 种族系数 = this.获取种族系数(母畜种族);
  
      const 基础值 = 总雌性价值 / 10;
      const 范围 = this.随机浮动范围;
  
      return {
        力量: {
          最小: Math.max(1, Math.round((基础值 - 范围) * 身份系数.力量 * 种族系数.力量)),
          最大: Math.round((基础值 + 范围) * 身份系数.力量 * 种族系数.力量),
          期望: Math.round(基础值 * 身份系数.力量 * 种族系数.力量),
        },
        敏捷: {
          最小: Math.max(1, Math.round((基础值 - 范围) * 身份系数.敏捷 * 种族系数.敏捷)),
          最大: Math.round((基础值 + 范围) * 身份系数.敏捷 * 种族系数.敏捷),
          期望: Math.round(基础值 * 身份系数.敏捷 * 种族系数.敏捷),
        },
        智力: {
          最小: Math.max(1, Math.round((基础值 - 范围) * 身份系数.智力 * 种族系数.智力)),
          最大: Math.round((基础值 + 范围) * 身份系数.智力 * 种族系数.智力),
          期望: Math.round(基础值 * 身份系数.智力 * 种族系数.智力),
        },
      };
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 母畜工厂
  // ═══════════════════════════════════════════════════════════════
  
  class 母畜工厂 {
    private 种族配置: Map<string, 种族配置数据>;
    private 身份配置: Map<string, 身份配置数据>;
  
    constructor(配置: 母畜工厂配置 = {}) {
      this.种族配置 = 配置.种族配置 ?? new Map();
      this.身份配置 = 配置.身份配置 ?? new Map();
    }
  
    // ===== 创建方法 =====
  
    创建潜在母畜(配置: 母畜创建配置 = {}): 母畜实体 {
      const 种族 = 配置.种族 || this.随机选择种族();
      const 身份 = 配置.身份 || this.随机选择身份();
  
      const 母畜 = new 母畜实体({
        姓名: 配置.姓名 || this.生成随机姓名(种族),
        种族,
        年龄: 配置.年龄 ?? this.随机年龄(身份),
        原身份: 身份,
        来源: 配置.来源 || '可袭击地点',
        描述: 配置.描述 || this.生成描述(种族, 身份),
        来源地点ID: 配置.来源地点ID || null,
        总雌性价值: 配置.总雌性价值 || 100,
        剩余雌性价值: 配置.剩余雌性价值 || 配置.总雌性价值 || 100,
      });
  
      return 母畜;
    }
  
    创建已捕获(配置: 母畜创建配置 = {}): 母畜实体 {
      const 母畜 = this.创建潜在母畜({
        ...配置,
        来源: 配置.来源 || '直接获取'
      });
  
      return 母畜;
    }
  
    批量创建潜在母畜(数量: number, 基础配置: 母畜创建配置 = {}): 母畜实体[] {
      const 结果: 母畜实体[] = [];
      for (let i = 0; i < 数量; i++) {
        结果.push(this.创建潜在母畜({
          ...基础配置,
        }));
      }
      return 结果;
    }
  
    // ===== 辅助方法 =====
  
    private 随机选择种族(): string {
      const 种族列表 = [...this.种族配置.keys()];
      if (种族列表.length === 0) return '人类';
      return 种族列表[Math.floor(Math.random() * 种族列表.length)];
    }
  
    private 随机选择身份(): string {
      const 身份列表 = [...this.身份配置.keys()];
      if (身份列表.length === 0) return '平民';
      return 身份列表[Math.floor(Math.random() * 身份列表.length)];
    }
  
    private 随机年龄(身份: string): number {
      const 身份数据 = this.身份配置.get(身份);
      const 最小 = 身份数据?.最小年龄 ?? 18;
      const 最大 = 身份数据?.最大年龄 ?? 40;
      return Math.floor(最小 + Math.random() * (最大 - 最小));
    }
  
    private 生成随机姓名(种族: string): string {
      const 种族数据 = this.种族配置.get(种族);
      const 姓名池 = 种族数据?.姓名池;
      if (!姓名池) {
        return `无名哥布林冠军`;
      };
  
      if (姓名池.主名?.length > 0) {
        const 随机选择 = <T>(数组: T[]): T | string => {
          if (!数组 || 数组.length === 0) return '';
          return 数组[Math.floor(Math.random() * 数组.length)];
        };
        const 前缀概率 = 种族数据?.前缀概率 ?? 0;
        const 后缀概率 = 种族数据?.后缀概率 ?? 0;
  
        const 前缀 = Math.random() < 前缀概率 ? 随机选择(姓名池.前缀 ?? []) : '';
        const 主名 = 随机选择(姓名池.主名);
        const 后缀 = Math.random() < 后缀概率 ? 随机选择(姓名池.后缀 ?? []) : '';
  
        return `${前缀}${主名}${后缀}`.trim();
      }
  
      return `无名_${Date.now().toString(36).slice(-4)}`;
    }
  
    private 生成描述(种族: string, 身份: string): string {
      return `一位 ${种族} ${身份}`;
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 领主工厂
  // ═══════════════════════════════════════════════════════════════
  
  class 领主工厂 {
    private 默认配置: { 魔力: number; 最大魔力: number; 姓名: string };
  
    constructor(配置: 领主工厂配置 = {}) {
      this.默认配置 = {
        魔力: 配置.初始魔力 ?? 0,
        最大魔力: 配置.最大魔力 ?? 100,
        姓名: 配置.默认姓名 ?? '无名领主',
      };
    }
  
    创建领主(配置: 领主创建配置 = {}): 领主实体 {
      return new 领主实体({
        ...this.默认配置,
        ...配置,
      });
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 可袭击地点工厂
  // ═══════════════════════════════════════════════════════════════
  
  class 可袭击地点工厂 {
    private 地点类型配置: Map<string, 地点类型配置数据>;
    private 母畜工厂: 母畜工厂 | null;
  
    constructor(配置: 可袭击地点工厂配置 = {}) {
      this.地点类型配置 = 配置.地点类型配置 ?? new Map();
      this.母畜工厂 = null;
    }
  
    设置母畜工厂(工厂: 母畜工厂): void {
      this.母畜工厂 = 工厂;
    }
  
    创建地点(类型: string, 配置: 地点创建配置 = {}): 可袭击地点实体 {
      if (!this.地点类型配置.has(类型)) {
        throw new Error(`未知的地点类型: ${类型}`);
      }
      const 类型配置 = this.地点类型配置.get(类型)!;
  
      const 地点 = new 可袭击地点实体({
        地点名称: 配置.名称 || this.生成地点名称(类型),
        地点类型: 类型,
        描述: 配置.描述 || 类型配置.描述模板,
        战斗力: 配置.战斗力 ?? 类型配置.基础战斗力,
        侦察进度: 配置.侦察进度 ?? 0,
        侦察最大值: 配置.侦察最大值 ?? 类型配置.侦察最大值 ?? 100
      });
  
      if (this.母畜工厂) {
        this.填充潜在母畜(地点, 类型配置, 配置);
      }
  
      return 地点;
    }
  
    private 填充潜在母畜(
      可袭击地点: 可袭击地点实体,
      类型配置: 地点类型配置数据,
      额外配置: 地点创建配置 = {}
    ): void {
      const 数量 = 额外配置.母畜数量 ?? 类型配置.母畜数量 ?? 5;
      const 身份分布 = 类型配置.身份分布 || { '平民': 1 };
  
      for (let i = 0; i < 数量; i++) {
        const 身份 = this.按权重选择(身份分布);
        const 母畜 = this.母畜工厂!.创建潜在母畜({
          身份,
          来源地点ID: 可袭击地点.实体ID,
        });
        可袭击地点.添加潜在母畜(母畜);
      }
    }
  
    private 按权重选择(权重对象: Record<string, number>): string {
      const 条目 = Object.entries(权重对象);
      const 总权重 = 条目.reduce((sum, [, w]) => sum + w, 0);
      let 随机值 = Math.random() * 总权重;
  
      for (const [选项, 权重] of 条目) {
        随机值 -= 权重;
        if (随机值 <= 0) return 选项;
      }
      return 条目[0]?.[0] ?? '平民';
    }
  
    private 生成地点名称(类型: string): string {
      const 类型配置 = this.地点类型配置.get(类型);
      const 前缀列表 = 类型配置?.前缀 ?? ['东'];
      const 中缀列表 = 类型配置?.中缀 ?? ['德'];
      const 后缀列表 = 类型配置?.后缀 ?? ['镇'];
  
      const 随机取 = <T>(arr: T[]): T => arr[Math.floor(Math.random() * arr.length)];
      return `${随机取(前缀列表)}${随机取(中缀列表)}${随机取(后缀列表)}`;
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 工厂管理器
  // ═══════════════════════════════════════════════════════════════
  
  class 工厂管理器 {
    readonly 冠军工厂: 冠军工厂;
    readonly 母畜工厂: 母畜工厂;
    readonly 领主工厂: 领主工厂;
    readonly 可袭击地点工厂: 可袭击地点工厂;
  
    constructor(运行时配置: 运行时配置 = {}) {
      this.冠军工厂 = new 冠军工厂(运行时配置.冠军配置);
      this.母畜工厂 = new 母畜工厂(运行时配置.母畜配置);
      this.领主工厂 = new 领主工厂(运行时配置.领主配置);
      this.可袭击地点工厂 = new 可袭击地点工厂(运行时配置.地点配置);
      this.可袭击地点工厂.设置母畜工厂(this.母畜工厂);
    }
  
    // ─── 工厂访问 ───
  
    获取冠军工厂(): 冠军工厂 {
      return this.冠军工厂;
    }
  
    获取母畜工厂(): 母畜工厂 {
      return this.母畜工厂;
    }
  
    获取领主工厂(): 领主工厂 {
      return this.领主工厂;
    }
  
    获取可袭击地点工厂(): 可袭击地点工厂 {
      return this.可袭击地点工厂;
    }
  
    // ─── 快捷创建方法 ───
  
    创建潜在母畜(配置: 母畜创建配置): 母畜实体 {
      return this.母畜工厂.创建潜在母畜(配置);
    }
  
    创建已捕获母畜(配置: 母畜创建配置): 母畜实体 {
      return this.母畜工厂.创建已捕获(配置);
    }
  
    创建领主(配置: 领主创建配置): 领主实体 {
      return this.领主工厂.创建领主(配置);
    }
  
    创建可袭击地点(类型: string, 配置: 地点创建配置): 可袭击地点实体 {
      return this.可袭击地点工厂.创建地点(类型, 配置);
    }
  
    从母畜生育哥布林冠军(母畜: 母畜实体, 选项: 生育选项): 生育结果 {
      return this.冠军工厂.从母畜生育(母畜, 选项);
    }
  
    // ─── 批量操作 ───
  
    批量创建潜在母畜(数量: number, 配置: 母畜创建配置): 母畜实体[] {
      return this.母畜工厂.批量创建潜在母畜(数量, 配置);
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 导出
  // ═══════════════════════════════════════════════════════════════
  
  export {
    冠军工厂,
    母畜工厂,
    领主工厂,
    可袭击地点工厂,
    工厂管理器
  };
  
  export type {
    姓名池配置,
    属性系数,
    冠军工厂配置,
    生育选项,
    生育结果,
    生育属性预估,
    母畜工厂配置,
    母畜创建配置,
    领主工厂配置,
    领主创建配置,
    可袭击地点工厂配置,
    地点创建配置,
    地点类型配置数据,
    运行时配置
  };
  