// ═══════════════════════════════════════════════════════════════
// systems/event-bus.js
// 事件总线 - 全局事件发布订阅系统
// ═══════════════════════════════════════════════════════════════

/**
 * 事件总线
 * 提供发布-订阅模式的事件通信机制
 * 支持优先级、通配符订阅、事件历史记录
 */
class 事件总线 {
  constructor(配置 = {}) {
    // 订阅者映射: 事件名 -> [{ 处理器, 优先级, 一次性 }]
    this.订阅者映射 = new Map();

    // 事件历史记录
    this.事件历史 = [];
    this.历史上限 = 配置.历史上限 ?? 1000;
    this.启用历史记录 = 配置.启用历史记录 ?? true;

    // 事件拦截器
    this.拦截器列表 = [];

    // 调试模式
    this.调试模式 = 配置.调试模式 ?? false;

    // 异步事件队列
    this.异步队列 = [];
    this.正在处理异步 = false;

    // 统计信息
    this.统计 = {
      发布次数: 0,
      订阅次数: 0,
      处理次数: 0,
    };
  }

  // ─── 订阅方法 ───

  订阅(事件名, 处理器, 选项 = {}) {
    /**
     * 订阅事件
     * @param 事件名 - 事件名称，支持通配符 '*'
     * @param 处理器 - 事件处理函数 (事件对象) => void
     * @param 选项 - { 优先级: number, 一次性: boolean }
     * @returns 取消订阅函数
     */
    const 优先级 = 选项.优先级 ?? 选项.priority ?? 0;
    const 一次性 = 选项.一次性 ?? 选项.once ?? false;

    if (!this.订阅者映射.has(事件名)) {
      this.订阅者映射.set(事件名, []);
    }

    const 订阅信息 = {
      处理器,
      优先级,
      一次性,
      订阅时间: Date.now(),
    };

    const 订阅列表 = this.订阅者映射.get(事件名);
    订阅列表.push(订阅信息);

    // 按优先级排序（高优先级在前）
    订阅列表.sort((a, b) => b.优先级 - a.优先级);

    this.统计.订阅次数++;

    // 返回取消订阅函数
    return () => this.取消订阅(事件名, 处理器);
  }

  一次性订阅(事件名, 处理器, 优先级 = 0) {
    /**
     * 订阅一次性事件（触发后自动取消订阅）
     */
    return this.订阅(事件名, 处理器, { 优先级, 一次性: true });
  }

  取消订阅(事件名, 处理器) {
    /**
     * 取消订阅
     */
    const 订阅列表 = this.订阅者映射.get(事件名);
    if (!订阅列表) return false;

    const 索引 = 订阅列表.findIndex(s => s.处理器 === 处理器);
    if (索引 !== -1) {
      订阅列表.splice(索引, 1);
      return true;
    }
    return false;
  }

  取消所有订阅(事件名 = null) {
    /**
     * 取消所有订阅
     * @param 事件名 - 如果提供，只取消该事件的订阅；否则取消所有
     */
    if (事件名) {
      this.订阅者映射.delete(事件名);
    } else {
      this.订阅者映射.clear();
    }
  }

  // ─── 发布方法 ───

  发布(事件名, 数据 = {}) {
    /**
     * 同步发布事件
     * @param 事件名 - 事件名称
     * @param 数据 - 事件数据
     * @returns 事件对象
     */
    const 事件对象 = this.创建事件对象(事件名, 数据);

    // 执行拦截器
    for (const 拦截器 of this.拦截器列表) {
      const 结果 = 拦截器(事件对象);
      if (结果 === false) {
        事件对象.已拦截 = true;
        return 事件对象;
      }
    }

    // 记录历史
    if (this.启用历史记录) {
      this.记录事件历史(事件对象);
    }

    // 调试输出
    if (this.调试模式) {
      console.log(`[事件总线] 发布: ${事件名}`, 数据);
    }

    // 执行订阅者
    this.执行订阅者(事件对象, 事件名);

    // 执行通配符订阅者
    this.执行订阅者(事件对象, '*');

    this.统计.发布次数++;

    return 事件对象;
  }

  异步发布(事件名, 数据 = {}) {
    /**
     * 异步发布事件（加入队列，稍后执行）
     * @returns Promise<事件对象>
     */
    return new Promise(resolve => {
      this.异步队列.push({
        事件名,
        数据,
        回调: resolve,
      });

      this.处理异步队列();
    });
  }

  延迟发布(事件名, 数据 = {}, 延迟毫秒 = 0) {
    /**
     * 延迟发布事件
     * @returns Promise<事件对象>
     */
    return new Promise(resolve => {
      setTimeout(() => {
        const 事件对象 = this.发布(事件名, 数据);
        resolve(事件对象);
      }, 延迟毫秒);
    });
  }

  // ─── 内部方法 ───

  创建事件对象(事件名, 数据) {
    return {
      名称: 事件名,
      name: 事件名, // 英文别名
      时间戳: Date.now(),
      数据,
      data: 数据, // 英文别名
      已阻止: false,
      已拦截: false,
      阻止传播() {
        this.已阻止 = true;
      },
      stopPropagation() {
        this.已阻止 = true;
      },
    };
  }

  执行订阅者(事件对象, 事件名) {
    const 订阅列表 = this.订阅者映射.get(事件名);
    if (!订阅列表 || 订阅列表.length === 0) return;

    // 收集需要移除的一次性订阅
    const 待移除 = [];

    for (const 订阅信息 of 订阅列表) {
      if (事件对象.已阻止) break;

      try {
        订阅信息.处理器(事件对象);
        this.统计.处理次数++;
      } catch (错误) {
        console.error(`[事件总线] 处理器错误 [${事件对象.名称}]:`, 错误);
      }

      if (订阅信息.一次性) {
        待移除.push(订阅信息);
      }
    }

    // 移除一次性订阅
    待移除.forEach(订阅信息 => {
      const 索引 = 订阅列表.indexOf(订阅信息);
      if (索引 !== -1) {
        订阅列表.splice(索引, 1);
      }
    });
  }

  async 处理异步队列() {
    if (this.正在处理异步) return;
    this.正在处理异步 = true;

    while (this.异步队列.length > 0) {
      const { 事件名, 数据, 回调 } = this.异步队列.shift();

      // 使用微任务确保异步
      await Promise.resolve();

      const 事件对象 = this.发布(事件名, 数据);
      回调(事件对象);
    }

    this.正在处理异步 = false;
  }

  // ─── 拦截器 ───

  添加拦截器(拦截函数) {
    /**
     * 添加事件拦截器
     * 拦截函数返回 false 时阻止事件发布
     * @returns 移除拦截器函数
     */
    this.拦截器列表.push(拦截函数);

    return () => {
      const 索引 = this.拦截器列表.indexOf(拦截函数);
      if (索引 !== -1) {
        this.拦截器列表.splice(索引, 1);
      }
    };
  }

  // ─── 历史记录 ───

  记录事件历史(事件对象) {
    this.事件历史.push({
      名称: 事件对象.名称,
      时间戳: 事件对象.时间戳,
      数据: 事件对象.数据,
    });

    // 限制历史记录数量
    while (this.事件历史.length > this.历史上限) {
      this.事件历史.shift();
    }
  }

  获取事件历史(过滤条件 = {}) {
    /**
     * 获取事件历史
     * @param 过滤条件 - { 事件名?, 数量?, 开始时间?, 结束时间? }
     */
    let 结果 = [...this.事件历史];

    if (过滤条件.事件名) {
      结果 = 结果.filter(e => e.名称 === 过滤条件.事件名);
    }

    if (过滤条件.开始时间) {
      结果 = 结果.filter(e => e.时间戳 >= 过滤条件.开始时间);
    }

    if (过滤条件.结束时间) {
      结果 = 结果.filter(e => e.时间戳 <= 过滤条件.结束时间);
    }

    if (过滤条件.数量) {
      结果 = 结果.slice(-过滤条件.数量);
    }

    return 结果;
  }

  清空事件历史() {
    this.事件历史 = [];
  }

  // ─── 查询方法 ───

  获取订阅者数量(事件名) {
    return this.订阅者映射.get(事件名)?.length ?? 0;
  }

  获取所有事件名() {
    return Array.from(this.订阅者映射.keys());
  }

  是否有订阅者(事件名) {
    return this.获取订阅者数量(事件名) > 0;
  }

  // ─── 统计与调试 ───

  获取统计信息() {
    return {
      ...this.统计,
      事件类型数: this.订阅者映射.size,
      历史记录数: this.事件历史.length,
    };
  }

  重置统计() {
    this.统计 = {
      发布次数: 0,
      订阅次数: 0,
      处理次数: 0,
    };
  }

  设置调试模式(启用) {
    this.调试模式 = 启用;
  }

  // ─── 批量操作 ───

  批量发布(事件列表) {
    /**
     * 批量发布事件
     * @param 事件列表 - [{ 事件名, 数据 }, ...]
     * @returns 事件对象数组
     */
    return 事件列表.map(({ 事件名, 数据 }) => this.发布(事件名, 数据));
  }

  批量订阅(订阅配置) {
    /**
     * 批量订阅事件
     * @param 订阅配置 - { 事件名: 处理器 } 或 [{ 事件名, 处理器, 选项 }, ...]
     * @returns 取消订阅函数数组
     */
    if (Array.isArray(订阅配置)) {
      return 订阅配置.map(({ 事件名, 处理器, 选项 }) => this.订阅(事件名, 处理器, 选项 ?? {}));
    } else {
      return Object.entries(订阅配置).map(([事件名, 处理器]) => this.订阅(事件名, 处理器));
    }
  }

  // ─── 命名空间支持 ───

  创建命名空间(前缀) {
    /**
     * 创建带命名空间的事件总线代理
     * @param 前缀 - 事件名前缀
     * @returns 代理对象
     */
    const 总线 = this;

    return {
      订阅(事件名, 处理器, 选项) {
        return 总线.订阅(`${前缀}:${事件名}`, 处理器, 选项);
      },
      发布(事件名, 数据) {
        return 总线.发布(`${前缀}:${事件名}`, 数据);
      },
      取消订阅(事件名, 处理器) {
        return 总线.取消订阅(`${前缀}:${事件名}`, 处理器);
      },
    };
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 事件总线 };
export default 事件总线;
