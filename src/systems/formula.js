// ═══════════════════════════════════════════════════════════════
// systems/formula.js
// 公式引擎 - 集中管理所有游戏公式
// ═══════════════════════════════════════════════════════════════

/**
 * 公式引擎
 * 集中管理所有游戏计算公式，支持动态注册和覆盖
 */
class 公式引擎 {
  constructor() {
    // 公式映射: 公式名 -> 计算函数
    this.公式映射 = new Map();

    // 公式元数据
    this.公式元数据 = new Map();

    // 常量表
    this.常量表 = new Map();

    // 公式分类索引
    this.分类索引 = new Map();

    // 计算缓存
    this.缓存 = new Map();
    this.启用缓存 = false;
  }

  // ─── 公式注册 ───

  注册公式(公式名, 计算函数, 元数据 = {}) {
    /**
     * 注册公式
     * @param 公式名 - 公式唯一标识
     * @param 计算函数 - (参数对象, 常量表) => 计算结果
     * @param 元数据 - { 描述, 参数说明, 分类 }
     */
    this.公式映射.set(公式名, 计算函数);

    this.公式元数据.set(公式名, {
      描述: 元数据.描述 ?? '',
      参数说明: 元数据.参数说明 ?? {},
      分类: 元数据.分类 ?? '通用',
      版本: 元数据.版本 ?? '1.0',
      公式文本: 元数据.公式文本 ?? null,
      注册时间: Date.now(),
    });

    // 更新分类索引
    const 分类 = 元数据.分类 ?? '通用';
    if (!this.分类索引.has(分类)) {
      this.分类索引.set(分类, new Set());
    }
    this.分类索引.get(分类).add(公式名);
  }

  批量注册(公式配置对象) {
    /**
     * 批量注册公式
     * @param 公式配置对象 - { 公式名: 计算函数 } 或 { 公式名: { 函数, 元数据 } }
     */
    Object.entries(公式配置对象).forEach(([名称, 配置]) => {
      if (typeof 配置 === 'function') {
        this.注册公式(名称, 配置);
      } else {
        this.注册公式(名称, 配置.函数 ?? 配置.fn, 配置.元数据 ?? 配置);
      }
    });
  }

  // ─── 公式计算 ───

  计算(公式名, 参数 = {}) {
    /**
     * 执行公式计算
     * @param 公式名 - 公式标识
     * @param 参数 - 计算参数对象
     * @returns 计算结果
     */
    const 计算函数 = this.公式映射.get(公式名);

    if (!计算函数) {
      throw new Error(`未注册的公式: ${公式名}`);
    }

    // 检查缓存
    if (this.启用缓存) {
      const 缓存键 = this.生成缓存键(公式名, 参数);
      if (this.缓存.has(缓存键)) {
        return this.缓存.get(缓存键);
      }
    }

    // 构建常量对象供公式访问
    const 常量对象 = Object.fromEntries(this.常量表);

    // 执行计算，传入参数和常量表
    try {
      const 结果 = 计算函数(参数, 常量对象);

      // 写入缓存
      if (this.启用缓存) {
        const 缓存键 = this.生成缓存键(公式名, 参数);
        this.缓存.set(缓存键, 结果);
      }

      return 结果;
    } catch (错误) {
      console.error(`公式计算错误 [${公式名}]:`, 错误);
      throw 错误;
    }
  }

  安全计算(公式名, 参数 = {}, 默认值 = null) {
    /**
     * 安全计算（出错时返回默认值）
     */
    try {
      return this.计算(公式名, 参数);
    } catch {
      return 默认值;
    }
  }

  批量计算(计算列表) {
    /**
     * 批量计算多个公式
     * @param 计算列表 - [{ 公式名, 参数 }, ...]
     * @returns 结果数组
     */
    return 计算列表.map(({ 公式名, 参数 }) => ({
      公式名,
      结果: this.安全计算(公式名, 参数),
    }));
  }

  // ─── 常量管理 ───

  设置常量(常量名, 值) {
    this.常量表.set(常量名, 值);
  }

  批量设置常量(常量对象) {
    Object.entries(常量对象).forEach(([名称, 值]) => {
      this.常量表.set(名称, 值);
    });
  }

  获取常量(常量名, 默认值 = undefined) {
    return this.常量表.has(常量名) ? this.常量表.get(常量名) : 默认值;
  }

  获取所有常量() {
    return Object.fromEntries(this.常量表);
  }

  // ─── 查询方法 ───

  是否已注册(公式名) {
    return this.公式映射.has(公式名);
  }

  获取公式元数据(公式名) {
    return this.公式元数据.get(公式名);
  }

  获取分类公式列表(分类) {
    const 公式名集合 = this.分类索引.get(分类);
    if (!公式名集合) return [];

    return Array.from(公式名集合).map(名称 => ({
      名称,
      ...this.公式元数据.get(名称),
    }));
  }

  获取所有分类() {
    return Array.from(this.分类索引.keys());
  }

  获取所有公式() {
    return Array.from(this.公式映射.keys()).map(名称 => ({
      名称,
      ...this.公式元数据.get(名称),
    }));
  }

  // ─── 缓存管理 ───

  生成缓存键(公式名, 参数) {
    const 排序参数 = Object.keys(参数)
      .sort()
      .reduce((obj, key) => {
        obj[key] = 参数[key];
        return obj;
      }, {});
    return `${公式名}:${JSON.stringify(排序参数)}`;
  }

  设置缓存启用(启用) {
    this.启用缓存 = 启用;
    if (!启用) {
      this.清空缓存();
    }
  }

  清空缓存() {
    this.缓存.clear();
  }

  // ─── 公式组合 ───

  创建组合公式(公式名, 子公式列表, 组合函数) {
    /**
     * 创建组合公式（由多个子公式组合而成）
     * @param 公式名 - 新公式名称
     * @param 子公式列表 - 子公式名称列表
     * @param 组合函数 - (子结果数组) => 最终结果
     */
    const 引擎 = this;

    this.注册公式(
      公式名,
      (参数, 常量) => {
        const 子结果 = 子公式列表.map(子公式名 => 引擎.计算(子公式名, 参数));
        return 组合函数(子结果, 参数, 常量);
      },
      {
        描述: `组合公式: ${子公式列表.join(' + ')}`,
        分类: '组合',
      },
    );
  }

  // ─── 公式克隆与变体 ───

  创建变体公式(原公式名, 新公式名, 参数转换器) {
    /**
     * 基于现有公式创建变体
     * @param 参数转换器 - (原参数) => 转换后参数
     */
    const 原公式 = this.公式映射.get(原公式名);
    if (!原公式) {
      throw new Error(`原公式不存在: ${原公式名}`);
    }

    this.注册公式(
      新公式名,
      (参数, 常量) => {
        const 转换后参数 = 参数转换器(参数);
        return 原公式(转换后参数, 常量);
      },
      {
        描述: `${原公式名} 的变体`,
        分类: '变体',
      },
    );
  }

  // ─── 工具方法 ───

  静态方法 = {
    限制范围: (值, 最小, 最大) => Math.max(最小, Math.min(最大, 值)),
    百分比: (值, 总量) => (总量 > 0 ? (值 / 总量) * 100 : 0),
    随机范围: (最小, 最大) => Math.floor(Math.random() * (最大 - 最小 + 1)) + 最小,
    随机浮点: (最小, 最大) => Math.random() * (最大 - 最小) + 最小,
    四舍五入: (值, 小数位 = 0) => {
      const 倍数 = Math.pow(10, 小数位);
      return Math.round(值 * 倍数) / 倍数;
    },
    向下取整: Math.floor,
    向上取整: Math.ceil,
    绝对值: Math.abs,
    幂: Math.pow,
    开方: Math.sqrt,
    对数: Math.log,
  };

  获取工具方法() {
    return this.静态方法;
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 公式引擎 };
export default 公式引擎;
