// ═══════════════════════════════════════════════════════════════
// systems/formula.js
// 公式引擎 - 集中管理所有游戏公式
// ═══════════════════════════════════════════════════════════════

/**
 * 公式引擎
 * 集中管理所有游戏计算公式，支持动态注册和覆盖
 */
class 公式引擎 {
  constructor() {
    // 公式映射: 公式名 -> 计算函数
    this.公式映射 = new Map();

    // 公式元数据
    this.公式元数据 = new Map();

    // 常量表
    this.常量表 = new Map();

    // 公式分类索引
    this.分类索引 = new Map();

    // 计算缓存
    this.缓存 = new Map();
    this.启用缓存 = false;
  }

  // ─── 公式注册 ───

  注册公式(公式名, 计算函数, 元数据 = {}) {
    /**
     * 注册公式
     * @param 公式名 - 公式唯一标识
     * @param 计算函数 - (参数对象) => 计算结果
     * @param 元数据 - { 描述, 参数说明, 分类 }
     */
    this.公式映射.set(公式名, 计算函数);

    this.公式元数据.set(公式名, {
      描述: 元数据.描述 ?? '',
      参数说明: 元数据.参数说明 ?? {},
      分类: 元数据.分类 ?? '通用',
      版本: 元数据.版本 ?? '1.0',
      注册时间: Date.now(),
    });

    // 更新分类索引
    const 分类 = 元数据.分类 ?? '通用';
    if (!this.分类索引.has(分类)) {
      this.分类索引.set(分类, new Set());
    }
    this.分类索引.get(分类).add(公式名);
  }

  批量注册(公式配置对象) {
    /**
     * 批量注册公式
     * @param 公式配置对象 - { 公式名: 计算函数 } 或 { 公式名: { 函数, 元数据 } }
     */
    Object.entries(公式配置对象).forEach(([名称, 配置]) => {
      if (typeof 配置 === 'function') {
        this.注册公式(名称, 配置);
      } else {
        this.注册公式(名称, 配置.函数 ?? 配置.fn, 配置.元数据 ?? 配置);
      }
    });
  }

  // ─── 公式计算 ───

  计算(公式名, 参数 = {}) {
    /**
     * 执行公式计算
     * @param 公式名 - 公式标识
     * @param 参数 - 计算参数对象
     * @returns 计算结果
     */
    const 计算函数 = this.公式映射.get(公式名);

    if (!计算函数) {
      throw new Error(`未注册的公式: ${公式名}`);
    }

    // 检查缓存
    if (this.启用缓存) {
      const 缓存键 = this.生成缓存键(公式名, 参数);
      if (this.缓存.has(缓存键)) {
        return this.缓存.get(缓存键);
      }
    }

    // 合并常量到参数
    const 完整参数 = {
      ...Object.fromEntries(this.常量表),
      ...参数,
    };

    // 执行计算
    try {
      const 结果 = 计算函数(完整参数);

      // 写入缓存
      if (this.启用缓存) {
        const 缓存键 = this.生成缓存键(公式名, 参数);
        this.缓存.set(缓存键, 结果);
      }

      return 结果;
    } catch (错误) {
      console.error(`公式计算错误 [${公式名}]:`, 错误);
      throw 错误;
    }
  }

  安全计算(公式名, 参数 = {}, 默认值 = null) {
    /**
     * 安全计算（出错时返回默认值）
     */
    try {
      return this.计算(公式名, 参数);
    } catch {
      return 默认值;
    }
  }

  批量计算(计算列表) {
    /**
     * 批量计算多个公式
     * @param 计算列表 - [{ 公式名, 参数 }, ...]
     * @returns 结果数组
     */
    return 计算列表.map(({ 公式名, 参数 }) => ({
      公式名,
      结果: this.安全计算(公式名, 参数),
    }));
  }

  // ─── 常量管理 ───

  设置常量(常量名, 值) {
    this.常量表.set(常量名, 值);
  }

  批量设置常量(常量对象) {
    Object.entries(常量对象).forEach(([名称, 值]) => {
      this.常量表.set(名称, 值);
    });
  }

  获取常量(常量名) {
    return this.常量表.get(常量名);
  }

  获取所有常量() {
    return Object.fromEntries(this.常量表);
  }

  // ─── 查询方法 ───

  是否已注册(公式名) {
    return this.公式映射.has(公式名);
  }

  获取公式元数据(公式名) {
    return this.公式元数据.get(公式名);
  }

  获取分类公式列表(分类) {
    const 公式名集合 = this.分类索引.get(分类);
    if (!公式名集合) return [];

    return Array.from(公式名集合).map(名称 => ({
      名称,
      ...this.公式元数据.get(名称),
    }));
  }

  获取所有分类() {
    return Array.from(this.分类索引.keys());
  }

  获取所有公式() {
    return Array.from(this.公式映射.keys()).map(名称 => ({
      名称,
      ...this.公式元数据.get(名称),
    }));
  }

  // ─── 缓存管理 ───

  生成缓存键(公式名, 参数) {
    const 排序参数 = Object.keys(参数)
      .sort()
      .reduce((obj, key) => {
        obj[key] = 参数[key];
        return obj;
      }, {});
    return `${公式名}:${JSON.stringify(排序参数)}`;
  }

  设置缓存启用(启用) {
    this.启用缓存 = 启用;
    if (!启用) {
      this.清空缓存();
    }
  }

  清空缓存() {
    this.缓存.clear();
  }

  // ─── 公式组合 ───

  创建组合公式(公式名, 子公式列表, 组合函数) {
    /**
     * 创建组合公式（由多个子公式组合而成）
     * @param 公式名 - 新公式名称
     * @param 子公式列表 - 子公式名称列表
     * @param 组合函数 - (子结果数组) => 最终结果
     */
    const 引擎 = this;

    this.注册公式(
      公式名,
      参数 => {
        const 子结果 = 子公式列表.map(子公式名 => 引擎.计算(子公式名, 参数));
        return 组合函数(子结果, 参数);
      },
      {
        描述: `组合公式: ${子公式列表.join(' + ')}`,
        分类: '组合',
      },
    );
  }

  // ─── 公式克隆与变体 ───

  创建变体公式(原公式名, 新公式名, 参数转换器) {
    /**
     * 基于现有公式创建变体
     * @param 参数转换器 - (原参数) => 转换后参数
     */
    const 原公式 = this.公式映射.get(原公式名);
    if (!原公式) {
      throw new Error(`原公式不存在: ${原公式名}`);
    }

    this.注册公式(
      新公式名,
      参数 => {
        const 转换后参数 = 参数转换器(参数);
        return 原公式(转换后参数);
      },
      {
        描述: `${原公式名} 的变体`,
        分类: '变体',
      },
    );
  }

  // ─── 工具方法 ───

  静态方法 = {
    // 常用数学函数封装
    限制范围: (值, 最小, 最大) => Math.max(最小, Math.min(最大, 值)),
    百分比: (值, 总量) => (总量 > 0 ? (值 / 总量) * 100 : 0),
    随机范围: (最小, 最大) => Math.floor(Math.random() * (最大 - 最小 + 1)) + 最小,
    随机浮点: (最小, 最大) => Math.random() * (最大 - 最小) + 最小,
    四舍五入: (值, 小数位 = 0) => {
      const 倍数 = Math.pow(10, 小数位);
      return Math.round(值 * 倍数) / 倍数;
    },
    向下取整: Math.floor,
    向上取整: Math.ceil,
    绝对值: Math.abs,
    幂: Math.pow,
    开方: Math.sqrt,
    对数: Math.log,
  };

  获取工具方法() {
    return this.静态方法;
  }
}

// ═══════════════════════════════════════════════════════════════
// 默认公式初始化函数
// ═══════════════════════════════════════════════════════════════

function 初始化默认公式(公式引擎) {
  // ─── 战斗相关公式 ───

  公式引擎.注册公式(
    '士气系数',
    ({ 士气 }) => {
      return Math.pow(1.1, (士气 + 20) / 10 - 10);
    },
    {
      描述: '根据士气计算战斗力系数',
      参数说明: { 士气: '当前士气值 (0-100)' },
      分类: '战斗',
    },
  );

  公式引擎.注册公式(
    '部曲战力',
    ({ 有效喽啰数, 冠军力量, 武装战斗力, 士气 }) => {
      const 士气系数 = 公式引擎.计算('士气系数', { 士气 });
      return (有效喽啰数 + Math.floor(冠军力量 / 20)) * (武装战斗力 / 100) * 士气系数;
    },
    {
      描述: '计算单个部曲的战斗力',
      参数说明: {
        有效喽啰数: '分配给该冠军的喽啰数量',
        冠军力量: '冠军的力量属性',
        武装战斗力: '喽啰的武装战斗力百分比',
        士气: '当前士气值',
      },
      分类: '战斗',
    },
  );

  公式引擎.注册公式(
    '战力估值偏差',
    ({ 情报进度 }) => {
      const n = 情报进度;
      return {
        下限系数: 0.2 + (8 * n) / 1000,
        上限系数: 5 - (4 * n) / 100,
      };
    },
    {
      描述: '根据情报进度计算敌方战力估值的误差范围',
      参数说明: { 情报进度: '对目标的情报进度 (0-100)' },
      分类: '战斗',
    },
  );

  // ─── 任务效率公式 ───

  公式引擎.注册公式(
    '调教效率',
    ({ 智力 }) => {
      return 5 * (智力 / 25) + 5;
    },
    {
      描述: '计算调教任务的臣服度增加量',
      参数说明: { 智力: '冠军的智力属性' },
      分类: '任务',
    },
  );

  公式引擎.注册公式(
    '潜入侦察效率',
    ({ 臣服度, 淫乱度 }) => {
      return 1 * (臣服度 / 50) * (1 - 淫乱度 / 200);
    },
    {
      描述: '计算潜入侦察的效率系数',
      参数说明: {
        臣服度: '母畜的臣服度',
        淫乱度: '母畜的淫乱度',
      },
      分类: '任务',
    },
  );

  公式引擎.注册公式(
    '直接侦察效率',
    ({ 敏捷 }) => {
      return 1 * (敏捷 / 25);
    },
    {
      描述: '计算直接侦察的效率系数',
      参数说明: { 敏捷: '冠军的敏捷属性' },
      分类: '任务',
    },
  );

  公式引擎.注册公式(
    '提振士气效率',
    ({ 淫乱度, 总雌性价值 }) => {
      return 15 * (淫乱度 / 50) * (总雌性价值 / 200);
    },
    {
      描述: '计算提振士气任务的士气增加量',
      参数说明: {
        淫乱度: '母畜的淫乱度',
        总雌性价值: '母畜的总雌性价值',
      },
      分类: '任务',
    },
  );

  公式引擎.注册公式(
    '潜入劝诱成功率',
    ({ 负责人价值, 目标价值 }) => {
      return 负责人价值 / 目标价值 / 2.5;
    },
    {
      描述: '计算潜入劝诱的成功概率',
      参数说明: {
        负责人价值: '执行任务母畜的总雌性价值',
        目标价值: '目标的雌性价值',
      },
      分类: '任务',
    },
  );

  // ─── 资源产出公式 ───

  公式引擎.注册公式(
    '泌乳产量',
    ({ 淫乱度 }) => {
      if (淫乱度 < 25) return 0;
      return Math.floor((淫乱度 + 45) / 20);
    },
    {
      描述: '计算母畜的每周母乳产量',
      参数说明: { 淫乱度: '母畜的淫乱度 (需≥25才能泌乳)' },
      分类: '资源',
    },
  );

  公式引擎.注册公式(
    '祝福水晶效果',
    ({ 淫乱度 }) => {
      return Math.floor(2000 / (淫乱度 + 20));
    },
    {
      描述: '计算祝福水晶恢复的雌性价值',
      参数说明: { 淫乱度: '目标母畜的淫乱度' },
      分类: '资源',
    },
  );

  // ─── 繁殖相关公式 ───

  公式引擎.注册公式(
    '冠军属性生成',
    ({ 总雌性价值, 效率系数, 随机浮动 }) => {
      const 基础值 = 总雌性价值 / 10;
      return Math.max(1, Math.round((基础值 + 随机浮动) * 效率系数));
    },
    {
      描述: '计算生育冠军的单项属性值',
      参数说明: {
        总雌性价值: '母畜的总雌性价值',
        效率系数: '身份对应的属性效率系数',
        随机浮动: '随机浮动值 (通常±5)',
      },
      分类: '繁殖',
    },
  );

  // ─── 情报相关公式 ───

  公式引擎.注册公式(
    '锁定目标值',
    ({ 负责人系数, 情报进度 }) => {
      return (负责人系数 * (情报进度 + 25)) / 100;
    },
    {
      描述: '计算侦察任务锁定高价值目标的数值',
      参数说明: {
        负责人系数: '负责人的相关系数',
        情报进度: '对目标的情报进度',
      },
      分类: '情报',
    },
  );

  // ─── 通用公式 ───

  公式引擎.注册公式(
    '属性百分比',
    ({ 当前值, 最大值 }) => {
      return 最大值 > 0 ? (当前值 / 最大值) * 100 : 0;
    },
    {
      描述: '计算属性的百分比',
      分类: '通用',
    },
  );

  公式引擎.注册公式(
    '经验升级阈值',
    ({ 当前等级 }) => {
      return 当前等级 * 100;
    },
    {
      描述: '计算升级所需经验',
      分类: '通用',
    },
  );
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 公式引擎, 初始化默认公式 };
export default 公式引擎;
