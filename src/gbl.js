// ═══════════════════════════════════════════════════════════════
// 数据模块层 - 定义与配置
// ═══════════════════════════════════════════════════════════════

/**
 * 属性定义注册表
 * 可扩展的属性系统，允许动态注册新属性类型
 */
class 属性定义注册表 {
  constructor() {
    this.属性类型映射 = new Map();
    this.属性计算器映射 = new Map();
    this.属性验证器映射 = new Map();
  }

  注册属性类型(属性名, 配置) {
    // 配置包含: 默认值, 范围, 衰减规则, 增长规则, 阶段效果等
    this.属性类型映射.set(属性名, {
      默认值: 配置.默认值 ?? 0,
      最小值: 配置.最小值 ?? 0,
      最大值: 配置.最大值 ?? Infinity,
      阶段定义: 配置.阶段定义 ?? [],
      衰减配置: 配置.衰减配置 ?? null,
      ...配置,
    });
  }

  注册属性计算器(属性名, 计算函数) {
    this.属性计算器映射.set(属性名, 计算函数);
  }

  获取属性配置(属性名) {
    return this.属性类型映射.get(属性名);
  }

  计算派生属性(属性名, 上下文) {
    const 计算器 = this.属性计算器映射.get(属性名);
    return 计算器 ? 计算器(上下文) : null;
  }

  获取属性阶段(属性名, 当前值) {
    const 配置 = this.属性类型映射.get(属性名);
    if (!配置?.阶段定义) return null;

    return 配置.阶段定义.find(阶段 => 当前值 >= 阶段.下限 && 当前值 <= 阶段.上限);
  }
}

/**
 * 任务定义注册表
 * 支持动态注册任务类型及其执行逻辑
 */
class 任务定义注册表 {
  constructor() {
    this.任务类型映射 = new Map();
    this.任务执行器映射 = new Map();
    this.任务验证器映射 = new Map();
  }

  注册任务类型(任务名, 定义) {
    this.任务类型映射.set(任务名, {
      行动点消耗: 定义.行动点消耗,
      负责人类型: 定义.负责人类型, // ['冠军', '母畜']
      负责人条件: 定义.负责人条件 ?? (() => true),
      效率属性: 定义.效率属性 ?? [],
      产出类型: 定义.产出类型 ?? [],
      副作用: 定义.副作用 ?? [],
      前置条件: 定义.前置条件 ?? (() => true),
      ...定义,
    });
  }

  注册任务执行器(任务名, 执行函数) {
    // 执行函数签名: (任务上下文, 游戏状态) => 任务结果
    this.任务执行器映射.set(任务名, 执行函数);
  }

  注册任务验证器(任务名, 验证函数) {
    this.任务验证器映射.set(任务名, 验证函数);
  }

  获取任务定义(任务名) {
    return this.任务类型映射.get(任务名);
  }

  验证任务可执行性(任务名, 上下文) {
    const 验证器 = this.任务验证器映射.get(任务名);
    const 定义 = this.任务类型映射.get(任务名);

    if (!定义) return { 可执行: false, 原因: '未知任务类型' };
    if (验证器 && !验证器(上下文)) {
      return { 可执行: false, 原因: '自定义验证失败' };
    }
    if (!定义.前置条件(上下文)) {
      return { 可执行: false, 原因: '前置条件不满足' };
    }

    return { 可执行: true };
  }
}

/**
 * 法术定义注册表
 */
class 法术定义注册表 {
  constructor() {
    this.法术映射 = new Map();
    this.法术效果处理器 = new Map();
  }

  注册法术(法术名, 定义) {
    this.法术映射.set(法术名, {
      魔力消耗: 定义.魔力消耗,
      目标类型: 定义.目标类型, // '母畜' | '冠军' | '军队' | '无'
      效果描述: 定义.效果描述,
      效果参数: 定义.效果参数 ?? {},
      施放条件: 定义.施放条件 ?? (() => true),
      ...定义,
    });
  }

  注册效果处理器(法术名, 处理函数) {
    this.法术效果处理器.set(法术名, 处理函数);
  }

  获取法术定义(法术名) {
    return this.法术映射.get(法术名);
  }

  执行法术效果(法术名, 目标, 上下文) {
    const 处理器 = this.法术效果处理器.get(法术名);
    return 处理器 ? 处理器(目标, 上下文) : null;
  }
}

/**
 * 商品定义注册表
 */
class 商品定义注册表 {
  constructor() {
    this.商品分类 = new Map();
    this.商品映射 = new Map();
    this.刷新规则映射 = new Map();
  }

  注册商品分类(分类名, 配置) {
    this.商品分类.set(分类名, {
      刷新周期: 配置.刷新周期 ?? 1,
      随机刷新: 配置.随机刷新 ?? false,
      限购规则: 配置.限购规则 ?? null,
      ...配置,
    });
  }

  注册商品(商品名, 定义) {
    this.商品映射.set(商品名, {
      分类: 定义.分类,
      价格: 定义.价格,
      效果: 定义.效果,
      每周限购: 定义.每周限购 ?? Infinity,
      稀有度: 定义.稀有度 ?? 1,
      刷新权重: 定义.刷新权重 ?? 100,
      购买条件: 定义.购买条件 ?? (() => true),
      ...定义,
    });
  }

  注册刷新规则(分类名, 规则函数) {
    this.刷新规则映射.set(分类名, 规则函数);
  }

  获取分类商品列表(分类名) {
    return Array.from(this.商品映射.entries())
      .filter(([_, 定义]) => 定义.分类 === 分类名)
      .map(([名称, 定义]) => ({ 名称, ...定义 }));
  }
}

/**
 * 事件定义注册表
 */
class 事件定义注册表 {
  constructor() {
    this.事件类型映射 = new Map();
    this.事件处理器映射 = new Map();
    this.事件条件映射 = new Map();
    this.事件权重映射 = new Map();
    this.事件冷却映射 = new Map();
  }

  注册事件类型(事件名, 定义) {
    this.事件类型映射.set(事件名, {
      分类: 定义.分类 ?? '通用', // '战斗' | '繁殖' | '调教' | '探索' | '黑市' | '随机'
      触发时机: 定义.触发时机 ?? 'manual', // 'manual' | 'auto' | 'periodic' | 'conditional'
      优先级: 定义.优先级 ?? 0,
      可重复: 定义.可重复 ?? true,
      冷却周期: 定义.冷却周期 ?? 0,
      前置事件: 定义.前置事件 ?? [],
      互斥事件: 定义.互斥事件 ?? [],
      参与者类型: 定义.参与者类型 ?? [], // ['领主', '冠军', '母畜', '喽啰']
      效果描述: 定义.效果描述 ?? '',
      ...定义,
    });
  }

  注册事件条件(事件名, 条件函数) {
    // 条件函数签名: (上下文) => { 满足: boolean, 原因?: string }
    if (!this.事件条件映射.has(事件名)) {
      this.事件条件映射.set(事件名, []);
    }
    this.事件条件映射.get(事件名).push(条件函数);
  }

  注册事件处理器(事件名, 处理函数) {
    // 处理函数签名: (上下文) => 事件结果
    this.事件处理器映射.set(事件名, 处理函数);
  }

  注册事件权重(事件名, 权重计算函数) {
    // 用于随机事件池的权重计算
    this.事件权重映射.set(事件名, 权重计算函数);
  }

  获取事件定义(事件名) {
    return this.事件类型映射.get(事件名);
  }

  检查事件条件(事件名, 上下文) {
    const 条件列表 = this.事件条件映射.get(事件名) ?? [];

    for (const 条件 of 条件列表) {
      const 结果 = 条件(上下文);
      if (!结果.满足) {
        return { 可触发: false, 原因: 结果.原因 };
      }
    }

    // 检查冷却
    const 定义 = this.事件类型映射.get(事件名);
    if (定义?.冷却周期 > 0) {
      const 上次触发 = this.事件冷却映射.get(事件名);
      if (上次触发 && 上下文.当前周次 - 上次触发 < 定义.冷却周期) {
        return { 可触发: false, 原因: '事件冷却中' };
      }
    }

    // 检查互斥事件
    if (定义?.互斥事件?.length > 0) {
      for (const 互斥事件名 of 定义.互斥事件) {
        if (上下文.本周已触发事件?.includes(互斥事件名)) {
          return { 可触发: false, 原因: `与事件[${互斥事件名}]互斥` };
        }
      }
    }

    return { 可触发: true };
  }

  执行事件(事件名, 上下文) {
    const 处理器 = this.事件处理器映射.get(事件名);
    if (!处理器) {
      return { 成功: false, 原因: '事件处理器未注册' };
    }

    const 结果 = 处理器(上下文);

    // 记录冷却
    const 定义 = this.事件类型映射.get(事件名);
    if (定义?.冷却周期 > 0) {
      this.事件冷却映射.set(事件名, 上下文.当前周次);
    }

    return 结果;
  }

  获取分类事件列表(分类) {
    return Array.from(this.事件类型映射.entries())
      .filter(([_, 定义]) => 定义.分类 === 分类)
      .map(([名称, 定义]) => ({ 名称, ...定义 }));
  }

  计算事件权重(事件名, 上下文) {
    const 权重函数 = this.事件权重映射.get(事件名);
    return 权重函数 ? 权重函数(上下文) : 100;
  }

  获取可触发随机事件池(上下文) {
    const 随机事件列表 = this.获取分类事件列表('随机');
    const 可触发事件 = [];

    for (const 事件 of 随机事件列表) {
      const 检查结果 = this.检查事件条件(事件.名称, 上下文);
      if (检查结果.可触发) {
        const 权重 = this.计算事件权重(事件.名称, 上下文);
        可触发事件.push({ ...事件, 权重 });
      }
    }

    return 可触发事件;
  }
}

// ═══════════════════════════════════════════════════════════════
// 实体模块层 - 实体与工厂
// ═══════════════════════════════════════════════════════════════

/**
 * 实体基类
 * 所有游戏实体的基础，提供属性管理和事件钩子
 */
class 实体基类 {
  constructor(实体类型, 初始数据 = {}) {
    this.实体ID = this.生成唯一ID();
    this.实体类型 = 实体类型;
    this.属性容器 = new Map();
    this.状态标签 = new Set();
    this.元数据 = { 创建时间: Date.now(), ...初始数据.元数据 };
    this.事件监听器 = new Map();
  }

  生成唯一ID() {
    return `${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
  }

  // 属性操作
  设置属性(属性名, 值) {
    const 旧值 = this.属性容器.get(属性名);
    this.属性容器.set(属性名, 值);
    this.触发事件('属性变更', { 属性名, 旧值, 新值: 值 });
  }

  获取属性(属性名, 默认值 = null) {
    return this.属性容器.has(属性名) ? this.属性容器.get(属性名) : 默认值;
  }

  修改属性(属性名, 增量, 属性注册表 = null) {
    const 当前值 = this.获取属性(属性名, 0);
    let 新值 = 当前值 + 增量;

    // 如果有属性注册表，应用范围限制
    if (属性注册表) {
      const 配置 = 属性注册表.获取属性配置(属性名);
      if (配置) {
        新值 = Math.max(配置.最小值, Math.min(配置.最大值, 新值));
      }
    }

    this.设置属性(属性名, 新值);
    return 新值;
  }

  // 状态标签操作
  添加标签(标签) {
    this.状态标签.add(标签);
    this.触发事件('标签添加', { 标签 });
  }

  移除标签(标签) {
    this.状态标签.delete(标签);
    this.触发事件('标签移除', { 标签 });
  }

  拥有标签(标签) {
    return this.状态标签.has(标签);
  }

  // 事件系统
  监听事件(事件名, 处理器) {
    if (!this.事件监听器.has(事件名)) {
      this.事件监听器.set(事件名, []);
    }
    this.事件监听器.get(事件名).push(处理器);
  }

  触发事件(事件名, 数据) {
    const 处理器列表 = this.事件监听器.get(事件名) ?? [];
    处理器列表.forEach(处理器 => 处理器(数据, this));
  }

  // 序列化
  序列化() {
    return {
      实体ID: this.实体ID,
      实体类型: this.实体类型,
      属性: Object.fromEntries(this.属性容器),
      标签: Array.from(this.状态标签),
      元数据: this.元数据,
    };
  }

  静态从序列化恢复(数据) {
    const 实体 = new this.constructor(数据.实体类型);
    实体.实体ID = 数据.实体ID;
    数据.属性 && Object.entries(数据.属性).forEach(([k, v]) => 实体.设置属性(k, v));
    数据.标签 && 数据.标签.forEach(t => 实体.添加标签(t));
    实体.元数据 = 数据.元数据;
    return 实体;
  }
}

/**
 * 领主实体
 */
class 领主实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('领主', 初始数据);
    this.设置属性('魔力', 初始数据.魔力 ?? 0);
  }

  消耗魔力(数量) {
    const 当前魔力 = this.获取属性('魔力');
    if (当前魔力 < 数量) return false;
    this.设置属性('魔力', 当前魔力 - 数量);
    return true;
  }

  获得魔力(数量) {
    this.修改属性('魔力', 数量);
  }
}

/**
 * 冠军实体
 */
class 冠军实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('冠军', 初始数据);

    // 基础信息
    this.设置属性('姓名', 初始数据.姓名 ?? '无名冠军');
    this.设置属性('外貌描述', 初始数据.外貌描述 ?? '');

    // 三维属性
    this.设置属性('力量', 初始数据.力量 ?? 10);
    this.设置属性('敏捷', 初始数据.敏捷 ?? 10);
    this.设置属性('智力', 初始数据.智力 ?? 10);

    // 成长记录
    this.成长日志 = [];
    this.来源信息 = 初始数据.来源信息 ?? null;
  }

  记录成长事件(事件描述) {
    this.成长日志.push({
      时间戳: Date.now(),
      描述: 事件描述,
    });
  }

  计算可统帅喽啰数() {
    return this.获取属性('力量');
  }
}

/**
 * 母畜实体
 */
class 母畜实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('母畜', 初始数据);

    // 身份信息
    this.设置属性('姓名', 初始数据.姓名 ?? '无名母畜');
    this.设置属性('原身份', 初始数据.原身份 ?? '普通人');
    this.设置属性('种族', 初始数据.种族 ?? '人类');
    this.设置属性('外貌描述', 初始数据.外貌描述 ?? '');

    // 核心属性
    this.设置属性('总雌性价值', 初始数据.总雌性价值 ?? 100);
    this.设置属性('剩余雌性价值', 初始数据.剩余雌性价值 ?? 初始数据.总雌性价值 ?? 100);
    this.设置属性('臣服度', 初始数据.臣服度 ?? 0);
    this.设置属性('淫乱度', 初始数据.淫乱度 ?? 0);

    // 特殊标签
    if (初始数据.特殊标签) {
      初始数据.特殊标签.forEach(标签 => this.添加标签(标签));
    }
  }

  可担任任务类型(任务定义注册表) {
    const 臣服度 = this.获取属性('臣服度');
    const 淫乱度 = this.获取属性('淫乱度');
    const 可用任务 = [];

    // 根据臣服度和淫乱度判断可担任的任务
    // 具体逻辑由任务系统配置决定
    任务定义注册表.任务类型映射.forEach((定义, 任务名) => {
      if (定义.负责人类型.includes('母畜')) {
        if (定义.负责人条件({ 臣服度, 淫乱度, 实体: this })) {
          可用任务.push(任务名);
        }
      }
    });

    return 可用任务;
  }

  消耗雌性价值(数量) {
    const 剩余 = this.获取属性('剩余雌性价值');
    if (剩余 < 数量) return false;
    this.设置属性('剩余雌性价值', 剩余 - 数量);
    return true;
  }

  计算泌乳产量() {
    const 淫乱度 = this.获取属性('淫乱度');
    return Math.floor((淫乱度 + 45) / 20);
  }
}

/**
 * 喽啰池
 * 喽啰以数值形式存在，不作为独立实体管理
 */
class 喽啰池 {
  constructor() {
    this.武装分组 = new Map();
    // 默认分组：未武装
    this.武装分组.set('未武装', { 数量: 0, 战斗力: 100 });
  }

  注册武装等级(等级名, 战斗力) {
    if (!this.武装分组.has(等级名)) {
      this.武装分组.set(等级名, { 数量: 0, 战斗力 });
    }
  }

  增加喽啰(数量, 武装等级 = '未武装') {
    const 分组 = this.武装分组.get(武装等级);
    if (分组) {
      分组.数量 += 数量;
    }
  }

  减少喽啰(数量, 武装等级 = '未武装') {
    const 分组 = this.武装分组.get(武装等级);
    if (分组) {
      分组.数量 = Math.max(0, 分组.数量 - 数量);
    }
  }

  武装升级(数量, 从等级, 到等级) {
    const 源分组 = this.武装分组.get(从等级);
    const 目标分组 = this.武装分组.get(到等级);

    if (!源分组 || !目标分组) return false;
    if (源分组.数量 < 数量) return false;

    源分组.数量 -= 数量;
    目标分组.数量 += 数量;
    return true;
  }

  获取总数量() {
    let 总数 = 0;
    this.武装分组.forEach(分组 => (总数 += 分组.数量));
    return 总数;
  }

  获取分组详情() {
    return Array.from(this.武装分组.entries()).map(([等级, 数据]) => ({
      等级,
      ...数据,
    }));
  }

  计算加权战斗力() {
    let 加权总和 = 0;
    let 总数量 = 0;

    this.武装分组.forEach(分组 => {
      加权总和 += 分组.数量 * 分组.战斗力;
      总数量 += 分组.数量;
    });

    return 总数量 > 0 ? 加权总和 / 总数量 : 100;
  }
}

/**
 * 冠军工厂
 */
class 冠军工厂 {
  constructor(属性注册表) {
    this.属性注册表 = 属性注册表;
    this.效率系数表 = new Map();
    this.姓名生成器 = null;
    this.外貌生成器 = null;
  }

  注册效率系数(身份类型, 系数配置) {
    // 系数配置: { 力量: 1.0, 敏捷: 1.0, 智力: 1.0 }
    this.效率系数表.set(身份类型, 系数配置);
  }

  设置姓名生成器(生成函数) {
    this.姓名生成器 = 生成函数;
  }

  设置外貌生成器(生成函数) {
    this.外貌生成器 = 生成函数;
  }

  从母畜生育(母畜实体) {
    const 母畜身份 = 母畜实体.获取属性('原身份');
    const 总雌性价值 = 母畜实体.获取属性('总雌性价值');
    const 效率系数 = this.效率系数表.get(母畜身份) ?? { 力量: 1.0, 敏捷: 1.0, 智力: 1.0 };

    const 基础值 = 总雌性价值 / 10;
    const 随机浮动 = () => Math.floor(Math.random() * 11) - 5; // ±5

    const 冠军数据 = {
      姓名: this.姓名生成器?.() ?? '新生冠军',
      外貌描述: this.外貌生成器?.() ?? '',
      力量: Math.round((基础值 + 随机浮动()) * 效率系数.力量),
      敏捷: Math.round((基础值 + 随机浮动()) * 效率系数.敏捷),
      智力: Math.round((基础值 + 随机浮动()) * 效率系数.智力),
      来源信息: {
        母畜ID: 母畜实体.实体ID,
        母畜姓名: 母畜实体.获取属性('姓名'),
        出生时间: Date.now(),
      },
    };

    return new 冠军实体(冠军数据);
  }
}

/**
 * 母畜工厂
 */
class 母畜工厂 {
  constructor(属性注册表) {
    this.属性注册表 = 属性注册表;
    this.身份价值表 = new Map();
    this.姓名生成器 = null;
    this.外貌生成器 = null;
  }

  注册身份价值(身份类型, 价值范围) {
    // 价值范围: { 最小: 100, 最大: 150 }
    this.身份价值表.set(身份类型, 价值范围);
  }

  设置姓名生成器(生成函数) {
    this.姓名生成器 = 生成函数;
  }

  设置外貌生成器(生成函数) {
    this.外貌生成器 = 生成函数;
  }

  创建母畜(配置) {
    const 身份 = 配置.原身份 ?? '普通人';
    const 价值范围 = this.身份价值表.get(身份) ?? { 最小: 80, 最大: 120 };

    const 总雌性价值 =
      配置.总雌性价值 ?? Math.floor(Math.random() * (价值范围.最大 - 价值范围.最小 + 1)) + 价值范围.最小;

    return new 母畜实体({
      姓名: 配置.姓名 ?? this.姓名生成器?.() ?? '无名女子',
      原身份: 身份,
      种族: 配置.种族 ?? '人类',
      外貌描述: 配置.外貌描述 ?? this.外貌生成器?.() ?? '',
      总雌性价值,
      剩余雌性价值: 总雌性价值,
      臣服度: 配置.臣服度 ?? 0,
      淫乱度: 配置.淫乱度 ?? 0,
      特殊标签: 配置.特殊标签 ?? [],
    });
  }
}

// ═══════════════════════════════════════════════════════════════
// 系统模块层 - 核心系统
// ═══════════════════════════════════════════════════════════════

/**
 * 公式引擎
 * 集中管理所有游戏公式，支持动态注册和覆盖
 */
class 公式引擎 {
  constructor() {
    this.公式映射 = new Map();
  }

  注册公式(公式名, 计算函数) {
    this.公式映射.set(公式名, 计算函数);
  }

  计算(公式名, 参数) {
    const 计算函数 = this.公式映射.get(公式名);
    if (!计算函数) {
      throw new Error(`未注册的公式: ${公式名}`);
    }
    return 计算函数(参数);
  }

  批量注册(公式配置对象) {
    Object.entries(公式配置对象).forEach(([名称, 函数]) => {
      this.注册公式(名称, 函数);
    });
  }
}

/**
 * 时间系统
 */
class 时间系统 {
  constructor(事件总线) {
    this.事件总线 = 事件总线;
    this.当前周次 = 1;
    this.周行动点上限 = 3;
    this.剩余行动点 = 3;
    this.周结算处理器 = [];
  }

  注册周结算处理器(处理函数) {
    this.周结算处理器.push(处理函数);
  }

  消耗行动点(数量) {
    if (this.剩余行动点 < 数量) {
      return { 成功: false, 原因: '行动点不足' };
    }
    this.剩余行动点 -= 数量;
    this.事件总线.发布('行动点消耗', { 消耗数量: 数量, 剩余: this.剩余行动点 });
    return { 成功: true };
  }

  结束当前周(游戏状态) {
    // 执行所有周结算处理器
    const 结算结果列表 = [];

    this.周结算处理器.forEach(处理器 => {
      const 结果 = 处理器(游戏状态, this.当前周次);
      结算结果列表.push(结果);
    });

    this.事件总线.发布('周结算完成', {
      周次: this.当前周次,
      结算结果: 结算结果列表,
    });

    // 进入新周
    this.当前周次++;
    this.剩余行动点 = this.周行动点上限;

    this.事件总线.发布('新周开始', {
      周次: this.当前周次,
      行动点: this.剩余行动点,
    });
  }
}

/**
 * 资源系统
 */
class 资源系统 {
  constructor(事件总线) {
    this.事件总线 = 事件总线;
    this.资源映射 = new Map();
    this.产出规则 = new Map();
    this.消耗规则 = new Map();
  }

  注册资源类型(资源名, 初始值 = 0) {
    this.资源映射.set(资源名, 初始值);
  }

  注册产出规则(资源名, 规则函数) {
    if (!this.产出规则.has(资源名)) {
      this.产出规则.set(资源名, []);
    }
    this.产出规则.get(资源名).push(规则函数);
  }

  注册消耗规则(资源名, 规则函数) {
    if (!this.消耗规则.has(资源名)) {
      this.消耗规则.set(资源名, []);
    }
    this.消耗规则.get(资源名).push(规则函数);
  }

  获取资源(资源名) {
    return this.资源映射.get(资源名) ?? 0;
  }

  修改资源(资源名, 增量) {
    const 当前值 = this.获取资源(资源名);
    const 新值 = Math.max(0, 当前值 + 增量);
    this.资源映射.set(资源名, 新值);

    this.事件总线.发布('资源变更', {
      资源名,
      旧值: 当前值,
      新值,
      增量,
    });

    return 新值;
  }

  周结算处理(游戏状态) {
    const 结算明细 = [];

    // 处理产出
    this.产出规则.forEach((规则列表, 资源名) => {
      规则列表.forEach(规则 => {
        const 产出量 = 规则(游戏状态);
        if (产出量 > 0) {
          this.修改资源(资源名, 产出量);
          结算明细.push({ 类型: '产出', 资源名, 数量: 产出量 });
        }
      });
    });

    // 处理消耗
    this.消耗规则.forEach((规则列表, 资源名) => {
      规则列表.forEach(规则 => {
        const 消耗量 = 规则(游戏状态);
        if (消耗量 > 0) {
          this.修改资源(资源名, -消耗量);
          结算明细.push({ 类型: '消耗', 资源名, 数量: 消耗量 });
        }
      });
    });

    return 结算明细;
  }
}

/**
 * 任务系统
 */
class 任务系统 {
  constructor(事件总线, 任务注册表, 时间系统, 公式引擎) {
    this.事件总线 = 事件总线;
    this.任务注册表 = 任务注册表;
    this.时间系统 = 时间系统;
    this.公式引擎 = 公式引擎;
    this.进行中任务 = [];
  }

  验证任务(任务名, 负责人, 游戏状态, 额外参数 = {}) {
    const 定义 = this.任务注册表.获取任务定义(任务名);
    if (!定义) {
      return { 可执行: false, 原因: '未知任务类型' };
    }

    // 检查行动点
    if (this.时间系统.剩余行动点 < 定义.行动点消耗) {
      return { 可执行: false, 原因: '行动点不足' };
    }

    // 检查负责人类型
    if (!定义.负责人类型.includes(负责人.实体类型)) {
      return { 可执行: false, 原因: '负责人类型不匹配' };
    }

    // 检查负责人条件
    const 上下文 = {
      负责人,
      游戏状态,
      ...额外参数,
    };
    if (!定义.负责人条件(上下文)) {
      return { 可执行: false, 原因: '负责人条件不满足' };
    }

    // 检查前置条件
    if (!定义.前置条件(上下文)) {
      return { 可执行: false, 原因: '前置条件不满足' };
    }

    return { 可执行: true };
  }

  执行任务(任务名, 负责人, 游戏状态, 额外参数 = {}) {
    // 验证
    const 验证结果 = this.验证任务(任务名, 负责人, 游戏状态, 额外参数);
    if (!验证结果.可执行) {
      return { 成功: false, 原因: 验证结果.原因 };
    }

    const 定义 = this.任务注册表.获取任务定义(任务名);

    // 消耗行动点
    this.时间系统.消耗行动点(定义.行动点消耗);

    // 构建执行上下文
    const 上下文 = {
      任务名,
      负责人,
      游戏状态,
      公式引擎: this.公式引擎,
      事件总线: this.事件总线,
      ...额外参数,
    };

    // 获取并执行任务执行器
    const 执行器 = this.任务注册表.任务执行器映射.get(任务名);
    if (!执行器) {
      return { 成功: false, 原因: '任务执行器未注册' };
    }

    const 执行结果 = 执行器(上下文);

    // 处理副作用
    定义.副作用.forEach(副作用处理器 => {
      副作用处理器(上下文, 执行结果);
    });

    this.事件总线.发布('任务完成', {
      任务名,
      负责人ID: 负责人.实体ID,
      结果: 执行结果,
    });

    return { 成功: true, 结果: 执行结果 };
  }
}

/**
 * 情报系统
 */
class 情报系统 {
  constructor(事件总线, 公式引擎) {
    this.事件总线 = 事件总线;
    this.公式引擎 = 公式引擎;
    this.目标情报 = new Map();
  }

  创建目标(目标ID, 初始数据 = {}) {
    this.目标情报.set(目标ID, {
      情报进度: 初始数据.情报进度 ?? 0,
      已锁定目标: new Set(),
      高价值目标列表: 初始数据.高价值目标列表 ?? [],
      战力估值: null,
      最后侦察周次: null,
    });
  }

  增加情报进度(目标ID, 增量) {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报) return;

    情报.情报进度 = Math.min(100, 情报.情报进度 + 增量);
    this.更新战力估值(目标ID);
    this.事件总线.发布('情报更新', { 目标ID, 情报进度: 情报.情报进度 });
  }

  更新战力估值(目标ID) {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报) return;

    const n = 情报.情报进度;
    情报.战力估值 = {
      下限系数: 0.2 + (8 * n) / 1000,
      上限系数: 5 - (4 * n) / 100,
    };
  }

  尝试锁定目标(目标ID, 负责人系数) {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报) return [];

    const 锁定值 = (负责人系数 * (情报.情报进度 + 25)) / 100;
    const 必定锁定数 = Math.floor(锁定值 / 100);
    const 额外锁定概率 = (锁定值 % 100) / 100;

    const 新锁定 = [];
    const 可锁定目标 = 情报.高价值目标列表.filter(t => !情报.已锁定目标.has(t));

    // 必定锁定
    for (let i = 0; i < Math.min(必定锁定数, 可锁定目标.length); i++) {
      const 目标 = 可锁定目标[i];
      情报.已锁定目标.add(目标);
      新锁定.push(目标);
    }

    // 概率锁定
    if (可锁定目标.length > 必定锁定数 && Math.random() < 额外锁定概率) {
      const 目标 = 可锁定目标[必定锁定数];
      情报.已锁定目标.add(目标);
      新锁定.push(目标);
    }

    return 新锁定;
  }

  获取目标情报(目标ID) {
    return this.目标情报.get(目标ID);
  }
}

/**
 * 战斗系统
 */
class 战斗系统 {
  constructor(事件总线, 公式引擎, 情报系统) {
    this.事件总线 = 事件总线;
    this.公式引擎 = 公式引擎;
    this.情报系统 = 情报系统;
    this.战斗结果处理器 = new Map();
  }

  注册战斗结果处理器(结果类型, 处理函数) {
    this.战斗结果处理器.set(结果类型, 处理函数);
  }

  计算部曲战力(冠军, 喽啰配置, 士气) {
    const 力量 = 冠军.获取属性('力量');
    const 可统帅上限 = 力量;

    let 总战力 = 0;
    let 已分配喽啰 = 0;

    喽啰配置.forEach(配置 => {
      const 有效数量 = Math.min(配置.数量, 可统帅上限 - 已分配喽啰);
      if (有效数量 <= 0) return;

      const 部曲战力 = (有效数量 + Math.floor(力量 / 20)) * (配置.战斗力 / 100);
      总战力 += 部曲战力;
      已分配喽啰 += 有效数量;
    });

    // 士气系数
    const 士气系数 = Math.pow(1.1, (士气 + 20) / 10 - 10);

    return 总战力 * 士气系数;
  }

  计算军队总战力(出击配置, 士气) {
    let 总战力 = 0;

    出击配置.部曲列表.forEach(部曲 => {
      总战力 += this.计算部曲战力(部曲.冠军, 部曲.喽啰配置, 士气);
    });

    return 总战力;
  }

  执行战斗(我方配置, 敌方战力, 目标ID) {
    const 我方战力 = this.计算军队总战力(我方配置, 我方配置.士气);
    const 战力比 = 我方战力 / 敌方战力;

    // 确定战斗结果
    const 结果 = this.判定战斗结果(战力比);

    // 计算损失
    const 喽啰损失 = this.计算喽啰损失(我方配置, 结果.存活率);

    // 处理战利品
    const 战利品 = this.处理战利品(目标ID, 结果);

    // 士气变化
    const 士气变化 = 结果.士气变化;

    const 战斗报告 = {
      我方战力,
      敌方战力,
      战力比,
      结果类型: 结果.类型,
      喽啰损失,
      战利品,
      士气变化,
    };

    this.事件总线.发布('战斗结束', 战斗报告);

    return 战斗报告;
  }

  判定战斗结果(战力比) {
    // 使用公式引擎或内部逻辑判定
    const 结果表 = [
      { 下限: 0, 上限: 0.5, 类型: '溃败', 存活率: 0.2, 士气变化: -50 },
      { 下限: 0.5, 上限: 0.8, 类型: '惨败', 存活率: 0.4, 士气变化: -20 },
      { 下限: 0.8, 上限: 1.0, 类型: '惜败', 存活率: 0.6, 士气变化: -10 },
      { 下限: 1.0, 上限: 1.2, 类型: '略占上风', 存活率: 0.8, 士气变化: 0, 保底俘获: 1 },
      { 下限: 1.2, 上限: 1.5, 类型: '大获全胜', 存活率: 0.95, 士气变化: -5, 保底俘获: 2 },
      { 下限: 1.5, 上限: 2.0, 类型: '大获全胜', 存活率: 0.95, 士气变化: -20, 保底俘获: 3 },
      { 下限: 2.0, 上限: Infinity, 类型: '碾压', 存活率: 1.0, 士气变化: -30, 全部俘获: true },
    ];

    return 结果表.find(r => 战力比 >= r.下限 && 战力比 < r.上限);
  }

  计算喽啰损失(配置, 存活率) {
    const 损失明细 = [];
    配置.部曲列表.forEach(部曲 => {
      部曲.喽啰配置.forEach(喽啰组 => {
        const 损失数 = Math.floor(喽啰组.数量 * (1 - 存活率));
        损失明细.push({
          武装等级: 喽啰组.武装等级,
          损失数量: 损失数,
        });
      });
    });
    return 损失明细;
  }

  处理战利品(目标ID, 战斗结果) {
    const 情报 = this.情报系统.获取目标情报(目标ID);
    if (!情报) return { 俘获目标: [] };

    const 俘获目标 = [];

    // 已锁定目标全部俘获
    情报.已锁定目标.forEach(目标 => 俘获目标.push(目标));

    // 保底俘获
    if (战斗结果.保底俘获) {
      const 未锁定目标 = 情报.高价值目标列表.filter(t => !情报.已锁定目标.has(t));
      for (let i = 0; i < Math.min(战斗结果.保底俘获, 未锁定目标.length); i++) {
        俘获目标.push(未锁定目标[i]);
      }
    }

    // 全部俘获
    if (战斗结果.全部俘获) {
      情报.高价值目标列表.forEach(目标 => {
        if (!俘获目标.includes(目标)) {
          俘获目标.push(目标);
        }
      });
    }

    return { 俘获目标 };
  }
}

/**
 * 繁殖系统
 */
class 繁殖系统 {
  constructor(事件总线, 冠军工厂, 喽啰池, 属性注册表) {
    this.事件总线 = 事件总线;
    this.冠军工厂 = 冠军工厂;
    this.喽啰池 = 喽啰池;
    this.属性注册表 = 属性注册表;
    this.雌性价值消耗量 = 100;
    this.喽啰产出量 = 10;
  }

  生育冠军(母畜) {
    const 剩余价值 = 母畜.获取属性('剩余雌性价值');
    if (剩余价值 < this.雌性价值消耗量) {
      return { 成功: false, 原因: '剩余雌性价值不足' };
    }

    // 消耗雌性价值
    母畜.消耗雌性价值(this.雌性价值消耗量);

    // 增加淫乱度
    母畜.修改属性('淫乱度', 8, this.属性注册表);

    // 生成冠军
    const 新冠军 = this.冠军工厂.从母畜生育(母畜);

    this.事件总线.发布('冠军诞生', {
      冠军: 新冠军,
      母畜ID: 母畜.实体ID,
    });

    return { 成功: true, 冠军: 新冠军 };
  }

  生育喽啰(母畜) {
    const 剩余价值 = 母畜.获取属性('剩余雌性价值');

    let 实际产出;
    if (剩余价值 >= this.雌性价值消耗量) {
      母畜.消耗雌性价值(this.雌性价值消耗量);
      实际产出 = this.喽啰产出量;
    } else {
      // 不足100时按10点/喽啰计算
      实际产出 = Math.floor(剩余价值 / 10);
      母畜.设置属性('剩余雌性价值', 0);
    }

    if (实际产出 <= 0) {
      return { 成功: false, 原因: '剩余雌性价值不足' };
    }

    // 增加淫乱度
    母畜.修改属性('淫乱度', 8, this.属性注册表);

    // 增加喽啰
    this.喽啰池.增加喽啰(实际产出);

    this.事件总线.发布('喽啰诞生', {
      数量: 实际产出,
      母畜ID: 母畜.实体ID,
    });

    return { 成功: true, 产出数量: 实际产出 };
  }
}

/**
 * 法术系统
 */
class 法术系统 {
  constructor(事件总线, 法术注册表, 领主) {
    this.事件总线 = 事件总线;
    this.法术注册表 = 法术注册表;
    this.领主 = 领主;
  }

  验证施法(法术名, 目标 = null) {
    const 定义 = this.法术注册表.获取法术定义(法术名);
    if (!定义) {
      return { 可施放: false, 原因: '未知法术' };
    }

    // 检查魔力
    if (this.领主.获取属性('魔力') < 定义.魔力消耗) {
      return { 可施放: false, 原因: '魔力不足' };
    }

    // 检查目标类型
    if (定义.目标类型 !== '无' && !目标) {
      return { 可施放: false, 原因: '需要指定目标' };
    }

    if (目标 && 定义.目标类型 !== 目标.实体类型) {
      return { 可施放: false, 原因: '目标类型不匹配' };
    }

    // 检查施放条件
    if (!定义.施放条件({ 领主: this.领主, 目标 })) {
      return { 可施放: false, 原因: '施放条件不满足' };
    }

    return { 可施放: true };
  }

  施放法术(法术名, 目标 = null) {
    const 验证结果 = this.验证施法(法术名, 目标);
    if (!验证结果.可施放) {
      return { 成功: false, 原因: 验证结果.原因 };
    }

    const 定义 = this.法术注册表.获取法术定义(法术名);

    // 消耗魔力
    this.领主.消耗魔力(定义.魔力消耗);

    // 执行效果
    const 效果结果 = this.法术注册表.执行法术效果(法术名, 目标, {
      领主: this.领主,
      效果参数: 定义.效果参数,
    });

    this.事件总线.发布('法术施放', {
      法术名,
      目标ID: 目标?.实体ID,
      效果结果,
    });

    return { 成功: true, 效果结果 };
  }

  献祭母畜(母畜) {
    const 淫乱度 = 母畜.获取属性('淫乱度');
    if (淫乱度 < 100) {
      return { 成功: false, 原因: '未达到完全淫堕状态' };
    }

    const 总雌性价值 = 母畜.获取属性('总雌性价值');
    const 魔力获得 = Math.floor(总雌性价值 / 100);

    this.领主.获得魔力(魔力获得);

    this.事件总线.发布('母畜献祭', {
      母畜ID: 母畜.实体ID,
      魔力获得,
    });

    return { 成功: true, 魔力获得, 需移除母畜: true };
  }
}

/**
 * 黑市系统
 */
class 黑市系统 {
  constructor(事件总线, 商品注册表, 资源系统) {
    this.事件总线 = 事件总线;
    this.商品注册表 = 商品注册表;
    this.资源系统 = 资源系统;
    this.当前商品库存 = new Map();
    this.本周购买记录 = new Map();
  }

  刷新商品(周次) {
    this.本周购买记录.clear();

    // 固定商品
    this.商品注册表.商品映射.forEach((定义, 商品名) => {
      if (!定义.随机刷新) {
        this.当前商品库存.set(商品名, {
          ...定义,
          剩余限购: 定义.每周限购,
        });
      }
    });

    // 随机商品（根据分类刷新规则）
    this.商品注册表.商品分类.forEach((配置, 分类名) => {
      if (配置.随机刷新) {
        const 刷新规则 = this.商品注册表.刷新规则映射.get(分类名);
        if (刷新规则) {
          const 刷新结果 = 刷新规则(周次);
          刷新结果.forEach(商品 => {
            this.当前商品库存.set(商品.名称, {
              ...商品,
              剩余限购: 商品.每周限购,
            });
          });
        }
      }
    });

    this.事件总线.发布('黑市刷新', { 周次, 可用商品: this.获取可用商品列表() });
  }

  获取可用商品列表() {
    return Array.from(this.当前商品库存.entries())
      .filter(([_, 数据]) => 数据.剩余限购 > 0)
      .map(([名称, 数据]) => ({ 名称, ...数据 }));
  }

  购买商品(商品名, 数量 = 1) {
    const 商品数据 = this.当前商品库存.get(商品名);
    if (!商品数据) {
      return { 成功: false, 原因: '商品不存在' };
    }

    if (商品数据.剩余限购 < 数量) {
      return { 成功: false, 原因: '超出限购数量' };
    }

    const 总价 = 商品数据.价格 * 数量;
    const 当前母乳 = this.资源系统.获取资源('母乳');

    if (当前母乳 < 总价) {
      return { 成功: false, 原因: '母乳不足' };
    }

    // 扣除母乳
    this.资源系统.修改资源('母乳', -总价);

    // 减少库存
    商品数据.剩余限购 -= 数量;

    // 记录购买
    const 已购数量 = this.本周购买记录.get(商品名) ?? 0;
    this.本周购买记录.set(商品名, 已购数量 + 数量);

    this.事件总线.发布('商品购买', {
      商品名,
      数量,
      总价,
      效果: 商品数据.效果,
    });

    return { 成功: true, 效果: 商品数据.效果, 数量 };
  }
}

// ═══════════════════════════════════════════════════════════════
// 游戏主控制器层
// ═══════════════════════════════════════════════════════════════

/**
 * 事件总线
 * 全局事件发布订阅系统
 */
class 事件总线 {
  constructor() {
    this.订阅者映射 = new Map();
    this.事件历史 = [];
    this.历史上限 = 1000;
  }

  订阅(事件名, 处理器, 优先级 = 0) {
    if (!this.订阅者映射.has(事件名)) {
      this.订阅者映射.set(事件名, []);
    }

    const 订阅列表 = this.订阅者映射.get(事件名);
    订阅列表.push({ 处理器, 优先级 });
    订阅列表.sort((a, b) => b.优先级 - a.优先级);

    // 返回取消订阅函数
    return () => {
      const 索引 = 订阅列表.findIndex(s => s.处理器 === 处理器);
      if (索引 !== -1) 订阅列表.splice(索引, 1);
    };
  }

  发布(事件名, 数据 = {}) {
    const 事件对象 = {
      名称: 事件名,
      时间戳: Date.now(),
      数据,
      已阻止: false,
    };

    // 记录历史
    this.事件历史.push(事件对象);
    if (this.事件历史.length > this.历史上限) {
      this.事件历史.shift();
    }

    // 通知订阅者
    const 订阅列表 = this.订阅者映射.get(事件名) ?? [];
    for (const { 处理器 } of 订阅列表) {
      if (事件对象.已阻止) break;
      处理器(事件对象);
    }

    // 通知通配符订阅者
    const 通配符订阅 = this.订阅者映射.get('*') ?? [];
    通配符订阅.forEach(({ 处理器 }) => 处理器(事件对象));

    return 事件对象;
  }

  获取事件历史(事件名 = null, 数量 = 100) {
    let 历史 = this.事件历史;
    if (事件名) {
      历史 = 历史.filter(e => e.名称 === 事件名);
    }
    return 历史.slice(-数量);
  }
}

/**
 * 配置加载器
 * 负责加载和解析游戏配置
 */
class 配置加载器 {
  constructor() {
    this.配置缓存 = new Map();
    this.加载器映射 = new Map();
  }

  注册加载器(配置类型, 加载函数) {
    this.加载器映射.set(配置类型, 加载函数);
  }

  async 加载配置(配置类型, 来源) {
    const 加载器 = this.加载器映射.get(配置类型);
    if (!加载器) {
      throw new Error(`未注册的配置类型: ${配置类型}`);
    }

    const 配置数据 = await 加载器(来源);
    this.配置缓存.set(配置类型, 配置数据);
    return 配置数据;
  }

  获取配置(配置类型) {
    return this.配置缓存.get(配置类型);
  }

  应用配置到注册表(配置类型, 注册表) {
    const 配置数据 = this.获取配置(配置类型);
    if (!配置数据) return;

    // 根据配置类型应用到对应注册表
    // 具体实现取决于配置格式
  }
}

/**
 * 游戏状态
 * 管理所有游戏实体和全局状态
 */
class 游戏状态 {
  constructor() {
    this.领主 = null;
    this.冠军列表 = [];
    this.母畜列表 = [];
    this.喽啰池 = new 喽啰池();
    this.军队状态 = {
      士气: 50,
      战斗力基础值: 100,
    };
    this.全局变量 = new Map();
  }

  设置领主(领主实体) {
    this.领主 = 领主实体;
  }

  添加冠军(冠军实体) {
    this.冠军列表.push(冠军实体);
  }

  移除冠军(冠军ID) {
    const 索引 = this.冠军列表.findIndex(c => c.实体ID === 冠军ID);
    if (索引 !== -1) {
      return this.冠军列表.splice(索引, 1)[0];
    }
    return null;
  }

  添加母畜(母畜实体) {
    this.母畜列表.push(母畜实体);
  }

  移除母畜(母畜ID) {
    const 索引 = this.母畜列表.findIndex(m => m.实体ID === 母畜ID);
    if (索引 !== -1) {
      return this.母畜列表.splice(索引, 1)[0];
    }
    return null;
  }

  获取冠军(冠军ID) {
    return this.冠军列表.find(c => c.实体ID === 冠军ID);
  }

  获取母畜(母畜ID) {
    return this.母畜列表.find(m => m.实体ID === 母畜ID);
  }

  获取所有繁殖状态母畜() {
    return this.母畜列表.filter(m => m.拥有标签('繁殖状态') && m.获取属性('剩余雌性价值') > 0);
  }

  获取所有泌乳状态母畜() {
    return this.母畜列表.filter(m => m.获取属性('淫乱度') >= 25);
  }

  修改士气(增量) {
    this.军队状态.士气 = Math.max(0, Math.min(100, this.军队状态.士气 + 增量));
  }

  设置全局变量(键, 值) {
    this.全局变量.set(键, 值);
  }

  获取全局变量(键, 默认值 = null) {
    return this.全局变量.has(键) ? this.全局变量.get(键) : 默认值;
  }

  序列化() {
    return {
      领主: this.领主?.序列化(),
      冠军列表: this.冠军列表.map(c => c.序列化()),
      母畜列表: this.母畜列表.map(m => m.序列化()),
      喽啰池: {
        分组: Array.from(this.喽啰池.武装分组.entries()),
      },
      军队状态: { ...this.军队状态 },
      全局变量: Object.fromEntries(this.全局变量),
    };
  }
}

/**
 * 插件系统
 * 支持扩展游戏功能
 */
class 插件系统 {
  constructor(游戏控制器) {
    this.游戏控制器 = 游戏控制器;
    this.已加载插件 = new Map();
    this.钩子点 = new Map();
  }

  注册钩子点(钩子名) {
    if (!this.钩子点.has(钩子名)) {
      this.钩子点.set(钩子名, []);
    }
  }

  添加钩子(钩子名, 处理函数, 优先级 = 0) {
    if (!this.钩子点.has(钩子名)) {
      this.注册钩子点(钩子名);
    }

    const 钩子列表 = this.钩子点.get(钩子名);
    钩子列表.push({ 处理函数, 优先级 });
    钩子列表.sort((a, b) => b.优先级 - a.优先级);
  }

  执行钩子(钩子名, 上下文) {
    const 钩子列表 = this.钩子点.get(钩子名) ?? [];
    let 结果 = 上下文;

    for (const { 处理函数 } of 钩子列表) {
      结果 = 处理函数(结果, this.游戏控制器);
      if (结果?.中断) break;
    }

    return 结果;
  }

  async 加载插件(插件定义) {
    const { 名称, 版本, 初始化函数, 依赖 = [] } = 插件定义;

    // 检查依赖
    for (const 依赖名 of 依赖) {
      if (!this.已加载插件.has(依赖名)) {
        throw new Error(`插件 ${名称} 依赖未满足: ${依赖名}`);
      }
    }

    // 执行初始化
    const 插件实例 = await 初始化函数(this.游戏控制器, this);

    this.已加载插件.set(名称, {
      版本,
      实例: 插件实例,
    });

    return 插件实例;
  }

  获取插件(插件名) {
    return this.已加载插件.get(插件名)?.实例;
  }
}

/**
 * 游戏主控制器
 * 整合所有系统，提供统一的游戏接口
 */
class 游戏主控制器 {
  constructor() {
    // 初始化核心组件
    this.事件总线 = new 事件总线();
    this.配置加载器 = new 配置加载器();
    this.游戏状态 = new 游戏状态();
    this.插件系统 = new 插件系统(this);

    // 初始化注册表
    this.属性注册表 = new 属性定义注册表();
    this.任务注册表 = new 任务定义注册表();
    this.法术注册表 = new 法术定义注册表();
    this.商品注册表 = new 商品定义注册表();
    this.事件注册表 = new 事件定义注册表();

    // 初始化公式引擎
    this.公式引擎 = new 公式引擎();

    // 初始化工厂
    this.冠军工厂 = new 冠军工厂(this.属性注册表);
    this.母畜工厂 = new 母畜工厂(this.属性注册表);

    // 初始化系统（延迟到配置加载后）
    this.时间系统 = null;
    this.资源系统 = null;
    this.任务系统 = null;
    this.情报系统 = null;
    this.战斗系统 = null;
    this.繁殖系统 = null;
    this.法术系统 = null;
    this.黑市系统 = null;

    this.已初始化 = false;
  }

  async 初始化(配置来源 = null) {
    // 加载配置（如果提供）
    if (配置来源) {
      await this.加载游戏配置(配置来源);
    }

    // 初始化系统
    this.时间系统 = new 时间系统(this.事件总线);
    this.资源系统 = new 资源系统(this.事件总线);
    this.情报系统 = new 情报系统(this.事件总线, this.公式引擎);
    this.战斗系统 = new 战斗系统(this.事件总线, this.公式引擎, this.情报系统);
    this.繁殖系统 = new 繁殖系统(this.事件总线, this.冠军工厂, this.游戏状态.喽啰池, this.属性注册表);


    this.任务系统 = new 任务系统(this.事件总线, this.任务注册表, this.时间系统, this.公式引擎);

    // 注册默认周结算处理器
    this.时间系统.注册周结算处理器((状态, 周次) => {
      return this.资源系统.周结算处理(状态);
    });

    this.时间系统.注册周结算处理器(状态 => {
      // 士气自然衰减
      状态.修改士气(-5);
      return { 类型: '士气衰减', 数值: -5 };
    });

    // 注册默认资源类型
    this.资源系统.注册资源类型('母乳', 0);

    // 注册母乳产出规则
    this.资源系统.注册产出规则('母乳', 状态 => {
      let 总产出 = 0;
      状态.获取所有泌乳状态母畜().forEach(母畜 => {
        总产出 += 母畜.计算泌乳产量();
      });
      return 总产出;
    });


    this.已初始化 = true;
    this.事件总线.发布('游戏初始化完成');
  }

  async 加载游戏配置(来源) {
    // 根据来源类型加载配置
    // 实际实现取决于配置格式和来源类型
  }

  初始化法术系统() {
    if (!this.游戏状态.领主) {
      throw new Error('请先设置领主');
    }
    this.法术系统 = new 法术系统(this.事件总线, this.法术注册表, this.游戏状态.领主);
  }

  初始化黑市系统() {
    this.黑市系统 = new 黑市系统(this.事件总线, this.商品注册表, this.资源系统);
  }

  // 游戏操作接口
  执行任务(任务名, 负责人ID, 额外参数 = {}) {
    if (!this.已初始化) throw new Error('游戏未初始化');

    // 查找负责人
    let 负责人 = this.游戏状态.获取冠军(负责人ID);
    if (!负责人) {
      负责人 = this.游戏状态.获取母畜(负责人ID);
    }
    if (!负责人) {
      return { 成功: false, 原因: '找不到指定负责人' };
    }

    // 扩展额外参数，传入系统引用
    const 扩展参数 = {
      ...额外参数,
      繁殖系统: this.繁殖系统, // TODO: 新增
      属性注册表: this.属性注册表, // TODO: 新增
      情报系统: this.情报系统, // TODO: 新增
    };

    return this.任务系统.执行任务(任务名, 负责人, this.游戏状态, 扩展参数);

  }

  结束当前周() {
    if (!this.已初始化) throw new Error('游戏未初始化');
    return this.时间系统.结束当前周(this.游戏状态);
  }

  施放法术(法术名, 目标ID = null) {
    if (!this.法术系统) throw new Error('法术系统未初始化');

    let 目标 = null;
    if (目标ID) {
      目标 = this.游戏状态.获取母畜(目标ID) ?? this.游戏状态.获取冠军(目标ID);
    }

    return this.法术系统.施放法术(法术名, 目标);
  }

  购买商品(商品名, 数量 = 1) {
    if (!this.黑市系统) throw new Error('黑市系统未初始化');
    return this.黑市系统.购买商品(商品名, 数量);
  }

  // 状态查询接口
  获取游戏概览() {
    return {
      当前周次: this.时间系统?.当前周次 ?? 0,
      剩余行动点: this.时间系统?.剩余行动点 ?? 0,
      冠军数量: this.游戏状态.冠军列表.length,
      母畜数量: this.游戏状态.母畜列表.length,
      喽啰总数: this.游戏状态.喽啰池.获取总数量(),
      军队士气: this.游戏状态.军队状态.士气,
      魔力: this.游戏状态.领主?.获取属性('魔力') ?? 0,
      母乳: this.资源系统?.获取资源('母乳') ?? 0,
    };
  }

  获取游戏详情() {
    return {
      当前周次: this.时间系统?.当前周次 ?? 0,
      剩余行动点: this.时间系统?.剩余行动点 ?? 0,
      冠军列表: this.游戏状态.冠军列表 ?? [],
      母畜列表: this.游戏状态.母畜列表 ?? [],
      喽啰池: this.游戏状态.喽啰池 ?? [],
      军队状态: this.游戏状态.军队状态 ?? [],
      领主: this.游戏状态.领主 ?? null,
      商品列表: this.商品注册表.商品列表 ?? [],
      法术列表: this.法术注册表.法术列表 ?? [],
      资源系统: this.资源系统 ?? [],
    };
  }

  // 存档接口
  导出存档() {
    return {
      版本: '1.0.0',
      时间戳: Date.now(),
      游戏状态: this.游戏状态.序列化(),
      时间数据: {
        当前周次: this.时间系统.当前周次,
        剩余行动点: this.时间系统.剩余行动点,
      },
      资源数据: Object.fromEntries(this.资源系统.资源映射),
      情报数据: this.导出情报数据(),
      黑市数据: this.黑市系统
        ? {
            本周购买记录: Object.fromEntries(this.黑市系统.本周购买记录),
          }
        : null,
    };
  }

  导出情报数据() {
    const 情报快照 = {};
    this.情报系统.目标情报.forEach((数据, 目标ID) => {
      情报快照[目标ID] = {
        情报进度: 数据.情报进度,
        已锁定目标: Array.from(数据.已锁定目标),
        高价值目标列表: 数据.高价值目标列表,
        战力估值: 数据.战力估值,
        最后侦察周次: 数据.最后侦察周次,
      };
    });
    return 情报快照;
  }

  async 导入存档(存档数据) {
    if (!存档数据?.版本) {
      throw new Error('无效的存档数据');
    }

    // 版本兼容性检查
    const 存档版本 = 存档数据.版本.split('.').map(Number);
    // 可扩展的版本迁移逻辑

    // 恢复游戏状态
    await this.恢复游戏状态(存档数据.游戏状态);

    // 恢复时间数据
    this.时间系统.当前周次 = 存档数据.时间数据.当前周次;
    this.时间系统.剩余行动点 = 存档数据.时间数据.剩余行动点;

    // 恢复资源数据
    Object.entries(存档数据.资源数据).forEach(([资源名, 数量]) => {
      this.资源系统.资源映射.set(资源名, 数量);
    });

    // 恢复情报数据
    this.恢复情报数据(存档数据.情报数据);

    // 恢复黑市数据
    if (存档数据.黑市数据 && this.黑市系统) {
      Object.entries(存档数据.黑市数据.本周购买记录).forEach(([商品名, 数量]) => {
        this.黑市系统.本周购买记录.set(商品名, 数量);
      });
    }

    this.事件总线.发布('存档加载完成', { 版本: 存档数据.版本 });
  }

  async 恢复游戏状态(状态数据) {
    // 恢复领主
    if (状态数据.领主) {
      this.游戏状态.领主 = new 领主实体();
      Object.entries(状态数据.领主.属性).forEach(([k, v]) => {
        this.游戏状态.领主.设置属性(k, v);
      });
      状态数据.领主.标签?.forEach(t => this.游戏状态.领主.添加标签(t));
      this.游戏状态.领主.实体ID = 状态数据.领主.实体ID;
      this.游戏状态.领主.元数据 = 状态数据.领主.元数据;

      // 重新初始化法术系统
      this.初始化法术系统();
    }

    // 恢复冠军列表
    this.游戏状态.冠军列表 = 状态数据.冠军列表.map(冠军数据 => {
      const 冠军 = new 冠军实体();
      Object.entries(冠军数据.属性).forEach(([k, v]) => 冠军.设置属性(k, v));
      冠军数据.标签?.forEach(t => 冠军.添加标签(t));
      冠军.实体ID = 冠军数据.实体ID;
      冠军.元数据 = 冠军数据.元数据;
      return 冠军;
    });

    // 恢复母畜列表
    this.游戏状态.母畜列表 = 状态数据.母畜列表.map(母畜数据 => {
      const 母畜 = new 母畜实体();
      Object.entries(母畜数据.属性).forEach(([k, v]) => 母畜.设置属性(k, v));
      母畜数据.标签?.forEach(t => 母畜.添加标签(t));
      母畜.实体ID = 母畜数据.实体ID;
      母畜.元数据 = 母畜数据.元数据;
      return 母畜;
    });

    // 恢复喽啰池
    this.游戏状态.喽啰池.武装分组.clear();
    状态数据.喽啰池.分组.forEach(([等级, 数据]) => {
      this.游戏状态.喽啰池.武装分组.set(等级, { ...数据 });
    });

    // 恢复军队状态
    Object.assign(this.游戏状态.军队状态, 状态数据.军队状态);

    // 恢复全局变量
    this.游戏状态.全局变量.clear();
    Object.entries(状态数据.全局变量).forEach(([k, v]) => {
      this.游戏状态.全局变量.set(k, v);
    });
  }

  恢复情报数据(情报快照) {
    this.情报系统.目标情报.clear();
    Object.entries(情报快照).forEach(([目标ID, 数据]) => {
      this.情报系统.目标情报.set(目标ID, {
        情报进度: 数据.情报进度,
        已锁定目标: new Set(数据.已锁定目标),
        高价值目标列表: 数据.高价值目标列表,
        战力估值: 数据.战力估值,
        最后侦察周次: 数据.最后侦察周次,
      });
    });
  }
}

// ═══════════════════════════════════════════════════════════════
// 配置初始化示例 - 展示如何使用框架
// ═══════════════════════════════════════════════════════════════

/**
 * 默认配置初始化器
 * 注册游戏所需的各类定义
 */
class 默认配置初始化器 {
  constructor(游戏控制器) {
    this.控制器 = 游戏控制器;
  }

  初始化所有配置() {
    this.初始化属性定义();
    this.初始化任务定义();
    this.初始化法术定义();
    this.初始化商品定义();
    this.初始化公式();
    this.初始化工厂配置();
    this.注册事件监听器(this.控制器);
  }

  初始化属性定义() {
    const 注册表 = this.控制器.属性注册表;

    // 臣服度属性
    注册表.注册属性类型('臣服度', {
      默认值: 0,
      最小值: 0,
      最大值: 100,
      阶段定义: [
        { 名称: '抗拒期', 下限: 0, 上限: 24, 描述: '敌对、逃跑风险高' },
        { 名称: '动摇期', 下限: 25, 上限: 49, 描述: '意志松动、开始服从' },
        { 名称: '顺从期', 下限: 50, 上限: 74, 描述: '接受现状、主动配合' },
        { 名称: '归心期', 下限: 75, 上限: 89, 描述: '认同部落' },
        { 名称: '忠诚期', 下限: 90, 上限: 100, 描述: '彻底归化' },
      ],
    });

    // 淫乱度属性
    注册表.注册属性类型('淫乱度', {
      默认值: 0,
      最小值: 0,
      最大值: 100,
      阶段定义: [
        { 名称: '常态期', 下限: 0, 上限: 24, 描述: '正常抵抗' },
        { 名称: '泌乳期', 下限: 25, 上限: 49, 描述: '可诱导泌乳', 解锁: ['泌乳产出'] },
        { 名称: '渴求期', 下限: 50, 上限: 74, 描述: '持续处于饥渴状态' },
        { 名称: '淫堕期', 下限: 75, 上限: 99, 描述: '本能支配理智' },
        { 名称: '完全淫堕', 下限: 100, 上限: 100, 描述: '本能支配理智', 解锁: ['献祭转化'] },
      ],
    });

    // 士气属性
    注册表.注册属性类型('士气', {
      默认值: 50,
      最小值: 0,
      最大值: 100,
      衰减配置: { 周期: '周', 衰减量: 5 },
    });
  }

  初始化任务定义() {
    const 注册表 = this.控制器.任务注册表;

    // 调教任务
    注册表.注册任务类型('调教', {
      行动点消耗: 1,
      负责人类型: ['冠军'],
      效率属性: ['智力'],
      产出类型: ['臣服度'],
      副作用: [],
    });

    注册表.注册任务执行器('调教', 上下文 => {
      const { 负责人, 游戏状态, 目标ID } = 上下文;
      const 目标母畜 = 游戏状态.获取母畜(目标ID);
      if (!目标母畜) return { 成功: false, 原因: '目标不存在' };

      const 智力 = 负责人.获取属性('智力');
      const 臣服度增加 = 5 * (智力 / 25) + 5;

      目标母畜.修改属性('臣服度', 臣服度增加, 上下文.属性注册表);

      return {
        成功: true,
        效果: { 臣服度增加 },
        目标ID: 目标母畜.实体ID,
      };
    });

    // 劝慰任务
    注册表.注册任务类型('劝慰', {
      行动点消耗: 1,
      负责人类型: ['母畜'],
      负责人条件: 上下文 => 上下文.负责人.获取属性('臣服度') >= 75,
      产出类型: ['臣服度'],
    });

    注册表.注册任务执行器('劝慰', 上下文 => {
      const { 负责人, 游戏状态, 额外参数 } = 上下文;
      const 目标母畜 = 游戏状态.获取母畜(额外参数.目标ID);
      if (!目标母畜) return { 成功: false, 原因: '目标不存在' };

      let 臣服度增加 = 10;

      // 同种族加成
      if (负责人.获取属性('种族') === 目标母畜.获取属性('种族')) {
        臣服度增加 *= 1.5;
      }

      目标母畜.修改属性('臣服度', 臣服度增加);

      return {
        成功: true,
        效果: { 臣服度增加 },
        目标ID: 目标母畜.实体ID,
      };
    });

    // 提振士气任务
    注册表.注册任务类型('提振士气', {
      行动点消耗: 1,
      负责人类型: ['母畜'],
      负责人条件: 上下文 => 上下文.负责人.获取属性('臣服度') >= 75,
      产出类型: ['士气'],
      副作用: [
        上下文 => {
          上下文.负责人.修改属性('淫乱度', 5);
        },
      ],
    });

    注册表.注册任务执行器('提振士气', 上下文 => {
      const { 负责人, 游戏状态 } = 上下文;

      const 淫乱度 = 负责人.获取属性('淫乱度');
      const 总雌性价值 = 负责人.获取属性('总雌性价值');

      const 士气提升 = 15 * (淫乱度 / 50) * (总雌性价值 / 200);
      游戏状态.修改士气(士气提升);

      return {
        成功: true,
        效果: { 士气提升 },
      };
    });

    // 潜入侦察任务
    注册表.注册任务类型('潜入侦察', {
      行动点消耗: 1,
      负责人类型: ['母畜'],
      负责人条件: 上下文 => 上下文.负责人.获取属性('臣服度') >= 90,
      产出类型: ['情报'],
    });

    注册表.注册任务执行器('潜入侦察', 上下文 => {
      const { 负责人, 额外参数, 公式引擎 } = 上下文;
      const 目标ID = 额外参数.目标ID;

      const 臣服度 = 负责人.获取属性('臣服度');
      const 淫乱度 = 负责人.获取属性('淫乱度');

      // 效率公式: 1 × (臣服度 ÷ 50) × (1 - 淫乱度 ÷ 200)
      const 效率 = 1 * (臣服度 / 50) * (1 - 淫乱度 / 200);
      const 情报增量 = Math.floor(效率 * 20); // 基础20点情报

      // 暴露风险判定
      const 暴露概率 = 淫乱度 / 200;
      const 是否暴露 = Math.random() < 暴露概率;

      if (是否暴露) {
        return {
          成功: false,
          暴露: true,
          负责人ID: 负责人.实体ID,
        };
      }

      上下文.事件总线.发布('请求情报更新', { 目标ID, 增量: 情报增量 });

      return {
        成功: true,
        效果: { 情报增量 },
        目标ID,
      };
    });

    // 直接侦察任务
    注册表.注册任务类型('直接侦察', {
      行动点消耗: 1,
      负责人类型: ['冠军'],
      效率属性: ['敏捷'],
      产出类型: ['情报'],
    });

    注册表.注册任务执行器('直接侦察', 上下文 => {
      const { 负责人, 额外参数 } = 上下文;
      const 目标ID = 额外参数.目标ID;

      const 敏捷 = 负责人.获取属性('敏捷');
      const 效率 = 1 * (敏捷 / 25);
      const 情报增量 = Math.floor(效率 * 15);

      // 遭遇战风险
      const 遭遇战概率 = 0.1;
      const 发生遭遇战 = Math.random() < 遭遇战概率;

      上下文.事件总线.发布('请求情报更新', { 目标ID, 增量: 情报增量 });

      return {
        成功: true,
        效果: { 情报增量 },
        目标ID,
        遭遇战: 发生遭遇战,
      };
    });

    // 生育冠军任务
    注册表.注册任务类型('生育冠军', {
      行动点消耗: 1, // 臣服度25+时为1，否则为2
      负责人类型: ['母畜'],
      负责人条件: 上下文 => 上下文.负责人.获取属性('剩余雌性价值') >= 100,
      产出类型: ['冠军'],
    });

    // 生育喽啰任务
    注册表.注册任务类型('生育喽啰', {
      行动点消耗: 0, // 臣服度25+时为0，否则为1
      负责人类型: ['母畜'],
      负责人条件: 上下文 => 上下文.负责人.获取属性('剩余雌性价值') > 0,
      产出类型: ['喽啰'],
    });

    // 潜入劝诱任务
    注册表.注册任务类型('潜入劝诱', {
      行动点消耗: 1,
      负责人类型: ['母畜'],
      负责人条件: 上下文 => 上下文.负责人.获取属性('臣服度') >= 90,
      产出类型: ['母畜'],
    });

    注册表.注册任务执行器('潜入劝诱', 上下文 => {
      const { 负责人, 额外参数 } = 上下文;

      const 负责人价值 = 负责人.获取属性('总雌性价值');
      const 目标价值 = 额外参数.目标价值 ?? 100;

      const 成功率 = 负责人价值 / 目标价值 / 2.5;
      const 是否成功 = Math.random() < 成功率;

      if (!是否成功) {
        // 失败可能暴露
        const 暴露概率 = 0.3;
        const 是否暴露 = Math.random() < 暴露概率;

        return {
          成功: false,
          暴露: 是否暴露,
          负责人ID: 负责人.实体ID,
        };
      }

      return {
        成功: true,
        需创建母畜: true,
        初始臣服度: 20,
        目标配置: 额外参数.目标配置,
      };
    });

    // 泌乳任务（被动）
    注册表.注册任务类型('泌乳', {
      行动点消耗: 0,
      负责人类型: ['母畜'],
      负责人条件: 上下文 => 上下文.负责人.获取属性('淫乱度') >= 25,
      产出类型: ['母乳'],
      副作用: [
        上下文 => {
          上下文.负责人.修改属性('淫乱度', 3);
        },
      ],
    });
  }

  初始化法术定义() {
    const 注册表 = this.控制器.法术注册表;

    // 催化调教
    注册表.注册法术('催化调教', {
      魔力消耗: 1,
      目标类型: '无',
      效果描述: '单次调教效率翻倍',
      效果参数: { 调教倍率: 2 },
    });

    // 魔眼侦察
    注册表.注册法术('魔眼侦察', {
      魔力消耗: 1,
      目标类型: '无',
      效果描述: '立刻提高侦察进度',
      效果参数: { 情报增量: 30 },
    });

    // 战嚎祝福
    注册表.注册法术('战嚎祝福', {
      魔力消耗: 3,
      目标类型: '无',
      效果描述: '单次战斗军队战力+30%',
      效果参数: { 战力加成: 0.3 },
    });

    // 意志粉碎
    注册表.注册法术('意志粉碎', {
      魔力消耗: 3,
      目标类型: '母畜',
      效果描述: '目标母畜臣服度直接+50',
    });

    注册表.注册效果处理器('意志粉碎', (目标, 上下文) => {
      目标.修改属性('臣服度', 50);
      return { 臣服度增加: 50 };
    });

    // 淫堕催化
    注册表.注册法术('淫堕催化', {
      魔力消耗: 3,
      目标类型: '母畜',
      效果描述: '目标母畜淫乱度直接+50',
    });

    注册表.注册效果处理器('淫堕催化', (目标, 上下文) => {
      目标.修改属性('淫乱度', 50);
      return { 淫乱度增加: 50 };
    });

    // 孕力回复
    注册表.注册法术('孕力回复', {
      魔力消耗: 5,
      目标类型: '母畜',
      效果描述: '目标母畜剩余生育价值+100',
    });

    注册表.注册效果处理器('孕力回复', (目标, 上下文) => {
      const 当前剩余 = 目标.获取属性('剩余雌性价值');
      const 总价值 = 目标.获取属性('总雌性价值');
      const 新值 = Math.min(当前剩余 + 100, 总价值);
      目标.设置属性('剩余雌性价值', 新值);
      return { 实际恢复: 新值 - 当前剩余 };
    });
  }

  初始化商品定义() {
    const 注册表 = this.控制器.商品注册表;

    // 注册商品分类
    注册表.注册商品分类('武装装备', { 刷新周期: 1, 随机刷新: false });
    注册表.注册商品分类('奴隶商品', { 刷新周期: 1, 随机刷新: true });
    注册表.注册商品分类('特殊资源', { 刷新周期: 1, 随机刷新: false });

    // 武装装备
    注册表.注册商品('破旧兵刃与皮甲残片', {
      分类: '武装装备',
      价格: 1,
      每周限购: Infinity,
      效果: { 类型: '武装升级', 等级: '低级', 战斗力提升: 10, 每母乳数量: 10 },
    });

    注册表.注册商品('标准铁剑与链甲套件', {
      分类: '武装装备',
      价格: 1,
      每周限购: Infinity,
      效果: { 类型: '武装升级', 等级: '中级', 战斗力提升: 20, 每母乳数量: 4 },
    });

    注册表.注册商品('盗取的骑士全装', {
      分类: '武装装备',
      价格: 1,
      每周限购: Infinity,
      效果: { 类型: '武装升级', 等级: '高级', 战斗力提升: 50, 每母乳数量: 1 },
    });

    // 特殊资源
    注册表.注册商品('神殿祝福水晶', {
      分类: '特殊资源',
      价格: 25,
      每周限购: 3,
      效果: {
        类型: '祝福水晶',
        公式: 淫乱度 => Math.floor(2000 / (淫乱度 + 20)),
      },
    });

    注册表.注册商品('神殿净化水晶', {
      分类: '特殊资源',
      价格: 15,
      每周限购: 3,
      效果: { 类型: '净化水晶', 淫乱度减少: 10 },
    });

    // 奴隶商品刷新规则
    注册表.注册刷新规则('奴隶商品', 周次 => {
      const 商品列表 = [];

      // 低质奴隶（常驻）
      商品列表.push({
        名称: '债务抵押的农家女',
        分类: '奴隶商品',
        价格: 5,
        每周限购: 3,
        效果: {
          类型: '获得母畜',
          总雌性价值范围: [80, 120],
          初始臣服度: 10,
          原身份: '普通人',
        },
      });

      // 中质奴隶（常驻）
      商品列表.push({
        名称: '破落商人之女',
        分类: '奴隶商品',
        价格: 15,
        每周限购: 2,
        效果: {
          类型: '获得母畜',
          总雌性价值范围: [150, 200],
          初始臣服度: 5,
          原身份: '商人之女',
        },
      });

      // 特殊奴隶（每4周随机刷新0-1名）
      if (周次 % 4 === 0 && Math.random() < 0.5) {
        const 特殊奴隶池 = [
          {
            名称: '被除名的女见习法师',
            价格: 40,
            效果: {
              类型: '获得母畜',
              总雌性价值: 280,
              初始臣服度: 0,
              原身份: '法师',
              特殊标签: ['法师血脉'],
            },
          },
          {
            名称: '流亡小国的没落公主',
            价格: 80,
            效果: {
              类型: '获得母畜',
              总雌性价值: 350,
              初始臣服度: 0,
              原身份: '贵族',
              特殊标签: ['贵族血脉'],
            },
          },
        ];

        const 随机特殊 = 特殊奴隶池[Math.floor(Math.random() * 特殊奴隶池.length)];
        商品列表.push({
          ...随机特殊,
          分类: '奴隶商品',
          每周限购: 1,
        });
      }

      return 商品列表;
    });
  }

  初始化公式() {
    const 引擎 = this.控制器.公式引擎;

    // 士气系数公式
    引擎.注册公式('士气系数', ({ 士气 }) => {
      return Math.pow(1.1, (士气 + 20) / 10 - 10);
    });

    // 部曲战力公式
    引擎.注册公式('部曲战力', ({ 有效喽啰数, 冠军力量, 战斗力, 士气 }) => {
      const 士气系数 = Math.pow(1.1, (士气 + 20) / 10 - 10);
      return (有效喽啰数 + Math.floor(冠军力量 / 20)) * (战斗力 / 100) * 士气系数;
    });

    // 情报战力估值偏差公式
    引擎.注册公式('战力估值偏差', ({ 情报进度 }) => {
      const n = 情报进度;
      return {
        下限系数: 0.2 + (8 * n) / 1000,
        上限系数: 5 - (4 * n) / 100,
      };
    });

    // 潜入侦察效率公式
    引擎.注册公式('潜入侦察效率', ({ 臣服度, 淫乱度 }) => {
      return 1 * (臣服度 / 50) * (1 - 淫乱度 / 200);
    });

    // 直接侦察效率公式
    引擎.注册公式('直接侦察效率', ({ 敏捷 }) => {
      return 1 * (敏捷 / 25);
    });

    // 调教效率公式
    引擎.注册公式('调教效率', ({ 智力 }) => {
      return 5 * (智力 / 25) + 5;
    });

    // 提振士气效率公式
    引擎.注册公式('提振士气效率', ({ 淫乱度, 总雌性价值 }) => {
      return 15 * (淫乱度 / 50) * (总雌性价值 / 200);
    });

    // 泌乳产量公式
    引擎.注册公式('泌乳产量', ({ 淫乱度 }) => {
      return Math.floor((淫乱度 + 45) / 20);
    });

    // 祝福水晶效果公式
    引擎.注册公式('祝福水晶效果', ({ 淫乱度 }) => {
      return Math.floor(2000 / (淫乱度 + 20));
    });

    // 冠军属性生成公式
    引擎.注册公式('冠军属性生成', ({ 总雌性价值, 效率系数, 随机浮动 }) => {
      const 基础值 = 总雌性价值 / 10;
      return Math.round((基础值 + 随机浮动) * 效率系数);
    });

    // 锁定目标公式
    引擎.注册公式('锁定目标值', ({ 负责人系数, 情报进度 }) => {
      return (负责人系数 * (情报进度 + 25)) / 100;
    });

    // 潜入劝诱成功率公式
    引擎.注册公式('潜入劝诱成功率', ({ 负责人价值, 目标价值 }) => {
      return 负责人价值 / 目标价值 / 2.5;
    });
  }

  初始化工厂配置() {
    // 配置冠军工厂的效率系数
    const 冠军工厂 = this.控制器.冠军工厂;

    冠军工厂.注册效率系数('女骑士', { 力量: 1.3, 敏捷: 1.0, 智力: 0.8 });
    冠军工厂.注册效率系数('战士', { 力量: 1.3, 敏捷: 1.0, 智力: 0.8 });
    冠军工厂.注册效率系数('盗贼', { 力量: 0.9, 敏捷: 1.3, 智力: 0.9 });
    冠军工厂.注册效率系数('游侠', { 力量: 0.9, 敏捷: 1.3, 智力: 0.9 });
    冠军工厂.注册效率系数('法师', { 力量: 0.7, 敏捷: 0.9, 智力: 1.4 });
    冠军工厂.注册效率系数('学者', { 力量: 0.7, 敏捷: 0.9, 智力: 1.4 });
    冠军工厂.注册效率系数('贵族', { 力量: 1.0, 敏捷: 1.0, 智力: 1.1 });
    冠军工厂.注册效率系数('圣女', { 力量: 1.0, 敏捷: 1.0, 智力: 1.1 });
    冠军工厂.注册效率系数('普通人', { 力量: 1.0, 敏捷: 1.0, 智力: 1.0 });
    冠军工厂.注册效率系数('精灵', { 力量: 0.9, 敏捷: 1.1, 智力: 1.2 });

    // 配置母畜工厂的身份价值
    const 母畜工厂 = this.控制器.母畜工厂;

    母畜工厂.注册身份价值('圣女', { 最小: 450, 最大: 550 });
    母畜工厂.注册身份价值('公主', { 最小: 450, 最大: 550 });
    母畜工厂.注册身份价值('女骑士', { 最小: 350, 最大: 450 });
    母畜工厂.注册身份价值('高阶法师', { 最小: 350, 最大: 450 });
    母畜工厂.注册身份价值('大贵族', { 最小: 350, 最大: 450 });
    母畜工厂.注册身份价值('城主之女', { 最小: 200, 最大: 300 });
    母畜工厂.注册身份价值('低阶冒险者', { 最小: 200, 最大: 300 });
    母畜工厂.注册身份价值('商人之女', { 最小: 150, 最大: 200 });
    母畜工厂.注册身份价值('普通人', { 最小: 80, 最大: 120 });
  }


  注册事件监听器(游戏控制器) {
    const { 事件总线, 游戏状态, 资源系统, 情报系统, 繁殖系统, 黑市系统 } = 游戏控制器;

    // ─── 资源相关事件 ───
    事件总线.订阅('资源变更', (事件) => {
      // {处理资源变更后的连锁效果，如资源不足警告}
    });

    事件总线.订阅('母乳产出', (事件) => {
      // {记录母乳产出详情，触发相关成就检查}
    });

    // ─── 母畜相关事件 ───
    事件总线.订阅('属性变更', (事件) => {
      const { 实体, 属性名, 旧值, 新值 } = 事件.数据;

      if (属性名 === '臣服度') {
        // {检查臣服度阶段变化，触发阶段性事件}
      }

      if (属性名 === '淫乱度') {
        // {检查淫乱度阶段变化，解锁新能力}
      }

      if (属性名 === '剩余雌性价值') {
        // {检查雌性价值耗尽，标记母畜状态}
      }
    });

    事件总线.订阅('标签添加', (事件) => {
      // {处理状态标签变化的连锁效果}
    });

    事件总线.订阅('标签移除', (事件) => {
      // {处理状态标签移除的连锁效果}
    });

    // ─── 冠军相关事件 ───
    事件总线.订阅('冠军诞生', (事件) => {
      const { 冠军, 母畜ID } = 事件.数据;
      // {记录冠军血脉信息，更新母畜生育记录}
    });

    事件总线.订阅('冠军成长', (事件) => {
      // {处理冠军属性成长事件}
    });

    事件总线.订阅('冠军阵亡', (事件) => {
      // {处理冠军死亡，检查是否触发特殊事件}
    });

    // ─── 喽啰相关事件 ───
    事件总线.订阅('喽啰诞生', (事件) => {
      const { 数量, 母畜ID } = 事件.数据;
      // {更新喽啰总数统计}
    });

    事件总线.订阅('喽啰损失', (事件) => {
      // {处理喽啰损失，检查军队状态}
    });

    事件总线.订阅('武装升级完成', (事件) => {
      // {更新军队战力估算}
    });

    // ─── 情报相关事件 ───
    事件总线.订阅('请求情报更新', (事件) => {
      const { 目标ID, 增量 } = 事件.数据;
      if (情报系统) {
        情报系统.增加情报进度(目标ID, 增量);
      }
    });

    事件总线.订阅('情报更新', (事件) => {
      // {检查情报进度里程碑，解锁新信息}
    });

    事件总线.订阅('目标锁定', (事件) => {
      // {记录锁定的高价值目标}
    });

    // ─── 战斗相关事件 ───
    事件总线.订阅('战斗开始', (事件) => {
      // {记录战斗日志，应用战前buff}
    });

    事件总线.订阅('战斗结束', (事件) => {
      const { 结果类型, 喽啰损失, 战利品, 士气变化 } = 事件.数据;

      // {处理战斗结果，更新军队状态}
      // {处理俘获的目标，创建新母畜}
      // {应用士气变化}
    });

    事件总线.订阅('遭遇战发生', (事件) => {
      // {处理侦察时的遭遇战}
    });

    // ─── 任务相关事件 ───
    事件总线.订阅('任务完成', (事件) => {
      const { 任务名, 负责人ID, 结果 } = 事件.数据;
      // {记录任务完成统计，检查成就}
    });

    事件总线.订阅('任务失败', (事件) => {
      // {处理任务失败后果}
    });

    事件总线.订阅('负责人暴露', (事件) => {
      // {处理潜入任务暴露，可能导致母畜损失}
    });

    // ─── 繁殖相关事件 ───
    事件总线.订阅('繁殖周期开始', (事件) => {
      // {标记参与繁殖的母畜状态}
    });

    事件总线.订阅('繁殖周期结束', (事件) => {
      // {处理繁殖产出}
    });

    // ─── 法术相关事件 ───
    事件总线.订阅('法术施放', (事件) => {
      const { 法术名, 目标ID, 效果结果 } = 事件.数据;
      // {记录法术使用，应用法术效果}
    });

    事件总线.订阅('魔力变更', (事件) => {
      // {检查魔力阈值，触发相关事件}
    });

    事件总线.订阅('母畜献祭', (事件) => {
      const { 母畜ID, 魔力获得 } = 事件.数据;
      // {从母畜列表中移除，记录献祭历史}
    });

    // ─── 黑市相关事件 ───
    事件总线.订阅('黑市刷新', (事件) => {
      // {通知可用商品更新}
    });

    事件总线.订阅('商品购买', (事件) => {
      const { 商品名, 数量, 效果 } = 事件.数据;
      // {应用商品效果}

      if (效果.类型 === '武装升级') {
        // {执行喽啰武装升级}
      }

      if (效果.类型 === '获得母畜') {
        // {创建新母畜并添加到游戏状态}
      }

      if (效果.类型 === '祝福水晶') {
        // {计算并应用雌性价值恢复}
      }

      if (效果.类型 === '净化水晶') {
        // {降低目标母畜淫乱度}
      }
    });

    // ─── 时间相关事件 ───
    事件总线.订阅('行动点消耗', (事件) => {
      // {记录行动点使用}
    });

    事件总线.订阅('周结算完成', (事件) => {
      const { 周次, 结算结果 } = 事件.数据;
      // {生成周结算报告}
      // {触发周结算随机事件}
    });

    事件总线.订阅('新周开始', (事件) => {
      const { 周次, 行动点 } = 事件.数据;
      // {重置周相关状态}
      // {刷新黑市}
      if (黑市系统) {
        黑市系统.刷新商品(周次);
      }
      // {触发新周事件}
    });

    // ─── 游戏状态事件 ───
    事件总线.订阅('游戏初始化完成', (事件) => {
      // {执行初始化后的设置}
    });

    事件总线.订阅('存档加载完成', (事件) => {
      // {验证存档完整性，恢复运行时状态}
    });

    事件总线.订阅('游戏胜利', (事件) => {
      // {处理游戏胜利结算}
    });

    事件总线.订阅('游戏失败', (事件) => {
      // {处理游戏失败结算}
    });

    // ─── 调试/日志事件 ───
    事件总线.订阅('*', (事件) => {
      // {可选：记录所有事件到日志系统}
      // console.log(`[事件] ${事件.名称}:`, 事件.数据);
    }, -1000); // 最低优先级，最后执行

    return 事件总线;
  }


  处理商品效果(效果, 数量) {
    switch (效果.类型) {
      case '武装升级':
        // TODO: 实现武装升级逻辑
        const 可升级数量 = 效果.每母乳数量 * 数量;
        this.游戏状态.喽啰池.注册武装等级(效果.等级, 效果.战斗力提升 + 100);
        // 需要额外实现从未武装升级到目标等级的逻辑
        break;

      case '获得母畜':
        for (let i = 0; i < 数量; i++) {
          const 价值范围 = 效果.总雌性价值范围;
          const 总雌性价值 =
            效果.总雌性价值 ??
            (价值范围 ? Math.floor(Math.random() * (价值范围[1] - 价值范围[0] + 1)) + 价值范围[0] : 100);

          const 新母畜 = this.母畜工厂.创建母畜({
            原身份: 效果.原身份,
            总雌性价值,
            臣服度: 效果.初始臣服度 ?? 0,
            特殊标签: 效果.特殊标签,
          });
          this.游戏状态.添加母畜(新母畜);
        }
        break;

      case '祝福水晶':
        // TODO: 需要指定目标母畜
        // 效果为：Math.floor(2000 / (目标淫乱度 + 20)) 点雌性价值恢复
        break;

      case '净化水晶':
        // TODO: 需要指定目标母畜
        // 效果为：淫乱度减少10
        break;

      default:
        console.warn(`[商品] 未知效果类型: ${效果.类型}`);
    }
  }
}

// ═══════════════════════════════════════════════════════════════
// 使用示例
// ═══════════════════════════════════════════════════════════════

/**
 * 初始化游戏示例
 */
async function 创建新游戏() {
  // 创建游戏控制器
  const 游戏 = new 游戏主控制器();

  // 初始化游戏
  await 游戏.初始化();

  // 应用默认配置
  const 配置器 = new 默认配置初始化器(游戏);
  配置器.初始化所有配置();

  // 创建初始实体
  const 领主 = new 领主实体({ 魔力: 0 });
  游戏.游戏状态.设置领主(领主);
  游戏.初始化法术系统();

  // 创建初始冠军
  const 初始冠军 = new 冠军实体({
    姓名: '忠诚的初始伙伴',
    力量: 15,
    敏捷: 12,
    智力: 10,
  });
  游戏.游戏状态.添加冠军(初始冠军);

  // 创建初始母畜
  const 初始母畜 = 游戏.母畜工厂.创建母畜({
    姓名: '玛丽',
    原身份: '普通人',
    总雌性价值: 1000,
    臣服度: 100,
    淫乱度: 100,
  });
  初始母畜.添加标签('繁殖状态');
  游戏.游戏状态.添加母畜(初始母畜);

  // 初始喽啰
  游戏.游戏状态.喽啰池.增加喽啰(20);

  // 初始化黑市
  游戏.初始化黑市系统();
  游戏.黑市系统.刷新商品(1);

  return 游戏;
}

/**
 * 游戏流程示例
 */
async function 游戏流程演示() {
  const 游戏 = await 创建新游戏();

  console.log('=== 游戏初始状态 ===');
  console.log(游戏.获取游戏概览());

  // 获取冠军和母畜ID
  const 冠军ID = 游戏.游戏状态.冠军列表[0].实体ID;
  console.log(`冠军ID: ${冠军ID}`);
  const 母畜ID = 游戏.游戏状态.母畜列表[0].实体ID;
  console.log(`母畜ID: ${母畜ID}`);

  // 执行调教任务
  console.log('\n=== 执行调教任务 ===');
  const 调教结果 = 游戏.执行任务('调教', 冠军ID, { 目标ID: 母畜ID });
  console.log(调教结果);

  // 查看母畜状态变化
  const 母畜 = 游戏.游戏状态.获取母畜(母畜ID);
  console.log(`母畜臣服度: ${母畜.获取属性('臣服度')}`);

  // 结束当前周
  console.log('\n=== 结束当前周 ===');
  游戏.结束当前周();
  console.log(游戏.获取游戏概览());

  // 导出存档
  console.log('\n=== 导出存档 ===');
  const 存档 = 游戏.导出存档();
  console.log('存档版本:', 存档.版本);
  console.log('当前周次:', 存档.时间数据.当前周次);

  return 游戏;
}

// 导出模块
export {
  // 控制器层
  事件总线,
  任务定义注册表,
  任务系统,
  // 系统层
  公式引擎,
  冠军实体,
  冠军工厂,
  // 入口函数
  创建新游戏,
  商品定义注册表,
  喽啰池,
  // 实体层
  实体基类,
  // 数据层
  属性定义注册表,
  情报系统,
  战斗系统,
  插件系统,
  时间系统,
  母畜实体,
  母畜工厂,
  法术定义注册表,
  法术系统,
  游戏主控制器,
  游戏流程演示,
  游戏状态,
  繁殖系统,
  资源系统,
  配置加载器,
  领主实体,
  黑市系统,
  // 配置
  默认配置初始化器
};




// ═══════════════════════════════════════════════════════════════
// 完整任务系统 - 合并版
// ═══════════════════════════════════════════════════════════════

/**
 * 任务定义注册表（完整版）
 * 整合基础任务注册与系统依赖注入
 */
class 任务定义注册表 {
  constructor() {
    // 核心映射
    this.任务类型映射 = new Map();
    this.任务执行器映射 = new Map();
    this.任务验证器映射 = new Map();

    // 系统依赖
    this.系统依赖 = new Map();

    // 任务分类索引
    this.分类索引 = new Map();

    // 任务统计
    this.执行统计 = new Map();
  }

  // ─── 系统依赖管理 ───

  注入系统依赖(依赖配置) {
    /**
     * 依赖配置示例:
     * {
     *   繁殖系统: 繁殖系统实例,
     *   属性注册表: 属性注册表实例,
     *   情报系统: 情报系统实例,
     *   资源系统: 资源系统实例,
     *   母畜工厂: 母畜工厂实例,
     *   公式引擎: 公式引擎实例,
     *   事件总线: 事件总线实例,
     * }
     */
    Object.entries(依赖配置).forEach(([名称, 系统]) => {
      this.系统依赖.set(名称, 系统);
    });
  }

  获取系统(系统名) {
    return this.系统依赖.get(系统名);
  }

  移除系统依赖(系统名) {
    this.系统依赖.delete(系统名);
  }

  // ─── 任务类型注册 ───

  注册任务类型(任务名, 定义) {
    const 完整定义 = {
      // 基础配置
      行动点消耗: 定义.行动点消耗 ?? 1,
      负责人类型: 定义.负责人类型 ?? [], // ['冠军', '母畜']
      负责人条件: 定义.负责人条件 ?? (() => true),

      // 效果配置
      效率属性: 定义.效率属性 ?? [],
      产出类型: 定义.产出类型 ?? [],
      副作用: 定义.副作用 ?? [],

      // 条件配置
      前置条件: 定义.前置条件 ?? (() => true),
      冷却周期: 定义.冷却周期 ?? 0,
      每周限制: 定义.每周限制 ?? Infinity,

      // 分类与描述
      分类: 定义.分类 ?? '通用',
      描述: 定义.描述 ?? '',

      // 特殊标记
      需要目标: 定义.需要目标 ?? false,
      目标类型: 定义.目标类型 ?? null, // '母畜' | '冠军' | '目标ID'
      消耗资源: 定义.消耗资源 ?? null,

      // 动态行动点（可选）
      动态行动点计算: 定义.动态行动点计算 ?? null,

      ...定义,
    };

    this.任务类型映射.set(任务名, 完整定义);

    // 更新分类索引
    const 分类 = 完整定义.分类;
    if (!this.分类索引.has(分类)) {
      this.分类索引.set(分类, new Set());
    }
    this.分类索引.get(分类).add(任务名);

    // 初始化统计
    this.执行统计.set(任务名, { 总执行次数: 0, 成功次数: 0, 失败次数: 0 });
  }

  注册任务执行器(任务名, 执行函数) {
    /**
     * 执行函数签名: (上下文) => 任务结果
     * 上下文包含: 任务名, 负责人, 游戏状态, 额外参数, 以及所有注入的系统依赖
     */
    this.任务执行器映射.set(任务名, 执行函数);
  }

  注册任务验证器(任务名, 验证函数) {
    /**
     * 验证函数签名: (上下文) => { 通过: boolean, 原因?: string }
     */
    if (!this.任务验证器映射.has(任务名)) {
      this.任务验证器映射.set(任务名, []);
    }
    this.任务验证器映射.get(任务名).push(验证函数);
  }

  // ─── 任务查询 ───

  获取任务定义(任务名) {
    return this.任务类型映射.get(任务名);
  }

  获取分类任务列表(分类) {
    const 任务名集合 = this.分类索引.get(分类);
    if (!任务名集合) return [];

    return Array.from(任务名集合).map(名称 => ({
      名称,
      ...this.任务类型映射.get(名称),
    }));
  }

  获取所有任务列表() {
    return Array.from(this.任务类型映射.entries()).map(([名称, 定义]) => ({
      名称,
      ...定义,
    }));
  }

  获取负责人可执行任务(负责人, 游戏状态) {
    const 可执行任务 = [];

    this.任务类型映射.forEach((定义, 任务名) => {
      if (!定义.负责人类型.includes(负责人.实体类型)) return;

      const 上下文 = this.构建执行上下文({
        任务名,
        负责人,
        游戏状态,
      });

      const 验证结果 = this.验证任务可执行性(任务名, 上下文);
      if (验证结果.可执行) {
        可执行任务.push({
          名称: 任务名,
          行动点消耗: this.计算实际行动点(任务名, 上下文),
          ...定义,
        });
      }
    });

    return 可执行任务;
  }

  // ─── 上下文构建 ───

  构建执行上下文(基础上下文) {
    const 扩展上下文 = { ...基础上下文 };

    // 注入所有系统依赖
    this.系统依赖.forEach((系统, 名称) => {
      扩展上下文[名称] = 系统;
    });

    return 扩展上下文;
  }

  // ─── 任务验证 ───

  验证任务可执行性(任务名, 上下文) {
    const 定义 = this.任务类型映射.get(任务名);
    if (!定义) {
      return { 可执行: false, 原因: '未知任务类型' };
    }

    const { 负责人, 游戏状态, 时间系统 } = 上下文;

    // 检查负责人类型
    if (!定义.负责人类型.includes(负责人.实体类型)) {
      return { 可执行: false, 原因: '负责人类型不匹配' };
    }

    // 检查负责人条件
    if (!定义.负责人条件(上下文)) {
      return { 可执行: false, 原因: '负责人条件不满足' };
    }

    // 检查前置条件
    if (!定义.前置条件(上下文)) {
      return { 可执行: false, 原因: '前置条件不满足' };
    }

    // 检查行动点
    const 实际消耗 = this.计算实际行动点(任务名, 上下文);
    if (时间系统 && 时间系统.剩余行动点 < 实际消耗) {
      return { 可执行: false, 原因: '行动点不足' };
    }

    // 检查资源消耗
    if (定义.消耗资源) {
      const 资源系统 = this.获取系统('资源系统');
      if (资源系统) {
        for (const [资源名, 数量] of Object.entries(定义.消耗资源)) {
          if (资源系统.获取资源(资源名) < 数量) {
            return { 可执行: false, 原因: `${资源名}不足` };
          }
        }
      }
    }

    // 执行自定义验证器
    const 验证器列表 = this.任务验证器映射.get(任务名) ?? [];
    for (const 验证器 of 验证器列表) {
      const 结果 = 验证器(上下文);
      if (!结果.通过) {
        return { 可执行: false, 原因: 结果.原因 };
      }
    }

    return { 可执行: true };
  }

  计算实际行动点(任务名, 上下文) {
    const 定义 = this.任务类型映射.get(任务名);
    if (!定义) return 1;

    // 使用动态计算（如果存在）
    if (定义.动态行动点计算) {
      return 定义.动态行动点计算(上下文);
    }

    return 定义.行动点消耗;
  }

  // ─── 统计 ───

  记录执行结果(任务名, 成功) {
    const 统计 = this.执行统计.get(任务名);
    if (统计) {
      统计.总执行次数++;
      if (成功) {
        统计.成功次数++;
      } else {
        统计.失败次数++;
      }
    }
  }

  获取任务统计(任务名) {
    return this.执行统计.get(任务名);
  }

  获取所有统计() {
    return Object.fromEntries(this.执行统计);
  }
}

// ═══════════════════════════════════════════════════════════════
// 任务系统（完整版）
// ═══════════════════════════════════════════════════════════════

/**
 * 任务系统
 * 统一管理任务的验证、执行和结果处理
 */
class 任务系统 {
  constructor(事件总线, 任务注册表, 时间系统, 公式引擎) {
    this.事件总线 = 事件总线;
    this.任务注册表 = 任务注册表;
    this.时间系统 = 时间系统;
    this.公式引擎 = 公式引擎;

    // 任务队列（用于异步/延迟任务）
    this.待处理任务队列 = [];

    // 本周任务记录
    this.本周执行记录 = new Map();

    // 任务结果历史
    this.任务历史 = [];
    this.历史上限 = 100;
  }

  // ─── 核心执行流程 ───

  验证任务(任务名, 负责人, 游戏状态, 额外参数 = {}) {
    const 上下文 = this.任务注册表.构建执行上下文({
      任务名,
      负责人,
      游戏状态,
      时间系统: this.时间系统,
      额外参数,
    });

    return this.任务注册表.验证任务可执行性(任务名, 上下文);
  }

  执行任务(任务名, 负责人, 游戏状态, 额外参数 = {}) {
    // 构建完整上下文
    const 上下文 = this.任务注册表.构建执行上下文({
      任务名,
      负责人,
      游戏状态,
      时间系统: this.时间系统,
      公式引擎: this.公式引擎,
      事件总线: this.事件总线,
      额外参数,
    });

    // 验证
    const 验证结果 = this.任务注册表.验证任务可执行性(任务名, 上下文);
    if (!验证结果.可执行) {
      this.任务注册表.记录执行结果(任务名, false);
      return { 成功: false, 原因: 验证结果.原因 };
    }

    const 定义 = this.任务注册表.获取任务定义(任务名);

    // 消耗行动点
    const 实际消耗 = this.任务注册表.计算实际行动点(任务名, 上下文);
    if (实际消耗 > 0) {
      this.时间系统.消耗行动点(实际消耗);
    }

    // 消耗资源
    if (定义.消耗资源) {
      const 资源系统 = this.任务注册表.获取系统('资源系统');
      if (资源系统) {
        for (const [资源名, 数量] of Object.entries(定义.消耗资源)) {
          资源系统.修改资源(资源名, -数量);
        }
      }
    }

    // 获取并执行任务执行器
    const 执行器 = this.任务注册表.任务执行器映射.get(任务名);
    if (!执行器) {
      this.任务注册表.记录执行结果(任务名, false);
      return { 成功: false, 原因: '任务执行器未注册' };
    }

    let 执行结果;
    try {
      执行结果 = 执行器(上下文);
    } catch (错误) {
      console.error(`任务执行错误 [${任务名}]:`, 错误);
      this.任务注册表.记录执行结果(任务名, false);
      return { 成功: false, 原因: '任务执行异常', 错误: 错误.message };
    }

    // 处理副作用
    if (执行结果.成功 !== false) {
      定义.副作用.forEach(副作用处理器 => {
        try {
          副作用处理器(上下文, 执行结果);
        } catch (错误) {
          console.error(`副作用处理错误 [${任务名}]:`, 错误);
        }
      });
    }

    // 记录统计
    this.任务注册表.记录执行结果(任务名, 执行结果.成功 !== false);

    // 记录本周执行
    this.记录本周执行(任务名, 负责人.实体ID);

    // 记录历史
    this.记录任务历史({
      任务名,
      负责人ID: 负责人.实体ID,
      周次: this.时间系统?.当前周次,
      结果: 执行结果,
      时间戳: Date.now(),
    });

    // 发布事件
    this.事件总线.发布('任务完成', {
      任务名,
      负责人ID: 负责人.实体ID,
      行动点消耗: 实际消耗,
      结果: 执行结果,
    });

    return { 成功: true, 结果: 执行结果 };
  }

  // ─── 批量执行 ───

  批量执行任务(任务列表, 游戏状态) {
    /**
     * 任务列表格式: [{ 任务名, 负责人, 额外参数 }, ...]
     */
    const 结果列表 = [];

    for (const 任务配置 of 任务列表) {
      const 结果 = this.执行任务(
        任务配置.任务名,
        任务配置.负责人,
        游戏状态,
        任务配置.额外参数 ?? {}
      );
      结果列表.push({
        任务名: 任务配置.任务名,
        ...结果,
      });

      // 如果任务失败且配置为中断，则停止执行
      if (!结果.成功 && 任务配置.失败中断) {
        break;
      }
    }

    return 结果列表;
  }

  // ─── 记录管理 ───

  记录本周执行(任务名, 负责人ID) {
    const 键 = `${任务名}_${负责人ID}`;
    const 当前计数 = this.本周执行记录.get(键) ?? 0;
    this.本周执行记录.set(键, 当前计数 + 1);
  }

  重置本周记录() {
    this.本周执行记录.clear();
  }

  获取本周执行次数(任务名, 负责人ID = null) {
    if (负责人ID) {
      return this.本周执行记录.get(`${任务名}_${负责人ID}`) ?? 0;
    }

    let 总次数 = 0;
    this.本周执行记录.forEach((次数, 键) => {
      if (键.startsWith(`${任务名}_`)) {
        总次数 += 次数;
      }
    });
    return 总次数;
  }

  记录任务历史(记录) {
    this.任务历史.push(记录);
    if (this.任务历史.length > this.历史上限) {
      this.任务历史.shift();
    }
  }

  获取任务历史(过滤条件 = null) {
    if (!过滤条件) return [...this.任务历史];

    return this.任务历史.filter(记录 => {
      if (过滤条件.任务名 && 记录.任务名 !== 过滤条件.任务名) return false;
      if (过滤条件.负责人ID && 记录.负责人ID !== 过滤条件.负责人ID) return false;
      if (过滤条件.周次 && 记录.周次 !== 过滤条件.周次) return false;
      return true;
    });
  }

  // ─── 周结算钩子 ───

  周结算处理() {
    this.重置本周记录();
  }
}

// ═══════════════════════════════════════════════════════════════
// 默认任务配置初始化
// ═══════════════════════════════════════════════════════════════

/**
 * 初始化所有默认任务定义和执行器
 */
function 初始化默认任务(任务注册表) {

  // ═══════════════════════════════════════════════════════════════
  // 调教类任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 调教（冠军 → 母畜）───
  任务注册表.注册任务类型('调教', {
    分类: '调教',
    行动点消耗: 1,
    负责人类型: ['冠军'],
    效率属性: ['智力'],
    产出类型: ['臣服度'],
    需要目标: true,
    目标类型: '母畜',
    描述: '冠军对母畜进行调教，提升其臣服度',
  });

  任务注册表.注册任务执行器('调教', (上下文) => {
    const { 负责人, 游戏状态, 属性注册表, 公式引擎, 额外参数 } = 上下文;
    const 目标ID = 额外参数?.目标ID;

    const 目标母畜 = 游戏状态.获取母畜(目标ID);
    if (!目标母畜) {
      return { 成功: false, 原因: '目标不存在' };
    }

    const 智力 = 负责人.获取属性('智力');
    const 臣服度增加 = 公式引擎.计算('调教效率', { 智力 });

    const 旧臣服度 = 目标母畜.获取属性('臣服度');
    目标母畜.修改属性('臣服度', 臣服度增加, 属性注册表);
    const 新臣服度 = 目标母畜.获取属性('臣服度');

    return {
      成功: true,
      效果: {
        臣服度增加: Math.floor(臣服度增加),
        当前臣服度: 新臣服度,
      },
      目标ID: 目标母畜.实体ID,
    };
  });

  // ─── 劝慰（母畜 → 母畜）───
  任务注册表.注册任务类型('劝慰', {
    分类: '调教',
    行动点消耗: 1,
    负责人类型: ['母畜'],
    负责人条件: (上下文) => 上下文.负责人.获取属性('臣服度') >= 75,
    产出类型: ['臣服度'],
    需要目标: true,
    目标类型: '母畜',
    描述: '已归心的母畜劝慰新来者，同种族/身份有加成',
  });

  任务注册表.注册任务执行器('劝慰', (上下文) => {
    const { 负责人, 游戏状态, 属性注册表, 额外参数 } = 上下文;

    const 目标母畜 = 游戏状态.获取母畜(额外参数.目标ID);
    if (!目标母畜) {
      return { 成功: false, 原因: '目标不存在' };
    }

    // 不能劝慰自己
    if (负责人.实体ID === 目标母畜.实体ID) {
      return { 成功: false, 原因: '不能对自己执行此任务' };
    }

    let 臣服度增加 = 10;

    // 同种族加成 ×1.5
    if (负责人.获取属性('种族') === 目标母畜.获取属性('种族')) {
      臣服度增加 *= 1.5;
    }

    // 同身份加成 ×1.3
    if (负责人.获取属性('原身份') === 目标母畜.获取属性('原身份')) {
      臣服度增加 *= 1.3;
    }

    目标母畜.修改属性('臣服度', 臣服度增加, 属性注册表);

    return {
      成功: true,
      效果: {
        臣服度增加: Math.floor(臣服度增加),
        当前臣服度: 目标母畜.获取属性('臣服度'),
      },
      目标ID: 目标母畜.实体ID,
    };
  });

  // ─── 惩戒（冠军 → 母畜）───
  任务注册表.注册任务类型('惩戒', {
    分类: '调教',
    行动点消耗: 1,
    负责人类型: ['冠军'],
    效率属性: ['力量'],
    产出类型: ['臣服度', '淫乱度'],
    需要目标: true,
    目标类型: '母畜',
    描述: '通过惩戒快速提升臣服度，但会大幅增加淫乱度',
  });

  任务注册表.注册任务执行器('惩戒', (上下文) => {
    const { 负责人, 游戏状态, 属性注册表, 额外参数 } = 上下文;

    const 目标母畜 = 游戏状态.获取母畜(额外参数?.目标ID);
    if (!目标母畜) {
      return { 成功: false, 原因: '目标不存在' };
    }

    const 力量 = 负责人.获取属性('力量');
    const 臣服度增加 = 8 + Math.floor(力量 / 10);
    const 淫乱度增加 = 12 + Math.floor(力量 / 15);

    目标母畜.修改属性('臣服度', 臣服度增加, 属性注册表);
    目标母畜.修改属性('淫乱度', 淫乱度增加, 属性注册表);

    return {
      成功: true,
      效果: {
        臣服度增加,
        淫乱度增加,
        当前臣服度: 目标母畜.获取属性('臣服度'),
        当前淫乱度: 目标母畜.获取属性('淫乱度'),
      },
      目标ID: 目标母畜.实体ID,
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 侦察类任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 潜入侦察（母畜 → 目标）───
  任务注册表.注册任务类型('潜入侦察', {
    分类: '侦察',
    行动点消耗: 1,
    负责人类型: ['母畜'],
    负责人条件: (上下文) => 上下文.负责人.获取属性('臣服度') >= 90,
    产出类型: ['情报'],
    需要目标: true,
    目标类型: '目标ID',
    描述: '派遣忠诚母畜潜入目标进行侦察，有暴露风险',
  });

  任务注册表.注册任务执行器('潜入侦察', (上下文) => {
    const { 负责人, 情报系统, 属性注册表, 额外参数, 公式引擎, 事件总线 } = 上下文;
    const 目标ID = 额外参数?.目标ID;

    if (!情报系统) {
      return { 成功: false, 原因: '情报系统未初始化' };
    }

    if (!目标ID) {
      return { 成功: false, 原因: '未指定侦察目标' };
    }

    const 臣服度 = 负责人.获取属性('臣服度');
    const 淫乱度 = 负责人.获取属性('淫乱度');

    // 效率公式: 1 × (臣服度 ÷ 50) × (1 - 淫乱度 ÷ 200)
    const 效率 = 公式引擎.计算('潜入侦察效率', { 臣服度, 淫乱度 });
    const 情报增量 = Math.floor(效率 * 20);

    // 暴露风险判定
    const 暴露概率 = 淫乱度 / 200;
    const 是否暴露 = Math.random() < 暴露概率;

    if (是否暴露) {
      事件总线.发布('负责人暴露', {
        负责人ID: 负责人.实体ID,
        任务: '潜入侦察',
        目标ID,
      });
      return {
        成功: false,
        暴露: true,
        负责人ID: 负责人.实体ID,
        原因: '侦察员身份暴露',
      };
    }

    // 增加情报进度
    情报系统.增加情报进度(目标ID, 情报增量);

    // 尝试锁定目标
    const 锁定系数 = 负责人.获取属性('总雌性价值') / 100;
    const 新锁定目标 = 情报系统.尝试锁定目标(目标ID, 锁定系数);

    // 侦察会略微增加淫乱度（被骚扰等）
    负责人.修改属性('淫乱度', 2, 属性注册表);

    return {
      成功: true,
      效果: {
        情报增量,
        新锁定目标,
        淫乱度增加: 2,
      },
      目标ID,
    };
  });

  // ─── 直接侦察（冠军 → 目标）───
  任务注册表.注册任务类型('直接侦察', {
    分类: '侦察',
    行动点消耗: 1,
    负责人类型: ['冠军'],
    效率属性: ['敏捷'],
    产出类型: ['情报'],
    需要目标: true,
    目标类型: '目标ID',
    描述: '派遣冠军直接侦察，效率较高但可能遭遇战斗',
  });

  任务注册表.注册任务执行器('直接侦察', (上下文) => {
    const { 负责人, 情报系统, 额外参数, 公式引擎, 事件总线 } = 上下文;
    const 目标ID = 额外参数?.目标ID;

    if (!情报系统) {
      return { 成功: false, 原因: '情报系统未初始化' };
    }

    if (!目标ID) {
      return { 成功: false, 原因: '未指定侦察目标' };
    }

    const 敏捷 = 负责人.获取属性('敏捷');
    const 效率 = 公式引擎.计算('直接侦察效率', { 敏捷 });
    const 情报增量 = Math.floor(效率 * 15);

    // 增加情报进度
    情报系统.增加情报进度(目标ID, 情报增量);

    // 遭遇战风险
    const 遭遇战概率 = 0.1;
    const 发生遭遇战 = Math.random() < 遭遇战概率;

    if (发生遭遇战) {
      事件总线.发布('遭遇战发生', {
        冠军ID: 负责人.实体ID,
        目标ID,
      });
    }

    // 尝试锁定目标
    const 锁定系数 = 敏捷 / 10;
    const 新锁定目标 = 情报系统.尝试锁定目标(目标ID, 锁定系数);

    return {
      成功: true,
      效果: {
        情报增量,
        新锁定目标,
      },
      目标ID,
      遭遇战: 发生遭遇战,
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 繁殖类任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 生育冠军 ───
  任务注册表.注册任务类型('生育冠军', {
    分类: '繁殖',
    行动点消耗: 1, // 基础消耗，臣服度不足时为2
    负责人类型: ['母畜'],
    负责人条件: (上下文) => {
      const 剩余价值 = 上下文.负责人.获取属性('剩余雌性价值');
      return 剩余价值 >= 100;
    },
    产出类型: ['冠军'],
    动态行动点计算: (上下文) => {
      const 臣服度 = 上下文.负责人.获取属性('臣服度');
      return 臣服度 >= 25 ? 1 : 2;
    },
    描述: '母畜生育一名冠军，消耗100雌性价值',
  });

  任务注册表.注册任务执行器('生育冠军', (上下文) => {
    const { 负责人, 繁殖系统, 游戏状态, 属性注册表, 事件总线 } = 上下文;

    if (!繁殖系统) {
      return { 成功: false, 原因: '繁殖系统未初始化' };
    }

    const 结果 = 繁殖系统.生育冠军(负责人);

    if (结果.成功) {
      // 将新冠军添加到游戏状态
      游戏状态.添加冠军(结果.冠军);

      // 检查是否是首个冠军
      if (游戏状态.冠军列表.length === 1) {
        事件总线.发布('首个冠军诞生', { 冠军: 结果.冠军 });
      }
    }

    return 结果;
  });

  // ─── 生育喽啰 ───
  任务注册表.注册任务类型('生育喽啰', {
    分类: '繁殖',
    行动点消耗: 0, // 基础消耗，臣服度不足时为1
    负责人类型: ['母畜'],
    负责人条件: (上下文) => {
      const 剩余价值 = 上下文.负责人.获取属性('剩余雌性价值');
      return 剩余价值 > 0;
    },
    产出类型: ['喽啰'],
    动态行动点计算: (上下文) => {
      const 臣服度 = 上下文.负责人.获取属性('臣服度');
      return 臣服度 >= 25 ? 0 : 1;
    },
    描述: '母畜生育喽啰，消耗100雌性价值产出10喽啰（不足时按10点/喽啰计算）',
  });

  任务注册表.注册任务执行器('生育喽啰', (上下文) => {
    const { 负责人, 繁殖系统 } = 上下文;

    if (!繁殖系统) {
      return { 成功: false, 原因: '繁殖系统未初始化' };
    }

    return 繁殖系统.生育喽啰(负责人);
  });

  // ─── 设置繁殖状态 ───
  任务注册表.注册任务类型('设置繁殖状态', {
    分类: '繁殖',
    行动点消耗: 0,
    负责人类型: ['母畜'],
    负责人条件: (上下文) => 上下文.负责人.获取属性('臣服度') >= 25,
    描述: '将母畜标记为繁殖状态',
  });

  任务注册表.注册任务执行器('设置繁殖状态', (上下文) => {
    const { 负责人 } = 上下文;

    if (负责人.拥有标签('繁殖状态')) {
      return { 成功: false, 原因: '已处于繁殖状态' };
    }

    负责人.添加标签('繁殖状态');

    return {
      成功: true,
      效果: { 状态变更: '进入繁殖状态' },
    };
  });

  // ─── 取消繁殖状态 ───
  任务注册表.注册任务类型('取消繁殖状态', {
    分类: '繁殖',
    行动点消耗: 0,
    负责人类型: ['母畜'],
    描述: '取消母畜的繁殖状态',
  });

  任务注册表.注册任务执行器('取消繁殖状态', (上下文) => {
    const { 负责人 } = 上下文;

    if (!负责人.拥有标签('繁殖状态')) {
      return { 成功: false, 原因: '未处于繁殖状态' };
    }

    负责人.移除标签('繁殖状态');

    return {
      成功: true,
      效果: { 状态变更: '退出繁殖状态' },
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 军事类任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 提振士气 ───
  任务注册表.注册任务类型('提振士气', {
    分类: '军事',
    行动点消耗: 1,
    负责人类型: ['母畜'],
    负责人条件: (上下文) => 上下文.负责人.获取属性('臣服度') >= 75,
    产出类型: ['士气'],
    描述: '母畜在喽啰面前表演以提振士气',
    副作用: [
      (上下文) => {
        const { 负责人, 属性注册表 } = 上下文;
        负责人.修改属性('淫乱度', 5, 属性注册表);
      },
    ],
  });

  任务注册表.注册任务执行器('提振士气', (上下文) => {
    const { 负责人, 游戏状态, 公式引擎 } = 上下文;

    const 淫乱度 = 负责人.获取属性('淫乱度');
    const 总雌性价值 = 负责人.获取属性('总雌性价值');

    const 士气提升 = 公式引擎.计算('提振士气效率', { 淫乱度, 总雌性价值 });
    游戏状态.修改士气(士气提升);

    return {
      成功: true,
      效果: {
        士气提升: Math.floor(士气提升),
        淫乱度增加: 5,
        当前士气: 游戏状态.军队状态.士气,
      },
    };
  });

  // ─── 训练喽啰 ───
  任务注册表.注册任务类型('训练喽啰', {
    分类: '军事',
    行动点消耗: 1,
    负责人类型: ['冠军'],
    效率属性: ['力量'],
    产出类型: ['战力'],
    描述: '冠军训练喽啰，提升基础战斗力',
  });

  任务注册表.注册任务执行器('训练喽啰', (上下文) => {
    const { 负责人, 游戏状态 } = 上下文;

    const 力量 = 负责人.获取属性('力量');
    const 战力提升 = 2 + Math.floor(力量 / 20);

    游戏状态.军队状态.战斗力基础值 += 战力提升;

    return {
      成功: true,
      效果: {
        战力提升,
        当前基础战力: 游戏状态.军队状态.战斗力基础值,
      },
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 资源类任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 泌乳（被动/主动）───
  任务注册表.注册任务类型('泌乳', {
    分类: '资源',
    行动点消耗: 0,
    负责人类型: ['母畜'],
    负责人条件: (上下文) => 上下文.负责人.获取属性('淫乱度') >= 25,
    产出类型: ['母乳'],
    描述: '淫乱度达到25以上的母畜会产出母乳',
    副作用: [
      (上下文) => {
        const { 负责人, 属性注册表 } = 上下文;
        负责人.修改属性('淫乱度', 3, 属性注册表);
      },
    ],
  });

  任务注册表.注册任务执行器('泌乳', (上下文) => {
    const { 负责人, 资源系统, 公式引擎 } = 上下文;

    const 淫乱度 = 负责人.获取属性('淫乱度');
    const 产量 = 公式引擎.计算('泌乳产量', { 淫乱度 });

    if (资源系统) {
      资源系统.修改资源('母乳', 产量);
    }

    return {
      成功: true,
      效果: {
        母乳产量: 产量,
        淫乱度增加: 3,
      },
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 特殊任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 潜入劝诱 ───
  任务注册表.注册任务类型('潜入劝诱', {
    分类: '特殊',
    行动点消耗: 1,
    负责人类型: ['母畜'],
    负责人条件: (上下文) => 上下文.负责人.获取属性('臣服度') >= 90,
    产出类型: ['母畜'],
    需要目标: true,
    描述: '派遣母畜劝诱目标地点的女性加入部落',
  });

  任务注册表.注册任务执行器('潜入劝诱', (上下文) => {
    const { 负责人, 母畜工厂, 游戏状态, 额外参数, 公式引擎, 事件总线 } = 上下文;

    const 负责人价值 = 负责人.获取属性('总雌性价值');
    const 目标价值 = 额外参数?.目标价值 ?? 100;

    const 成功率 = 公式引擎.计算('潜入劝诱成功率', { 负责人价值, 目标价值 });
    const 是否成功 = Math.random() < 成功率;

    if (!是否成功) {
      const 暴露概率 = 0.3;
      const 是否暴露 = Math.random() < 暴露概率;

      if (是否暴露) {
        事件总线.发布('负责人暴露', {
          负责人ID: 负责人.实体ID,
          任务: '潜入劝诱',
        });
      }

      return {
        成功: false,
        暴露: 是否暴露,
        负责人ID: 负责人.实体ID,
        原因: '劝诱失败',
      };
    }

    // 创建新母畜
    if (母畜工厂) {
      const 新母畜 = 母畜工厂.创建母畜({
        ...额外参数?.目标配置,
        臣服度: 20,
      });
      游戏状态.添加母畜(新母畜);

      return {
        成功: true,
        新母畜ID: 新母畜.实体ID,
        效果: {
          获得母畜: 新母畜.获取属性('姓名'),
          初始臣服度: 20,
        },
      };
    }

    return {
      成功: true,
      需创建母畜: true,
      初始臣服度: 20,
      目标配置: 额外参数?.目标配置,
    };
  });

  // ─── 献祭母畜 ───
  任务注册表.注册任务类型('献祭母畜', {
    分类: '特殊',
    行动点消耗: 1,
    负责人类型: ['母畜'],
    负责人条件: (上下文) => 上下文.负责人.获取属性('淫乱度') >= 100,
    产出类型: ['魔力'],
    描述: '将完全淫堕的母畜献祭给领主，获得魔力',
  });

  任务注册表.注册任务执行器('献祭母畜', (上下文) => {
    const { 负责人, 游戏状态, 事件总线 } = 上下文;

    const 淫乱度 = 负责人.获取属性('淫乱度');
    if (淫乱度 < 100) {
      return { 成功: false, 原因: '未达到完全淫堕状态' };
    }

    const 总雌性价值 = 负责人.获取属性('总雌性价值');
    const 魔力获得 = Math.floor(总雌性价值 / 100);

    // 领主获得魔力
    if (游戏状态.领主) {
      游戏状态.领主.获得魔力(魔力获得);
    }

    // 发布事件
    事件总线.发布('母畜献祭', {
      母畜ID: 负责人.实体ID,
      母畜姓名: 负责人.获取属性('姓名'),
      魔力获得,
    });

    // 标记需要移除
    return {
      成功: true,
      效果: {
        魔力获得,
      },
      需移除母畜: true,
      移除目标ID: 负责人.实体ID,
    };
  });

  // ─── 冠军陪练 ───
  任务注册表.注册任务类型('冠军陪练', {
    分类: '特殊',
    行动点消耗: 1,
    负责人类型: ['冠军'],
    需要目标: true,
    目标类型: '冠军',
    描述: '两名冠军相互切磋，都有机会获得属性成长',
  });

  任务注册表.注册任务执行器('冠军陪练', (上下文) => {
    const { 负责人, 游戏状态, 额外参数 } = 上下文;

    const 目标冠军 = 游戏状态.获取冠军(额外参数?.目标ID);
    if (!目标冠军) {
      return { 成功: false, 原因: '目标不存在' };
    }

    if (负责人.实体ID === 目标冠军.实体ID) {
      return { 成功: false, 原因: '不能与自己陪练' };
    }

    // 随机属性成长
    const 属性列表 = ['力量', '敏捷', '智力'];
    const 成长结果 = [];

    // 双方都有30%概率获得+1成长
    [负责人, 目标冠军].forEach(冠军 => {
      属性列表.forEach(属性 => {
        if (Math.random() < 0.3) {
          冠军.修改属性(属性, 1);
          成长结果.push({
            冠军ID: 冠军.实体ID,
            冠军姓名: 冠军.获取属性('姓名'),
            属性,
            增量: 1,
          });
        }
      });
    });

    return {
      成功: true,
      效果: {
        成长结果,
      },
    };
  });

  // ─── 休整 ───
  任务注册表.注册任务类型('休整', {
    分类: '通用',
    行动点消耗: 1,
    负责人类型: ['冠军', '母畜'],
    描述: '休息恢复，冠军恢复负伤状态，母畜略微降低淫乱度',
  });

  任务注册表.注册任务执行器('休整', (上下文) => {
    const { 负责人, 属性注册表 } = 上下文;

    const 效果 = {};

    if (负责人.实体类型 === '冠军') {
      // 冠军：移除负伤标签
      if (负责人.拥有标签('负伤')) {
        负责人.移除标签('负伤');
        效果.状态恢复 = '负伤痊愈';
      } else {
        效果.状态恢复 = '无需恢复';
      }
    } else if (负责人.实体类型 === '母畜') {
      // 母畜：降低淫乱度5点
      const 旧淫乱度 = 负责人.获取属性('淫乱度');
      if (旧淫乱度 > 0) {
        负责人.修改属性('淫乱度', -5, 属性注册表);
        效果.淫乱度降低 = Math.min(5, 旧淫乱度);
        效果.当前淫乱度 = 负责人.获取属性('淫乱度');
      } else {
        效果.状态恢复 = '无需恢复';
      }
    }

    return {
      成功: true,
      效果,
    };
  });
}

// ═══════════════════════════════════════════════════════════════
// 工厂函数：创建完整配置的任务系统
// ═══════════════════════════════════════════════════════════════

/**
 * 创建完整任务系统
 * 整合注册表、系统、默认任务定义
 */
function 创建任务系统(配置) {
  const {
    事件总线,
    时间系统,
    公式引擎,
    繁殖系统 = null,
    属性注册表 = null,
    情报系统 = null,
    资源系统 = null,
    母畜工厂 = null,
  } = 配置;

  // 创建注册表
  const 任务注册表 = new 任务定义注册表();

  // 注入系统依赖
  任务注册表.注入系统依赖({
    繁殖系统,
    属性注册表,
    情报系统,
    资源系统,
    母畜工厂,
    公式引擎,
    事件总线,
  });

  // 初始化默认任务
  初始化默认任务(任务注册表);

  // 创建任务系统
  const 任务系统实例 = new 任务系统(事件总线, 任务注册表, 时间系统, 公式引擎);

  // 注册周结算钩子
  if (时间系统) {
    时间系统.注册周结算处理器(() => {
      任务系统实例.周结算处理();
      return { 类型: '任务系统周结算' };
    });
  }

  return {
    任务注册表,
    任务系统: 任务系统实例,
  };
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export {
  任务定义注册表,
  任务系统,
  初始化默认任务,
  创建任务系统,
};


