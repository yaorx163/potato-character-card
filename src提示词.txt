
src\config\attributes.js
```js
// ═══════════════════════════════════════════════════════════════
// config/attributes.js
// 属性配置 - 定义所有属性类型及其阶段
// ═══════════════════════════════════════════════════════════════

/**
 * 初始化默认属性定义
 * @param 属性注册表 - 属性定义注册表实例
 */
function 初始化属性配置(属性注册表) {
  // ═══════════════════════════════════════════════════════════════
  // 母畜属性
  // ═══════════════════════════════════════════════════════════════

  // ─── 臣服度 ───
  属性注册表.注册属性类型('臣服度', {
    默认值: 0,
    最小值: 0,
    最大值: 100,
    描述: '母畜对部落的服从程度，影响可执行的任务类型',
    单位: '',
    阶段定义: [
      {
        名称: '抗拒期',
        等级: 1,
        下限: 0,
        上限: 24,
        描述: '充满敌意，有逃跑风险，需要监控',
        解锁任务: [],
        行为特征: ['可能尝试逃跑', '拒绝合作', '需要强制'],
      },
      {
        名称: '动摇期',
        等级: 2,
        下限: 25,
        上限: 49,
        描述: '意志开始松动，逐渐接受现状',
        解锁任务: ['生育喽啰'],
        行为特征: ['被动服从', '偶尔反抗', '可繁殖'],
      },
      {
        名称: '顺从期',
        等级: 3,
        下限: 50,
        上限: 74,
        描述: '接受现状，开始主动配合',
        解锁任务: ['生育冠军'],
        行为特征: ['主动配合', '不再反抗', '可培养'],
      },
      {
        名称: '归心期',
        等级: 4,
        下限: 75,
        上限: 89,
        描述: '认同部落，积极参与部落事务',
        解锁任务: ['劝慰', '提振士气'],
        行为特征: ['积极参与', '关心部落', '可信任'],
      },
      {
        名称: '忠诚期',
        等级: 5,
        下限: 90,
        上限: 100,
        描述: '彻底归化，愿意为部落付出一切',
        解锁任务: ['潜入侦察', '潜入劝诱'],
        行为特征: ['绝对忠诚', '舍身奉献', '可委以重任'],
      },
    ],
  });

  // ─── 淫乱度 ───
  属性注册表.注册属性类型('淫乱度', {
    默认值: 0,
    最小值: 0,
    最大值: 100,
    描述: '母畜的淫乱程度，影响产出能力和特殊功能',
    单位: '',
    阶段定义: [
      {
        名称: '常态期',
        等级: 1,
        下限: 0,
        上限: 24,
        描述: '保持正常状态，具有正常抵抗力',
        解锁能力: [],
        特征: ['正常状态', '可抵抗诱惑'],
      },
      {
        名称: '泌乳期',
        等级: 2,
        下限: 25,
        上限: 49,
        描述: '身体开始变化，可以诱导产出母乳',
        解锁能力: ['泌乳'],
        特征: ['可产母乳', '身体敏感度提升'],
      },
      {
        名称: '渴求期',
        等级: 3,
        下限: 50,
        上限: 74,
        描述: '持续处于不满足状态，渴求刺激',
        解锁能力: ['增强泌乳'],
        特征: ['主动索求', '难以自控', '产量提升'],
      },
      {
        名称: '淫堕期',
        等级: 4,
        下限: 75,
        上限: 99,
        描述: '本能逐渐支配理智，沉溺于肉欲',
        解锁能力: ['极限泌乳'],
        特征: ['本能驱动', '理智削弱', '高产量'],
      },
      {
        名称: '完全淫堕',
        等级: 5,
        下限: 100,
        上限: 100,
        描述: '彻底被本能支配，可用于献祭',
        解锁能力: ['献祭转化'],
        特征: ['丧失理智', '纯粹肉欲', '可献祭'],
      },
    ],
  });

  // ─── 雌性价值 ───
  属性注册表.注册属性类型('剩余雌性价值', {
    默认值: 100,
    最小值: 0,
    最大值: Infinity, // 上限由总雌性价值决定
    描述: '母畜剩余的生育价值，消耗后无法恢复（除非使用特殊道具）',
    单位: '点',
  });

  属性注册表.注册属性类型('总雌性价值', {
    默认值: 100,
    最小值: 10,
    最大值: 1000,
    描述: '母畜的总生育价值，决定其生育潜力和子代品质',
    单位: '点',
  });

  // ═══════════════════════════════════════════════════════════════
  // 冠军属性
  // ═══════════════════════════════════════════════════════════════

  // ─── 力量 ───
  属性注册表.注册属性类型('力量', {
    默认值: 10,
    最小值: 1,
    最大值: 100,
    描述: '物理力量，影响可统帅喽啰数量和战斗力',
    单位: '',
    影响: ['可统帅喽啰数 = 力量值', '部曲战力加成', '惩戒任务效率'],
  });

  // ─── 敏捷 ───
  属性注册表.注册属性类型('敏捷', {
    默认值: 10,
    最小值: 1,
    最大值: 100,
    描述: '行动敏捷度，影响侦察效率和规避能力',
    单位: '',
    影响: ['直接侦察效率', '遭遇战规避概率', '锁定目标概率'],
  });

  // ─── 智力 ───
  属性注册表.注册属性类型('智力', {
    默认值: 10,
    最小值: 1,
    最大值: 100,
    描述: '智慧程度，影响调教效率和策略能力',
    单位: '',
    影响: ['调教任务效率', '战术判断'],
  });

  // ─── 经验与等级 ───
  属性注册表.注册属性类型('经验', {
    默认值: 0,
    最小值: 0,
    最大值: Infinity,
    描述: '冠军积累的经验值',
    单位: '点',
  });

  属性注册表.注册属性类型('等级', {
    默认值: 1,
    最小值: 1,
    最大值: 50,
    描述: '冠军的等级',
    单位: '级',
  });

  // ═══════════════════════════════════════════════════════════════
  // 军队属性
  // ═══════════════════════════════════════════════════════════════

  // ─── 士气 ───
  属性注册表.注册属性类型('士气', {
    默认值: 50,
    最小值: 0,
    最大值: 100,
    描述: '军队士气，影响战斗力系数',
    单位: '',
    衰减配置: {
      周期: '周',
      衰减量: 5,
      描述: '每周自然衰减5点',
    },
    阶段定义: [
      { 名称: '崩溃', 等级: 1, 下限: 0, 上限: 19, 系数: 0.5 },
      { 名称: '低迷', 等级: 2, 下限: 20, 上限: 39, 系数: 0.75 },
      { 名称: '正常', 等级: 3, 下限: 40, 上限: 59, 系数: 1.0 },
      { 名称: '高涨', 等级: 4, 下限: 60, 上限: 79, 系数: 1.25 },
      { 名称: '狂热', 等级: 5, 下限: 80, 上限: 100, 系数: 1.5 },
    ],
  });

  // ═══════════════════════════════════════════════════════════════
  // 领主属性
  // ═══════════════════════════════════════════════════════════════

  // ─── 魔力 ───
  属性注册表.注册属性类型('魔力', {
    默认值: 0,
    最小值: 0,
    最大值: 100,
    描述: '领主的魔力值，用于施放法术',
    单位: '点',
    获取方式: ['献祭完全淫堕的母畜', '特殊事件奖励'],
  });

  属性注册表.注册属性类型('最大魔力', {
    默认值: 100,
    最小值: 10,
    最大值: 999,
    描述: '领主的魔力上限',
    单位: '点',
  });

  // ═══════════════════════════════════════════════════════════════
  // 派生属性计算器
  // ═══════════════════════════════════════════════════════════════

  // 泌乳产量计算
  属性注册表.注册属性计算器('泌乳产量', 上下文 => {
    const 淫乱度 = 上下文.实体?.获取属性('淫乱度') ?? 0;
    if (淫乱度 < 25) return 0;
    return Math.floor((淫乱度 + 45) / 20);
  });

  // 可统帅喽啰数计算
  属性注册表.注册属性计算器('可统帅喽啰数', 上下文 => {
    const 力量 = 上下文.实体?.获取属性('力量') ?? 0;
    return 力量;
  });

  // 调教效率计算
  属性注册表.注册属性计算器('调教效率', 上下文 => {
    const 智力 = 上下文.实体?.获取属性('智力') ?? 0;
    return 5 * (智力 / 25) + 5;
  });

  // 侦察效率计算
  属性注册表.注册属性计算器('侦察效率', 上下文 => {
    const 敏捷 = 上下文.实体?.获取属性('敏捷') ?? 0;
    return 1 * (敏捷 / 25);
  });
}

// ═══════════════════════════════════════════════════════════════
// 身份价值配置
// ═══════════════════════════════════════════════════════════════

const 身份价值配置 = {
  // 顶级身份
  圣女: { 最小: 450, 最大: 550 },
  公主: { 最小: 450, 最大: 550 },
  女王: { 最小: 500, 最大: 600 },

  // 高级身份
  女骑士: { 最小: 350, 最大: 450 },
  高阶法师: { 最小: 350, 最大: 450 },
  大贵族: { 最小: 350, 最大: 450 },
  女将军: { 最小: 350, 最大: 450 },

  // 中级身份
  城主之女: { 最小: 200, 最大: 300 },
  低阶冒险者: { 最小: 200, 最大: 300 },
  见习法师: { 最小: 200, 最大: 300 },
  女侍卫: { 最小: 180, 最大: 280 },

  // 普通身份
  商人之女: { 最小: 150, 最大: 200 },
  村长之女: { 最小: 120, 最大: 180 },
  工匠之女: { 最小: 100, 最大: 160 },

  // 低级身份
  普通人: { 最小: 80, 最大: 120 },
  农家女: { 最小: 70, 最大: 110 },
  佣人: { 最小: 60, 最大: 100 },
};

// ═══════════════════════════════════════════════════════════════
// 冠军效率系数配置
// ═══════════════════════════════════════════════════════════════

const 冠军效率系数配置 = {
  // 战士系
  女骑士: { 力量: 1.3, 敏捷: 1.0, 智力: 0.8 },
  战士: { 力量: 1.3, 敏捷: 1.0, 智力: 0.8 },
  女将军: { 力量: 1.4, 敏捷: 0.9, 智力: 0.9 },

  // 敏捷系
  盗贼: { 力量: 0.9, 敏捷: 1.3, 智力: 0.9 },
  游侠: { 力量: 0.9, 敏捷: 1.3, 智力: 0.9 },
  刺客: { 力量: 0.8, 敏捷: 1.4, 智力: 0.9 },
  低阶冒险者: { 力量: 1.0, 敏捷: 1.2, 智力: 0.9 },

  // 智力系
  法师: { 力量: 0.7, 敏捷: 0.9, 智力: 1.4 },
  高阶法师: { 力量: 0.6, 敏捷: 0.8, 智力: 1.5 },
  见习法师: { 力量: 0.7, 敏捷: 0.9, 智力: 1.3 },
  学者: { 力量: 0.7, 敏捷: 0.9, 智力: 1.4 },

  // 均衡系
  贵族: { 力量: 1.0, 敏捷: 1.0, 智力: 1.1 },
  圣女: { 力量: 0.9, 敏捷: 1.0, 智力: 1.2 },
  公主: { 力量: 0.9, 敏捷: 1.0, 智力: 1.2 },

  // 特殊种族
  精灵: { 力量: 0.9, 敏捷: 1.2, 智力: 1.1 },
  半精灵: { 力量: 0.95, 敏捷: 1.15, 智力: 1.0 },
  兽人: { 力量: 1.4, 敏捷: 0.9, 智力: 0.7 },

  // 默认
  普通人: { 力量: 1.0, 敏捷: 1.0, 智力: 1.0 },
};

// ═══════════════════════════════════════════════════════════════
// 种族价值修正配置
// ═══════════════════════════════════════════════════════════════

const 种族价值修正配置 = {
  人类: { 乘数: 1.0, 加成: 0 },
  精灵: { 乘数: 1.3, 加成: 50 },
  半精灵: { 乘数: 1.15, 加成: 25 },
  兽人: { 乘数: 0.8, 加成: 0 },
  矮人: { 乘数: 0.9, 加成: 20 },
  龙裔: { 乘数: 1.5, 加成: 100 },
};

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 初始化属性配置, 身份价值配置, 冠军效率系数配置, 种族价值修正配置 };

export default 初始化属性配置;
```


src\config\female-generation.js
```js
// ═══════════════════════════════════════════════════════════════
// config/female-generation.js
// 女性角色随机生成配置 - 统一管理母畜/高价值目标的随机规则
// ═══════════════════════════════════════════════════════════════

/**
 * 女性随机配置类
 * 管理所有女性角色的随机生成规则
 */
class 女性随机配置 {
  constructor() {
    // ─── 身份配置 ───
    this.身份价值表 = new Map();
    this.身份权重表 = new Map();

    // ─── 种族配置 ───
    this.种族权重表 = new Map();
    this.种族价值修正表 = new Map();

    // ─── 年龄配置 ───
    this.年龄范围表 = new Map();
    this.默认年龄范围 = { 最小: 16, 最大: 35 };

    // ─── 生成器 ───
    this.姓名生成器 = null;
    this.外貌生成器 = null;

    // ─── 姓名池 ───
    this.姓名池 = {
      人类: [],
      精灵: [],
      半精灵: [],
      兽人: [],
      矮人: [],
      通用: [],
    };

    // ─── 外貌模板 ───
    this.外貌模板 = {
      人类: [],
      精灵: [],
      兽人: [],
      通用: [],
    };

    // ─── 特殊标签规则 ───
    this.特殊标签规则 = [];
  }

  // ═══════════════════════════════════════════════════════════════
  // 身份配置
  // ═══════════════════════════════════════════════════════════════

  注册身份(身份名, 配置) {
    /**
     * 配置示例:
     * {
     *   价值范围: { 最小: 100, 最大: 150 },
     *   权重: 100,           // 随机权重
     *   稀有度: 1,           // 1-5
     *   年龄范围: { 最小: 18, 最大: 30 },  // 可选，覆盖默认
     *   特殊标签: ['贵族'],  // 可选
     * }
     */
    this.身份价值表.set(身份名, {
      最小: 配置.价值范围?.最小 ?? 80,
      最大: 配置.价值范围?.最大 ?? 120,
    });

    this.身份权重表.set(身份名, 配置.权重 ?? 100);

    if (配置.年龄范围) {
      this.年龄范围表.set(身份名, 配置.年龄范围);
    }
  }

  批量注册身份(配置对象) {
    Object.entries(配置对象).forEach(([身份, 配置]) => {
      this.注册身份(身份, 配置);
    });
  }

  获取身份价值范围(身份) {
    return this.身份价值表.get(身份) ?? { 最小: 80, 最大: 120 };
  }

  获取所有身份() {
    return Array.from(this.身份价值表.keys());
  }

  // ═══════════════════════════════════════════════════════════════
  // 种族配置
  // ═══════════════════════════════════════════════════════════════

  注册种族(种族名, 配置) {
    /**
     * 配置示例:
     * {
     *   权重: 70,
     *   价值修正: { 乘数: 1.3, 加成: 50 },
     * }
     */
    this.种族权重表.set(种族名, 配置.权重 ?? 100);
    this.种族价值修正表.set(种族名, {
      乘数: 配置.价值修正?.乘数 ?? 1.0,
      加成: 配置.价值修正?.加成 ?? 0,
    });
  }

  批量注册种族(配置对象) {
    Object.entries(配置对象).forEach(([种族, 配置]) => {
      this.注册种族(种族, 配置);
    });
  }

  获取种族价值修正(种族) {
    return this.种族价值修正表.get(种族) ?? { 乘数: 1.0, 加成: 0 };
  }

  // ═══════════════════════════════════════════════════════════════
  // 姓名生成
  // ═══════════════════════════════════════════════════════════════

  设置姓名生成器(生成函数) {
    /**
     * 生成函数签名: (上下文) => 姓名字符串
     * 上下文: { 种族, 身份, 年龄 }
     */
    this.姓名生成器 = 生成函数;
  }

  设置姓名池(种族, 姓名列表) {
    if (this.姓名池[种族]) {
      this.姓名池[种族] = 姓名列表;
    } else {
      this.姓名池[种族] = 姓名列表;
    }
  }

  批量设置姓名池(配置) {
    Object.entries(配置).forEach(([种族, 列表]) => {
      this.设置姓名池(种族, 列表);
    });
  }

  生成姓名(上下文 = {}) {
    // 优先使用自定义生成器
    if (this.姓名生成器) {
      return this.姓名生成器(上下文);
    }

    // 根据种族选择姓名池
    const 种族 = 上下文.种族 ?? '人类';
    let 候选池 = this.姓名池[种族];

    if (!候选池 || 候选池.length === 0) {
      候选池 = this.姓名池.通用;
    }

    if (候选池 && 候选池.length > 0) {
      return this.随机选择(候选池);
    }

    // 默认姓名
    return `女子_${Math.random().toString(36).slice(2, 6)}`;
  }

  // ═══════════════════════════════════════════════════════════════
  // 外貌生成
  // ═══════════════════════════════════════════════════════════════

  设置外貌生成器(生成函数) {
    /**
     * 生成函数签名: (上下文) => 外貌描述字符串
     */
    this.外貌生成器 = 生成函数;
  }

  设置外貌模板(种族, 模板列表) {
    this.外貌模板[种族] = 模板列表;
  }

  生成外貌(上下文 = {}) {
    if (this.外貌生成器) {
      return this.外貌生成器(上下文);
    }

    const 种族 = 上下文.种族 ?? '人类';
    const 模板池 = this.外貌模板[种族] ?? this.外貌模板.通用 ?? [];

    if (模板池.length > 0) {
      return this.随机选择(模板池);
    }

    return '';
  }

  // ═══════════════════════════════════════════════════════════════
  // 特殊标签规则
  // ═══════════════════════════════════════════════════════════════

  注册特殊标签规则(规则函数) {
    /**
     * 规则函数签名: (上下文) => 标签数组
     * 上下文: { 身份, 种族, 年龄, 总雌性价值 }
     */
    this.特殊标签规则.push(规则函数);
  }

  生成特殊标签(上下文) {
    const 标签集合 = new Set();

    for (const 规则 of this.特殊标签规则) {
      try {
        const 标签列表 = 规则(上下文);
        if (Array.isArray(标签列表)) {
          标签列表.forEach(标签 => 标签集合.add(标签));
        }
      } catch (错误) {
        console.error('特殊标签规则执行错误:', 错误);
      }
    }

    return Array.from(标签集合);
  }

  // ═══════════════════════════════════════════════════════════════
  // 核心随机生成方法
  // ═══════════════════════════════════════════════════════════════

  随机生成(约束条件 = {}) {
    /**
     * 核心随机生成方法
     *
     * 约束条件示例:
     * {
     *   身份池: ['农家女', '商人之女'],     // 限定身份范围
     *   种族池: ['人类', '精灵'],           // 限定种族范围
     *   种族权重覆盖: { 人类: 50, 精灵: 50 }, // 覆盖默认权重
     *   价值范围: { 最小: 100, 最大: 200 }, // 覆盖身份默认价值
     *   年龄范围: { 最小: 18, 最大: 25 },   // 覆盖默认年龄
     *   固定属性: { 姓名: '艾丽丝' },       // 固定某些属性不随机
     *   额外标签: ['处女'],                 // 额外添加的标签
     * }
     *
     * @returns {
     *   姓名, 原身份, 种族, 年龄, 外貌描述,
     *   总雌性价值, 特殊标签
     * }
     */

    // ─── 确定身份 ───
    let 身份;
    if (约束条件.固定属性?.原身份) {
      身份 = 约束条件.固定属性.原身份;
    } else if (约束条件.身份池?.length > 0) {
      身份 = this.按权重随机选择身份(约束条件.身份池);
    } else {
      身份 = this.按权重随机选择身份();
    }

    // ─── 确定种族 ───
    let 种族;
    if (约束条件.固定属性?.种族) {
      种族 = 约束条件.固定属性.种族;
    } else if (约束条件.种族权重覆盖) {
      种族 = this.按权重随机选择(约束条件.种族权重覆盖);
    } else if (约束条件.种族池?.length > 0) {
      种族 = this.按权重随机选择种族(约束条件.种族池);
    } else {
      种族 = this.按权重随机选择种族();
    }

    // ─── 确定年龄 ───
    let 年龄;
    if (约束条件.固定属性?.年龄) {
      年龄 = 约束条件.固定属性.年龄;
    } else {
      const 年龄范围 = 约束条件.年龄范围 ?? this.年龄范围表.get(身份) ?? this.默认年龄范围;
      年龄 = this.随机范围(年龄范围.最小, 年龄范围.最大);
    }

    // ─── 计算雌性价值 ───
    let 总雌性价值;
    if (约束条件.固定属性?.总雌性价值) {
      总雌性价值 = 约束条件.固定属性.总雌性价值;
    } else {
      const 价值范围 = 约束条件.价值范围 ?? this.获取身份价值范围(身份);
      const 基础价值 = this.随机范围(价值范围.最小, 价值范围.最大);

      const 修正 = this.获取种族价值修正(种族);
      总雌性价值 = Math.round(基础价值 * 修正.乘数 + 修正.加成);
      总雌性价值 = Math.max(10, 总雌性价值);
    }

    // ─── 生成上下文 ───
    const 生成上下文 = {
      原身份: 身份,
      种族,
      年龄,
      总雌性价值,
    };

    // ─── 生成姓名 ───
    const 姓名 = 约束条件.固定属性?.姓名 ?? this.生成姓名(生成上下文);

    // ─── 生成外貌 ───
    const 外貌描述 = 约束条件.固定属性?.外貌描述 ?? this.生成外貌(生成上下文);

    // ─── 生成特殊标签 ───
    const 自动标签 = this.生成特殊标签(生成上下文);
    const 额外标签 = 约束条件.额外标签 ?? [];
    const 特殊标签 = [...new Set([...自动标签, ...额外标签])];

    return {
      姓名,
      原身份: 身份,
      种族,
      年龄,
      外貌描述,
      总雌性价值,
      特殊标签,
    };
  }

  // ═══════════════════════════════════════════════════════════════
  // 便捷生成方法
  // ═══════════════════════════════════════════════════════════════

  为袭击目标生成(目标类型配置) {
    /**
     * 为袭击目标生成高价值目标
     * @param 目标类型配置 - 来自 raid-targets.js 的配置
     */
    const 约束条件 = {
      身份池: 目标类型配置.高价值目标身份池,
    };

    // 处理稀有身份
    if (目标类型配置.稀有身份池 && Math.random() < (目标类型配置.稀有身份概率 ?? 0)) {
      约束条件.身份池 = 目标类型配置.稀有身份池;
    }

    // 处理特殊种族权重（如精灵商队）
    if (目标类型配置.种族权重覆盖) {
      约束条件.种族权重覆盖 = 目标类型配置.种族权重覆盖;
    }

    // 处理特殊标签
    if (目标类型配置.特殊标签) {
      约束条件.额外标签 = 目标类型配置.特殊标签;
    }

    return this.随机生成(约束条件);
  }

  为黑市商品生成(商品配置) {
    /**
     * 为黑市商品生成母畜属性
     * @param 商品配置 - 来自商品效果的配置
     */
    const 约束条件 = {};

    // 处理身份
    if (商品配置.原身份) {
      约束条件.固定属性 = { 原身份: 商品配置.原身份 };
    }

    // 处理种族
    if (商品配置.种族) {
      约束条件.固定属性 = {
        ...约束条件.固定属性,
        种族: 商品配置.种族,
      };
    }

    // 处理价值范围
    if (商品配置.总雌性价值范围) {
      约束条件.价值范围 = {
        最小: 商品配置.总雌性价值范围[0],
        最大: 商品配置.总雌性价值范围[1],
      };
    } else if (商品配置.总雌性价值) {
      约束条件.固定属性 = {
        ...约束条件.固定属性,
        总雌性价值: 商品配置.总雌性价值,
      };
    }

    // 处理特殊标签
    if (商品配置.特殊标签) {
      约束条件.额外标签 = 商品配置.特殊标签;
    }

    return this.随机生成(约束条件);
  }

  // ═══════════════════════════════════════════════════════════════
  // 工具方法
  // ═══════════════════════════════════════════════════════════════

  随机选择(数组) {
    if (!数组 || 数组.length === 0) return null;
    return 数组[Math.floor(Math.random() * 数组.length)];
  }

  随机范围(最小, 最大) {
    return Math.floor(Math.random() * (最大 - 最小 + 1)) + 最小;
  }

  按权重随机选择(权重对象) {
    const 总权重 = Object.values(权重对象).reduce((sum, w) => sum + w, 0);
    let 随机值 = Math.random() * 总权重;

    for (const [选项, 权重] of Object.entries(权重对象)) {
      随机值 -= 权重;
      if (随机值 <= 0) {
        return 选项;
      }
    }

    return Object.keys(权重对象)[0];
  }

  按权重随机选择身份(限定池 = null) {
    const 候选 = {};

    if (限定池) {
      限定池.forEach(身份 => {
        候选[身份] = this.身份权重表.get(身份) ?? 100;
      });
    } else {
      this.身份权重表.forEach((权重, 身份) => {
        候选[身份] = 权重;
      });
    }

    if (Object.keys(候选).length === 0) {
      return '普通人';
    }

    return this.按权重随机选择(候选);
  }

  按权重随机选择种族(限定池 = null) {
    const 候选 = {};

    if (限定池) {
      限定池.forEach(种族 => {
        候选[种族] = this.种族权重表.get(种族) ?? 100;
      });
    } else {
      this.种族权重表.forEach((权重, 种族) => {
        候选[种族] = 权重;
      });
    }

    if (Object.keys(候选).length === 0) {
      return '人类';
    }

    return this.按权重随机选择(候选);
  }
}

// ═══════════════════════════════════════════════════════════════
// 默认配置初始化函数
// ═══════════════════════════════════════════════════════════════

function 初始化女性随机配置(配置实例) {
  // ─── 注册身份 ───
  配置实例.批量注册身份({
    // 顶级身份
    圣女: { 价值范围: { 最小: 450, 最大: 550 }, 权重: 5, 稀有度: 5 },
    公主: { 价值范围: { 最小: 450, 最大: 550 }, 权重: 3, 稀有度: 5 },
    女王: { 价值范围: { 最小: 500, 最大: 600 }, 权重: 1, 稀有度: 5 },

    // 高级身份
    女骑士: { 价值范围: { 最小: 350, 最大: 450 }, 权重: 15, 稀有度: 4 },
    高阶法师: { 价值范围: { 最小: 350, 最大: 450 }, 权重: 10, 稀有度: 4 },
    大贵族: { 价值范围: { 最小: 350, 最大: 450 }, 权重: 10, 稀有度: 4 },
    女将军: { 价值范围: { 最小: 350, 最大: 450 }, 权重: 5, 稀有度: 4 },

    // 中级身份
    城主之女: { 价值范围: { 最小: 200, 最大: 300 }, 权重: 30, 稀有度: 3 },
    低阶冒险者: { 价值范围: { 最小: 200, 最大: 300 }, 权重: 40, 稀有度: 3 },
    见习法师: { 价值范围: { 最小: 200, 最大: 300 }, 权重: 25, 稀有度: 3 },
    女侍卫: { 价值范围: { 最小: 180, 最大: 280 }, 权重: 35, 稀有度: 3 },
    贵族: { 价值范围: { 最小: 150, 最大: 200 }, 权重: 40, 稀有度: 3 },

    // 普通身份
    商人之女: { 价值范围: { 最小: 150, 最大: 200 }, 权重: 60, 稀有度: 2 },
    村长之女: { 价值范围: { 最小: 120, 最大: 180 }, 权重: 70, 稀有度: 2 },
    工匠之女: { 价值范围: { 最小: 100, 最大: 160 }, 权重: 80, 稀有度: 2 },

    // 低级身份
    普通人: { 价值范围: { 最小: 80, 最大: 120 }, 权重: 100, 稀有度: 1 },
    农家女: { 价值范围: { 最小: 70, 最大: 110 }, 权重: 120, 稀有度: 1 },
    佣人: { 价值范围: { 最小: 60, 最大: 100 }, 权重: 90, 稀有度: 1 },

    // 特殊身份
    盗贼: { 价值范围: { 最小: 120, 最大: 180 }, 权重: 20, 稀有度: 2 },
    游侠: { 价值范围: { 最小: 150, 最大: 220 }, 权重: 15, 稀有度: 3 },
    刺客: { 价值范围: { 最小: 180, 最大: 260 }, 权重: 10, 稀有度: 3 },
    战士: { 价值范围: { 最小: 160, 最大: 240 }, 权重: 25, 稀有度: 2 },
  });

  // ─── 注册种族 ───
  配置实例.批量注册种族({
    人类: { 权重: 70, 价值修正: { 乘数: 1.0, 加成: 0 } },
    精灵: { 权重: 10, 价值修正: { 乘数: 1.3, 加成: 50 } },
    半精灵: { 权重: 10, 价值修正: { 乘数: 1.15, 加成: 25 } },
    兽人: { 权重: 5, 价值修正: { 乘数: 0.8, 加成: 0 } },
    矮人: { 权重: 5, 价值修正: { 乘数: 0.9, 加成: 20 } },
  });

  // ─── 注册年龄范围（按身份类型）───
  配置实例.年龄范围表.set('圣女', { 最小: 16, 最大: 24 });
  配置实例.年龄范围表.set('公主', { 最小: 14, 最大: 22 });
  配置实例.年龄范围表.set('女骑士', { 最小: 18, 最大: 32 });
  配置实例.年龄范围表.set('低阶冒险者', { 最小: 16, 最大: 28 });
  配置实例.年龄范围表.set('见习法师', { 最小: 14, 最大: 22 });
  配置实例.年龄范围表.set('农家女', { 最小: 14, 最大: 30 });
  配置实例.年龄范围表.set('贵族', { 最小: 16, 最大: 28 });

  // ─── 注册特殊标签规则 ───

  // 精灵血脉
  配置实例.注册特殊标签规则(上下文 => {
    if (上下文.种族 === '精灵') return ['精灵血脉'];
    if (上下文.种族 === '半精灵') return ['半精灵血脉'];
    return [];
  });

  // 高贵血统
  配置实例.注册特殊标签规则(上下文 => {
    const 贵族身份 = ['公主', '女王', '大贵族', '贵族', '城主之女'];
    if (贵族身份.includes(上下文.原身份)) return ['高贵血统'];
    return [];
  });

  // 神圣属性
  配置实例.注册特殊标签规则(上下文 => {
    if (上下文.原身份 === '圣女') return ['神圣'];
    return [];
  });

  // 战斗训练
  配置实例.注册特殊标签规则(上下文 => {
    const 战斗身份 = ['女骑士', '女将军', '女侍卫', '低阶冒险者', '战士', '刺客'];
    if (战斗身份.includes(上下文.原身份)) return ['战斗训练'];
    return [];
  });

  // 魔法天赋
  配置实例.注册特殊标签规则(上下文 => {
    const 魔法身份 = ['高阶法师', '见习法师', '圣女'];
    if (魔法身份.includes(上下文.原身份)) return ['魔法天赋'];
    return [];
  });

  // 高价值标记
  配置实例.注册特殊标签规则(上下文 => {
    if (上下文.总雌性价值 >= 400) return ['极品'];
    if (上下文.总雌性价值 >= 300) return ['优质'];
    return [];
  });
}

// ═══════════════════════════════════════════════════════════════
// 预设种族权重配置（用于特殊场景）
// ═══════════════════════════════════════════════════════════════

const 预设种族权重 = {
  默认: { 人类: 70, 精灵: 10, 半精灵: 10, 兽人: 5, 矮人: 5 },
  精灵聚居地: { 人类: 10, 精灵: 60, 半精灵: 25, 兽人: 0, 矮人: 5 },
  边境地区: { 人类: 50, 精灵: 5, 半精灵: 15, 兽人: 20, 矮人: 10 },
  贵族领地: { 人类: 80, 精灵: 10, 半精灵: 8, 兽人: 0, 矮人: 2 },
  修道院: { 人类: 85, 精灵: 10, 半精灵: 5, 兽人: 0, 矮人: 0 },
};

// ═══════════════════════════════════════════════════════════════
// 预设身份池（用于特定场景）
// ═══════════════════════════════════════════════════════════════

const 预设身份池 = {
  村庄: ['农家女', '村长之女', '工匠之女', '普通人'],
  商队: ['商人之女', '佣人', '普通人', '低阶冒险者'],
  城镇: ['商人之女', '城主之女', '工匠之女', '低阶冒险者', '见习法师'],
  城市: ['贵族', '城主之女', '女骑士', '低阶冒险者', '见习法师', '商人之女'],
  要塞: ['女骑士', '女侍卫', '女将军'],
  修道院: ['普通人', '见习法师', '圣女'],
  冒险者营地: ['低阶冒险者', '见习法师', '盗贼', '游侠'],
  贵族庄园: ['贵族', '大贵族', '佣人', '女侍卫'],

  // 稀有身份池
  稀有_战斗: ['女骑士', '女将军', '刺客'],
  稀有_魔法: ['高阶法师', '圣女'],
  稀有_贵族: ['公主', '大贵族', '女王'],
};

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 女性随机配置, 初始化女性随机配置, 预设种族权重, 预设身份池 };

export default 女性随机配置;
```


src\config\formulas.js
```js
// ═══════════════════════════════════════════════════════════════
// config/formulas.js
// 公式配置 - 定义所有游戏计算公式
// ═══════════════════════════════════════════════════════════════

/**
 * 初始化默认公式配置
 * @param 公式引擎 - 公式引擎实例
 */
function 初始化公式配置(公式引擎) {
  // ═══════════════════════════════════════════════════════════════
  // 常量设置
  // ═══════════════════════════════════════════════════════════════

  公式引擎.批量设置常量({
    // ─── 基础常量 ───
    基础臣服度增加: 5,
    基础淫乱度增加: 5,
    调教基础效率: 5,

    // ─── 繁殖系统常量 ───
    冠军生育消耗: 100,
    喽啰生育消耗: 100,
    喽啰生育基础产出: 10,
    每点价值产出喽啰: 0.1, // 每10点产1喽啰
    生育淫乱度增加: 8,
    冠军属性随机浮动范围: 5,

    // ─── 战斗系统常量 ───
    基础存活率: 0.8,
    士气基础值: 50,
    士气每周衰减: 5,
    冠军力量战力系数: 20, // 力量/20 转化为战力
    士气系数基数: 1.1,
    士气系数偏移: 20,
    士气系数除数: 10,
    士气系数幂偏移: 10,

    // ─── 战斗结果阈值 ───
    战力比_溃败上限: 0.5,
    战力比_惨败上限: 0.8,
    战力比_惜败上限: 1.0,
    战力比_险胜上限: 1.2,
    战力比_小胜上限: 1.5,
    战力比_大胜上限: 2.0,

    // ─── 战斗存活率 ───
    存活率_溃败: 0.2,
    存活率_惨败: 0.4,
    存活率_惜败: 0.6,
    存活率_险胜: 0.7,
    存活率_小胜: 0.85,
    存活率_大胜: 0.95,
    存活率_碾压: 1.0,

    // ─── 战斗士气变化 ───
    士气变化_溃败: -50,
    士气变化_惨败: -30,
    士气变化_惜败: -10,
    士气变化_险胜: 5,
    士气变化_小胜: 10,
    士气变化_大胜: 15,
    士气变化_碾压: 20,

    // ─── 战斗俘获保底 ───
    俘获保底_险胜: 1,
    俘获保底_小胜: 2,
    俘获保底_大胜: 3,

    // ─── 冠军损失概率 ───
    冠军负伤概率_惜败: 0.15,
    冠军负伤概率_惨败: 0.3,
    冠军负伤概率_溃败: 0.5,
    冠军负伤系数: 0.5, // (1 - 存活率) * 此系数
    冠军阵亡概率_严重溃败: 0.05,
    冠军阵亡概率_完全溃败: 0.1,
    冠军阵亡战力比阈值: 0.3,

    // ─── 情报系统常量 ───
    情报满值: 100,
    情报衰减值: 5,
    情报最低保留: 10,
    情报阶段_详尽阈值: 80,
    情报阶段_充分阈值: 50,
    情报阶段_初步阈值: 25,

    // ─── 情报战力估值系数 ───
    战力估值_下限起始: 0.2,
    战力估值_下限终点: 1.0,
    战力估值_上限起始: 5.0,
    战力估值_上限终点: 1.0,

    // ─── 侦察常量 ───
    潜入侦察基础情报: 20,
    直接侦察基础情报: 15,
    遭遇战概率: 0.1,
    潜入暴露基数: 200, // 暴露概率 = 淫乱度 / 此值
    潜入淫乱度增加: 2,
    潜入劝诱暴露概率: 0.3,
    潜入劝诱成功率除数: 2.5,

    // ─── 锁定目标常量 ───
    锁定系数_情报偏移: 25,
    锁定系数_除数: 100,

    // ─── 泌乳常量 ───
    泌乳阈值: 25,
    泌乳淫乱度增加: 3,
    泌乳产量偏移: 45,
    泌乳产量除数: 20,

    // ─── 调教任务常量 ───
    调教智力系数: 25,
    调教基础增加: 5,
    惩戒基础臣服度: 8,
    惩戒力量系数_臣服度: 10,
    惩戒基础淫乱度: 12,
    惩戒力量系数_淫乱度: 15,

    // ─── 劝慰任务常量 ───
    劝慰基础臣服度: 10,
    劝慰同种族加成: 1.5,
    劝慰同身份加成: 1.3,

    // ─── 提振士气常量 ───
    提振士气基础值: 15,
    提振士气淫乱度系数: 50,
    提振士气价值系数: 200,
    提振士气淫乱度增加: 5,

    // ─── 训练常量 ───
    训练基础战力: 2,
    训练力量系数: 20,

    // ─── 任务臣服度阈值 ───
    臣服度_归心阈值: 75,
    臣服度_忠诚阈值: 90,
    臣服度_动摇阈值: 25,
    臣服度_顺从阈值: 50,

    // ─── 时间系统常量 ───
    周行动点上限: 3,
    历史记录上限: 100,

    // ─── 法术系统常量 ───
    献祭魔力系数: 100, // 总雌性价值 / 此值 = 魔力获得
    献祭淫乱度阈值: 100,
    强制献祭淫乱度阈值: 80,

    // ─── 法术效果常量 ───
    催化调教倍率: 2,
    战嚎祝福战力加成: 0.3,
    铁壁守护存活率加成: 0.2,
    急行军令行动点: 1,
    魔眼侦察情报增量: 30,
    真视之眼情报增量: 100,
    心灵探知锁定数量: 1,
    意志粉碎臣服度: 50,
    淫堕催化淫乱度: 50,
    双重催化臣服度: 30,
    双重催化淫乱度: 30,
    净化之光淫乱度减少: 30,
    孕力回复雌性价值: 100,
    士气鼓舞增加量: 20,
    狂战祝福战力倍率: 2,
    丰饶祝福产量倍率: 2,
    繁殖祝福产出倍率: 2,
    命运改写价值提升比例: 0.5,

    // ─── 商品效果常量 ───
    祝福水晶基数: 2000,
    祝福水晶淫乱度偏移: 20,

    // ─── 休整常量 ───
    休整淫乱度降低: 5,

    // ─── 属性阶段阈值 ───
    淫乱度_完全淫堕: 100,
    淫乱度_淫堕期: 75,
    淫乱度_渴求期: 50,
    淫乱度_泌乳期: 25,

    // ─── 士气阶段阈值 ───
    士气_狂热阈值: 80,
    士气_高涨阈值: 60,
    士气_正常阈值: 40,
    士气_低迷阈值: 20,

    // ─── 士气战力系数 ───
    士气系数_狂热: 1.5,
    士气系数_高涨: 1.25,
    士气系数_正常: 1.0,
    士气系数_低迷: 0.75,
    士气系数_崩溃: 0.5,

    // ─── 经验与等级常量 ───
    升级经验系数: 100, // 升级所需 = 当前等级 * 此值

    // ─── 冠军属性等级配置 ───
    属性等级_弱小_基础: 5,
    属性等级_弱小_浮动: 3,
    属性等级_普通_基础: 10,
    属性等级_普通_浮动: 5,
    属性等级_精英_基础: 20,
    属性等级_精英_浮动: 5,
    属性等级_传奇_基础: 35,
    属性等级_传奇_浮动: 10,

    // ─── 默认属性范围 ───
    默认属性_最小: 5,
    默认属性_最大: 20,

    // ─── 喽啰维护常量 ───
    喽啰维护除数: 50, // 每50喽啰消耗1单位资源
  });

  // ═══════════════════════════════════════════════════════════════
  // 战斗相关公式
  // ═══════════════════════════════════════════════════════════════

  // ─── 士气系数 ───
  公式引擎.注册公式(
    '士气系数',
    ({ 士气 }, 常量) => {
      const 基数 = 常量.士气系数基数 ?? 1.1;
      const 偏移 = 常量.士气系数偏移 ?? 20;
      const 除数 = 常量.士气系数除数 ?? 10;
      const 幂偏移 = 常量.士气系数幂偏移 ?? 10;
      return Math.pow(基数, (士气 + 偏移) / 除数 - 幂偏移);
    },
    {
      描述: '根据士气计算战斗力系数',
      参数说明: { 士气: '当前士气值 (0-100)' },
      分类: '战斗',
      公式文本: '1.1^((士气+20)/10-10)',
    },
  );

  // ─── 部曲战力 ───
  公式引擎.注册公式(
    '部曲战力',
    ({ 有效喽啰数, 冠军力量, 武装战斗力, 士气 }, 常量) => {
      const 士气系数 = 公式引擎.计算('士气系数', { 士气 });
      const 力量系数 = 常量.冠军力量战力系数 ?? 20;
      const 基础战力 = (有效喽啰数 + Math.floor(冠军力量 / 力量系数)) * (武装战斗力 / 100);
      return 基础战力 * 士气系数;
    },
    {
      描述: '计算单个部曲的战斗力',
      参数说明: {
        有效喽啰数: '分配给该冠军的有效喽啰数量（不超过统帅上限）',
        冠军力量: '冠军的力量属性',
        武装战斗力: '喽啰的武装战斗力百分比',
        士气: '当前士气值',
      },
      分类: '战斗',
      公式文本: '(有效喽啰数 + 力量/20) × 武装战斗力% × 士气系数',
    },
  );

  // ─── 战力估值偏差 ───
  公式引擎.注册公式(
    '战力估值偏差',
    ({ 情报进度 }, 常量) => {
      const n = 情报进度;
      const 下限起始 = 常量.战力估值_下限起始 ?? 0.2;
      const 下限终点 = 常量.战力估值_下限终点 ?? 1.0;
      const 上限起始 = 常量.战力估值_上限起始 ?? 5.0;
      const 上限终点 = 常量.战力估值_上限终点 ?? 1.0;

      return {
        下限系数: 下限起始 + ((下限终点 - 下限起始) * n) / 100,
        上限系数: 上限起始 - ((上限起始 - 上限终点) * n) / 100,
      };
    },
    {
      描述: '根据情报进度计算敌方战力估值的误差范围',
      参数说明: { 情报进度: '对目标的情报进度 (0-100)' },
      分类: '战斗',
      公式文本: '下限=0.2+0.8n/100, 上限=5-4n/100',
    },
  );

  // ─── 战斗损失率 ───
  公式引擎.注册公式(
    '战斗损失率',
    ({ 战力比 }, 常量) => {
      const 溃败 = 常量.战力比_溃败上限 ?? 0.5;
      const 惨败 = 常量.战力比_惨败上限 ?? 0.8;
      const 惜败 = 常量.战力比_惜败上限 ?? 1.0;
      const 险胜 = 常量.战力比_险胜上限 ?? 1.2;
      const 小胜 = 常量.战力比_小胜上限 ?? 1.5;
      const 大胜 = 常量.战力比_大胜上限 ?? 2.0;

      if (战力比 >= 大胜) return 0;
      if (战力比 >= 小胜) return 1 - (常量.存活率_大胜 ?? 0.95);
      if (战力比 >= 险胜) return 1 - (常量.存活率_小胜 ?? 0.85);
      if (战力比 >= 惜败) return 1 - (常量.存活率_险胜 ?? 0.7);
      if (战力比 >= 惨败) return 1 - (常量.存活率_惜败 ?? 0.6);
      if (战力比 >= 溃败) return 1 - (常量.存活率_惨败 ?? 0.4);
      return 1 - (常量.存活率_溃败 ?? 0.2);
    },
    {
      描述: '根据战力比计算己方损失率',
      参数说明: { 战力比: '我方战力/敌方战力' },
      分类: '战斗',
    },
  );

  // ─── 战斗士气变化 ───
  公式引擎.注册公式(
    '战斗士气变化',
    ({ 战力比 }, 常量) => {
      const 大胜 = 常量.战力比_大胜上限 ?? 2.0;
      const 小胜 = 常量.战力比_小胜上限 ?? 1.5;
      const 险胜 = 常量.战力比_险胜上限 ?? 1.2;
      const 惜败 = 常量.战力比_惜败上限 ?? 1.0;
      const 惨败 = 常量.战力比_惨败上限 ?? 0.8;
      const 溃败 = 常量.战力比_溃败上限 ?? 0.5;

      if (战力比 >= 大胜) return 常量.士气变化_碾压 ?? 20;
      if (战力比 >= 小胜) return 常量.士气变化_大胜 ?? 15;
      if (战力比 >= 险胜) return 常量.士气变化_小胜 ?? 10;
      if (战力比 >= 惜败) return 常量.士气变化_险胜 ?? 5;
      if (战力比 >= 惨败) return 常量.士气变化_惜败 ?? -10;
      if (战力比 >= 溃败) return 常量.士气变化_惨败 ?? -30;
      return 常量.士气变化_溃败 ?? -50;
    },
    {
      描述: '根据战斗结果计算士气变化',
      参数说明: {
        战力比: '我方战力/敌方战力',
      },
      分类: '战斗',
    },
  );

  // ─── 冠军负伤概率 ───
  公式引擎.注册公式(
    '冠军负伤概率',
    ({ 战力比, 已负伤 }, 常量) => {
      if (已负伤) return 0;

      const 小胜 = 常量.战力比_小胜上限 ?? 1.5;
      const 惜败 = 常量.战力比_惜败上限 ?? 1.0;
      const 惨败 = 常量.战力比_惨败上限 ?? 0.8;
      const 溃败 = 常量.战力比_溃败上限 ?? 0.5;

      if (战力比 >= 小胜) return 0;
      if (战力比 >= 惜败) return 0.05;
      if (战力比 >= 惨败) return 常量.冠军负伤概率_惜败 ?? 0.15;
      if (战力比 >= 溃败) return 常量.冠军负伤概率_惨败 ?? 0.3;
      return 常量.冠军负伤概率_溃败 ?? 0.5;
    },
    {
      描述: '计算冠军在战斗中负伤的概率',
      参数说明: {
        战力比: '我方战力/敌方战力',
        已负伤: '冠军是否已经处于负伤状态',
      },
      分类: '战斗',
    },
  );

  // ─── 冠军阵亡概率 ───
  公式引擎.注册公式(
    '冠军阵亡概率',
    ({ 战力比, 已负伤 }, 常量) => {
      const 溃败 = 常量.战力比_溃败上限 ?? 0.5;
      const 阵亡阈值 = 常量.冠军阵亡战力比阈值 ?? 0.3;

      let 基础概率 = 0;

      if (战力比 >= 溃败) {
        基础概率 = 0;
      } else if (战力比 >= 阵亡阈值) {
        基础概率 = 常量.冠军阵亡概率_严重溃败 ?? 0.05;
      } else {
        基础概率 = 常量.冠军阵亡概率_完全溃败 ?? 0.1;
      }

      return 已负伤 ? 基础概率 * 2 : 基础概率;
    },
    {
      描述: '计算冠军在战斗中阵亡的概率',
      参数说明: {
        战力比: '我方战力/敌方战力',
        已负伤: '冠军是否处于负伤状态',
      },
      分类: '战斗',
    },
  );

  // ═══════════════════════════════════════════════════════════════
  // 任务效率公式
  // ═══════════════════════════════════════════════════════════════

  // ─── 调教效率 ───
  公式引擎.注册公式(
    '调教效率',
    ({ 智力 }, 常量) => {
      const 系数 = 常量.调教智力系数 ?? 25;
      const 基础 = 常量.调教基础增加 ?? 5;
      return 基础 * (智力 / 系数) + 基础;
    },
    {
      描述: '计算调教任务的臣服度增加量',
      参数说明: { 智力: '冠军的智力属性' },
      分类: '任务',
      公式文本: '5 × (智力/25) + 5',
    },
  );

  // ─── 惩戒效率 ───
  公式引擎.注册公式(
    '惩戒效率',
    ({ 力量 }, 常量) => {
      const 基础臣服度 = 常量.惩戒基础臣服度 ?? 8;
      const 臣服度系数 = 常量.惩戒力量系数_臣服度 ?? 10;
      const 基础淫乱度 = 常量.惩戒基础淫乱度 ?? 12;
      const 淫乱度系数 = 常量.惩戒力量系数_淫乱度 ?? 15;

      return {
        臣服度增加: 基础臣服度 + Math.floor(力量 / 臣服度系数),
        淫乱度增加: 基础淫乱度 + Math.floor(力量 / 淫乱度系数),
      };
    },
    {
      描述: '计算惩戒任务的臣服度和淫乱度增加量',
      参数说明: { 力量: '冠军的力量属性' },
      分类: '任务',
      公式文本: '臣服度=8+力量/10, 淫乱度=12+力量/15',
    },
  );

  // ─── 劝慰效率 ───
  公式引擎.注册公式(
    '劝慰效率',
    ({ 同种族, 同身份 }, 常量) => {
      let 基础值 = 常量.劝慰基础臣服度 ?? 10;
      const 种族加成 = 常量.劝慰同种族加成 ?? 1.5;
      const 身份加成 = 常量.劝慰同身份加成 ?? 1.3;

      if (同种族) {
        基础值 *= 种族加成;
      }
      if (同身份) {
        基础值 *= 身份加成;
      }

      return Math.floor(基础值);
    },
    {
      描述: '计算劝慰任务的臣服度增加量',
      参数说明: {
        同种族: '负责人与目标是否同种族',
        同身份: '负责人与目标是否同身份',
      },
      分类: '任务',
      公式文本: '基础10 × 同种族1.5 × 同身份1.3',
    },
  );

  // ─── 潜入侦察效率 ───
  公式引擎.注册公式(
    '潜入侦察效率',
    ({ 臣服度, 淫乱度 }, 常量) => {
      const 臣服度系数 = 常量.臣服度_顺从阈值 ?? 50;
      const 暴露基数 = 常量.潜入暴露基数 ?? 200;
      return 1 * (臣服度 / 臣服度系数) * (1 - 淫乱度 / 暴露基数);
    },
    {
      描述: '计算潜入侦察的效率系数',
      参数说明: {
        臣服度: '母畜的臣服度',
        淫乱度: '母畜的淫乱度',
      },
      分类: '任务',
      公式文本: '1 × (臣服度/50) × (1 - 淫乱度/200)',
    },
  );

  // ─── 潜入暴露概率 ───
  公式引擎.注册公式(
    '潜入暴露概率',
    ({ 淫乱度 }, 常量) => {
      const 基数 = 常量.潜入暴露基数 ?? 200;
      return 淫乱度 / 基数;
    },
    {
      描述: '计算潜入任务的身份暴露概率',
      参数说明: { 淫乱度: '母畜的淫乱度' },
      分类: '任务',
      公式文本: '淫乱度/200',
    },
  );

  // ─── 直接侦察效率 ───
  公式引擎.注册公式(
    '直接侦察效率',
    ({ 敏捷 }, 常量) => {
      const 系数 = 常量.调教智力系数 ?? 25;
      return 1 * (敏捷 / 系数);
    },
    {
      描述: '计算直接侦察的效率系数',
      参数说明: { 敏捷: '冠军的敏捷属性' },
      分类: '任务',
      公式文本: '1 × (敏捷/25)',
    },
  );

  // ─── 提振士气效率 ───
  公式引擎.注册公式(
    '提振士气效率',
    ({ 淫乱度, 总雌性价值 }, 常量) => {
      const 基础值 = 常量.提振士气基础值 ?? 15;
      const 淫乱度系数 = 常量.提振士气淫乱度系数 ?? 50;
      const 价值系数 = 常量.提振士气价值系数 ?? 200;
      return 基础值 * (淫乱度 / 淫乱度系数) * (总雌性价值 / 价值系数);
    },
    {
      描述: '计算提振士气任务的士气增加量',
      参数说明: {
        淫乱度: '母畜的淫乱度',
        总雌性价值: '母畜的总雌性价值',
      },
      分类: '任务',
      公式文本: '15 × (淫乱度/50) × (总雌性价值/200)',
    },
  );

  // ─── 潜入劝诱成功率 ───
  公式引擎.注册公式(
    '潜入劝诱成功率',
    ({ 负责人价值, 目标价值 }, 常量) => {
      const 除数 = 常量.潜入劝诱成功率除数 ?? 2.5;
      return Math.min(1, 负责人价值 / 目标价值 / 除数);
    },
    {
      描述: '计算潜入劝诱的成功概率',
      参数说明: {
        负责人价值: '执行任务母畜的总雌性价值',
        目标价值: '目标的雌性价值',
      },
      分类: '任务',
      公式文本: 'min(1, 负责人价值/目标价值/2.5)',
    },
  );

  // ─── 训练效率 ───
  公式引擎.注册公式(
    '训练效率',
    ({ 力量 }, 常量) => {
      const 基础 = 常量.训练基础战力 ?? 2;
      const 系数 = 常量.训练力量系数 ?? 20;
      return 基础 + Math.floor(力量 / 系数);
    },
    {
      描述: '计算训练喽啰任务的战力提升',
      参数说明: { 力量: '冠军的力量属性' },
      分类: '任务',
      公式文本: '2 + 力量/20',
    },
  );

  // ═══════════════════════════════════════════════════════════════
  // 资源产出公式
  // ═══════════════════════════════════════════════════════════════

  // ─── 泌乳产量 ───
  公式引擎.注册公式(
    '泌乳产量',
    ({ 淫乱度 }, 常量) => {
      const 阈值 = 常量.泌乳阈值 ?? 25;
      const 偏移 = 常量.泌乳产量偏移 ?? 45;
      const 除数 = 常量.泌乳产量除数 ?? 20;

      if (淫乱度 < 阈值) return 0;
      return Math.floor((淫乱度 + 偏移) / 除数);
    },
    {
      描述: '计算母畜的每周母乳产量',
      参数说明: { 淫乱度: '母畜的淫乱度 (需≥25才能泌乳)' },
      分类: '资源',
      公式文本: 'floor((淫乱度+45)/20), 淫乱度<25时为0',
    },
  );

  // ─── 总泌乳产量 ───
  公式引擎.注册公式(
    '总泌乳产量',
    ({ 母畜列表 }) => {
      let 总产量 = 0;
      for (const 母畜 of 母畜列表) {
        const 淫乱度 = 母畜.获取属性?.('淫乱度') ?? 母畜.淫乱度 ?? 0;
        总产量 += 公式引擎.计算('泌乳产量', { 淫乱度 });
      }
      return 总产量;
    },
    {
      描述: '计算所有母畜的总泌乳产量',
      参数说明: { 母畜列表: '母畜实体数组' },
      分类: '资源',
    },
  );

  // ─── 祝福水晶效果 ───
  公式引擎.注册公式(
    '祝福水晶效果',
    ({ 淫乱度 }, 常量) => {
      const 基数 = 常量.祝福水晶基数 ?? 2000;
      const 偏移 = 常量.祝福水晶淫乱度偏移 ?? 20;
      return Math.floor(基数 / (淫乱度 + 偏移));
    },
    {
      描述: '计算祝福水晶恢复的雌性价值',
      参数说明: { 淫乱度: '目标母畜的淫乱度' },
      分类: '资源',
      公式文本: 'floor(2000/(淫乱度+20))',
    },
  );

  // ─── 献祭魔力获得 ───
  公式引擎.注册公式(
    '献祭魔力获得',
    ({ 总雌性价值, 淫乱度 }, 常量) => {
      const 系数 = 常量.献祭魔力系数 ?? 100;
      const 完全淫堕 = 常量.淫乱度_完全淫堕 ?? 100;
      const 效率 = 淫乱度 >= 完全淫堕 ? 1.0 : 淫乱度 / 完全淫堕;
      return Math.floor((总雌性价值 / 系数) * 效率);
    },
    {
      描述: '计算献祭母畜获得的魔力',
      参数说明: {
        总雌性价值: '母畜的总雌性价值',
        淫乱度: '母畜的淫乱度',
      },
      分类: '资源',
      公式文本: 'floor(总雌性价值/100 × 效率), 完全淫堕效率=1',
    },
  );

  // ─── 喽啰维护消耗 ───
  公式引擎.注册公式(
    '喽啰维护消耗',
    ({ 喽啰总数 }, 常量) => {
      const 除数 = 常量.喽啰维护除数 ?? 50;
      return Math.floor(喽啰总数 / 除数);
    },
    {
      描述: '计算喽啰的每周维护消耗',
      参数说明: { 喽啰总数: '喽啰总数量' },
      分类: '资源',
      公式文本: 'floor(喽啰总数/50)',
    },
  );

  // ═══════════════════════════════════════════════════════════════
  // 繁殖相关公式
  // ═══════════════════════════════════════════════════════════════

  // ─── 冠军属性生成 ───
  公式引擎.注册公式(
    '冠军属性生成',
    ({ 总雌性价值, 效率系数, 随机浮动 }) => {
      const 基础值 = 总雌性价值 / 10;
      return Math.max(1, Math.round((基础值 + 随机浮动) * 效率系数));
    },
    {
      描述: '计算生育冠军的单项属性值',
      参数说明: {
        总雌性价值: '母畜的总雌性价值',
        效率系数: '身份对应的属性效率系数',
        随机浮动: '随机浮动值 (通常±5)',
      },
      分类: '繁殖',
      公式文本: 'max(1, round((总雌性价值/10 + 随机浮动) × 效率系数))',
    },
  );

  // ─── 冠军属性预估范围 ───
  公式引擎.注册公式(
    '冠军属性预估范围',
    ({ 总雌性价值, 效率系数, 随机浮动范围 }, 常量) => {
      const 基础值 = 总雌性价值 / 10;
      const 范围 = 随机浮动范围 ?? 常量.冠军属性随机浮动范围 ?? 5;

      return {
        最小: Math.max(1, Math.round((基础值 - 范围) * 效率系数)),
        最大: Math.round((基础值 + 范围) * 效率系数),
        期望: Math.round(基础值 * 效率系数),
      };
    },
    {
      描述: '预估生育冠军的属性范围',
      参数说明: {
        总雌性价值: '母畜的总雌性价值',
        效率系数: '身份对应的属性效率系数',
        随机浮动范围: '随机浮动范围（默认5）',
      },
      分类: '繁殖',
    },
  );

  // ─── 喽啰产出计算 ───
  公式引擎.注册公式(
    '喽啰产出计算',
    ({ 剩余雌性价值, 标准消耗, 标准产出 }, 常量) => {
      const 消耗 = 标准消耗 ?? 常量.喽啰生育消耗 ?? 100;
      const 产出 = 标准产出 ?? 常量.喽啰生育基础产出 ?? 10;
      const 每点产出 = 常量.每点价值产出喽啰 ?? 0.1;

      if (剩余雌性价值 >= 消耗) {
        return {
          实际消耗: 消耗,
          实际产出: 产出,
        };
      } else {
        return {
          实际消耗: 剩余雌性价值,
          实际产出: Math.floor(剩余雌性价值 * 每点产出),
        };
      }
    },
    {
      描述: '计算生育喽啰的实际消耗和产出',
      参数说明: {
        剩余雌性价值: '母畜的剩余雌性价值',
        标准消耗: '标准消耗量（默认100）',
        标准产出: '标准产出量（默认10）',
      },
      分类: '繁殖',
    },
  );

  // ─── 生育行动点计算 ───
  公式引擎.注册公式(
    '生育行动点计算',
    ({ 臣服度, 任务类型 }, 常量) => {
      const 动摇阈值 = 常量.臣服度_动摇阈值 ?? 25;
      if (任务类型 === '冠军') {
        return 臣服度 >= 动摇阈值 ? 1 : 2;
      } else if (任务类型 === '喽啰') {
        return 臣服度 >= 动摇阈值 ? 0 : 1;
      }
      return 1;
    },
    {
      描述: '根据臣服度计算生育任务的行动点消耗',
      参数说明: {
        臣服度: '母畜的臣服度',
        任务类型: '生育任务类型（冠军/喽啰）',
      },
      分类: '繁殖',
    },
  );

  // ═══════════════════════════════════════════════════════════════
  // 情报相关公式
  // ═══════════════════════════════════════════════════════════════

  // ─── 锁定目标值 ───
  公式引擎.注册公式(
    '锁定目标值',
    ({ 负责人系数, 情报进度 }, 常量) => {
      const 偏移 = 常量.锁定系数_情报偏移 ?? 25;
      const 除数 = 常量.锁定系数_除数 ?? 100;
      return (负责人系数 * (情报进度 + 偏移)) / 除数;
    },
    {
      描述: '计算侦察任务锁定高价值目标的数值',
      参数说明: {
        负责人系数: '负责人的相关系数（如总雌性价值/100或敏捷/10）',
        情报进度: '对目标的情报进度',
      },
      分类: '情报',
      公式文本: '负责人系数 × (情报进度+25) / 100',
    },
  );

  // ─── 锁定目标解析 ───
  公式引擎.注册公式(
    '锁定目标解析',
    ({ 锁定值 }) => {
      return {
        必定锁定数: Math.floor(锁定值 / 100),
        额外锁定概率: (锁定值 % 100) / 100,
      };
    },
    {
      描述: '解析锁定值为必定锁定数和额外锁定概率',
      参数说明: { 锁定值: '由锁定目标值公式计算得出' },
      分类: '情报',
    },
  );

  // ─── 情报衰减 ───
  公式引擎.注册公式(
    '情报衰减',
    ({ 当前进度, 上次侦察周次, 当前周次, 衰减值, 最低保留 }, 常量) => {
      const 间隔周次 = 当前周次 - (上次侦察周次 ?? 0);

      if (间隔周次 <= 1) {
        return 当前进度;
      }

      const 实际衰减 = (衰减值 ?? 常量.情报衰减值 ?? 5) * (间隔周次 - 1);
      return Math.max(最低保留 ?? 常量.情报最低保留 ?? 10, 当前进度 - 实际衰减);
    },
    {
      描述: '计算情报的自然衰减',
      参数说明: {
        当前进度: '当前情报进度',
        上次侦察周次: '上次进行侦察的周次',
        当前周次: '当前周次',
        衰减值: '每周衰减值（默认5）',
        最低保留: '最低保留值（默认10）',
      },
      分类: '情报',
    },
  );

  // ─── 情报阶段判定 ───
  公式引擎.注册公式(
    '情报阶段判定',
    ({ 情报进度 }, 常量) => {
      const 详尽 = 常量.情报阶段_详尽阈值 ?? 80;
      const 充分 = 常量.情报阶段_充分阈值 ?? 50;
      const 初步 = 常量.情报阶段_初步阈值 ?? 25;

      if (情报进度 >= 详尽) {
        return { 名称: '详尽', 等级: 4, 描述: '情报非常准确，误差极小' };
      }
      if (情报进度 >= 充分) {
        return { 名称: '充分', 等级: 3, 描述: '情报较为可靠，有一定误差' };
      }
      if (情报进度 >= 初步) {
        return { 名称: '初步', 等级: 2, 描述: '有基本了解，误差较大' };
      }
      return { 名称: '模糊', 等级: 1, 描述: '几乎一无所知，估计极不准确' };
    },
    {
      描述: '根据情报进度判定情报阶段',
      参数说明: { 情报进度: '对目标的情报进度 (0-100)' },
      分类: '情报',
    },
  );

  // ═══════════════════════════════════════════════════════════════
  // 属性阶段公式
  // ═══════════════════════════════════════════════════════════════

  // ─── 臣服度阶段判定 ───
  公式引擎.注册公式(
    '臣服度阶段判定',
    ({ 臣服度 }, 常量) => {
      const 忠诚 = 常量.臣服度_忠诚阈值 ?? 90;
      const 归心 = 常量.臣服度_归心阈值 ?? 75;
      const 顺从 = 常量.臣服度_顺从阈值 ?? 50;
      const 动摇 = 常量.臣服度_动摇阈值 ?? 25;

      if (臣服度 >= 忠诚) {
        return { 名称: '忠诚期', 等级: 5, 解锁: ['潜入侦察', '潜入劝诱'] };
      }
      if (臣服度 >= 归心) {
        return { 名称: '归心期', 等级: 4, 解锁: ['劝慰', '提振士气'] };
      }
      if (臣服度 >= 顺从) {
        return { 名称: '顺从期', 等级: 3, 解锁: ['生育冠军'] };
      }
      if (臣服度 >= 动摇) {
        return { 名称: '动摇期', 等级: 2, 解锁: ['生育喽啰'] };
      }
      return { 名称: '抗拒期', 等级: 1, 解锁: [] };
    },
    {
      描述: '根据臣服度判定阶段及解锁任务',
      参数说明: { 臣服度: '母畜的臣服度' },
      分类: '属性',
    },
  );

  // ─── 淫乱度阶段判定 ───
  公式引擎.注册公式(
    '淫乱度阶段判定',
    ({ 淫乱度 }, 常量) => {
      const 完全淫堕 = 常量.淫乱度_完全淫堕 ?? 100;
      const 淫堕期 = 常量.淫乱度_淫堕期 ?? 75;
      const 渴求期 = 常量.淫乱度_渴求期 ?? 50;
      const 泌乳期 = 常量.淫乱度_泌乳期 ?? 25;

      if (淫乱度 >= 完全淫堕) {
        return { 名称: '完全淫堕', 等级: 5, 解锁: ['献祭'] };
      }
      if (淫乱度 >= 淫堕期) {
        return { 名称: '淫堕期', 等级: 4, 解锁: ['极限泌乳'] };
      }
      if (淫乱度 >= 渴求期) {
        return { 名称: '渴求期', 等级: 3, 解锁: ['增强泌乳'] };
      }
      if (淫乱度 >= 泌乳期) {
        return { 名称: '泌乳期', 等级: 2, 解锁: ['泌乳'] };
      }
      return { 名称: '常态期', 等级: 1, 解锁: [] };
    },
    {
      描述: '根据淫乱度判定阶段及解锁能力',
      参数说明: { 淫乱度: '母畜的淫乱度' },
      分类: '属性',
    },
  );

  // ─── 士气阶段判定 ───
  公式引擎.注册公式(
    '士气阶段判定',
    ({ 士气 }, 常量) => {
      const 狂热 = 常量.士气_狂热阈值 ?? 80;
      const 高涨 = 常量.士气_高涨阈值 ?? 60;
      const 正常 = 常量.士气_正常阈值 ?? 40;
      const 低迷 = 常量.士气_低迷阈值 ?? 20;

      if (士气 >= 狂热) {
        return { 名称: '狂热', 等级: 5, 战力系数: 常量.士气系数_狂热 ?? 1.5 };
      }
      if (士气 >= 高涨) {
        return { 名称: '高涨', 等级: 4, 战力系数: 常量.士气系数_高涨 ?? 1.25 };
      }
      if (士气 >= 正常) {
        return { 名称: '正常', 等级: 3, 战力系数: 常量.士气系数_正常 ?? 1.0 };
      }
      if (士气 >= 低迷) {
        return { 名称: '低迷', 等级: 2, 战力系数: 常量.士气系数_低迷 ?? 0.75 };
      }
      return { 名称: '崩溃', 等级: 1, 战力系数: 常量.士气系数_崩溃 ?? 0.5 };
    },
    {
      描述: '根据士气判定阶段和战力系数',
      参数说明: { 士气: '军队士气值' },
      分类: '属性',
    },
  );

  // ═══════════════════════════════════════════════════════════════
  // 经济相关公式
  // ═══════════════════════════════════════════════════════════════

  // ─── 武装成本计算 ───
  公式引擎.注册公式(
    '武装成本计算',
    ({ 武装等级, 数量 }) => {
      const 单位成本映射 = {
        低级武装: { 单价: 0.1, 战斗力: 110 },
        中级武装: { 单价: 0.25, 战斗力: 130 },
        高级武装: { 单价: 1, 战斗力: 180 },
        精英武装: { 单价: 10, 战斗力: 250 },
      };

      const 配置 = 单位成本映射[武装等级] ?? { 单价: 0.1, 战斗力: 110 };

      return {
        总成本: Math.ceil(配置.单价 * 数量),
        单位成本: 配置.单价,
        战斗力提升: 配置.战斗力,
      };
    },
    {
      描述: '计算武装喽啰的成本',
      参数说明: {
        武装等级: '目标武装等级',
        数量: '武装数量',
      },
      分类: '经济',
    },
  );

  // ─── 商品性价比 ───
  公式引擎.注册公式(
    '商品性价比',
    ({ 效果值, 价格 }) => {
      return 价格 > 0 ? 效果值 / 价格 : Infinity;
    },
    {
      描述: '计算商品的性价比',
      参数说明: {
        效果值: '商品效果的数值化评估',
        价格: '商品价格',
      },
      分类: '经济',
    },
  );

  // ═══════════════════════════════════════════════════════════════
  // 通用工具公式
  // ═══════════════════════════════════════════════════════════════

  // ─── 百分比计算 ───
  公式引擎.注册公式(
    '百分比计算',
    ({ 当前值, 最大值 }) => {
      return 最大值 > 0 ? (当前值 / 最大值) * 100 : 0;
    },
    {
      描述: '计算当前值占最大值的百分比',
      参数说明: {
        当前值: '当前数值',
        最大值: '最大数值',
      },
      分类: '通用',
    },
  );

  // ─── 范围限制 ───
  公式引擎.注册公式(
    '范围限制',
    ({ 值, 最小, 最大 }) => {
      return Math.max(最小 ?? 0, Math.min(最大 ?? Infinity, 值));
    },
    {
      描述: '将值限制在指定范围内',
      参数说明: {
        值: '输入值',
        最小: '最小值（默认0）',
        最大: '最大值（默认无限）',
      },
      分类: '通用',
    },
  );

  // ─── 随机范围 ───
  公式引擎.注册公式(
    '随机范围',
    ({ 最小, 最大 }) => {
      return Math.floor(Math.random() * (最大 - 最小 + 1)) + 最小;
    },
    {
      描述: '生成指定范围的随机整数',
      参数说明: {
        最小: '最小值',
        最大: '最大值',
      },
      分类: '通用',
    },
  );

  // ─── 概率判定 ───
  公式引擎.注册公式(
    '概率判定',
    ({ 概率 }) => {
      return Math.random() < 概率;
    },
    {
      描述: '进行概率判定',
      参数说明: { 概率: '判定概率 (0-1)' },
      分类: '通用',
    },
  );

  // ─── 加权随机选择 ───
  公式引擎.注册公式(
    '加权随机选择',
    ({ 选项列表 }) => {
      const 总权重 = 选项列表.reduce((sum, item) => sum + (item.权重 ?? 1), 0);
      let 随机值 = Math.random() * 总权重;

      for (const 选项 of 选项列表) {
        随机值 -= 选项.权重 ?? 1;
        if (随机值 <= 0) {
          return 选项.值;
        }
      }

      return 选项列表[选项列表.length - 1]?.值;
    },
    {
      描述: '从加权选项中随机选择',
      参数说明: { 选项列表: '加权选项数组 [{ 值, 权重 }, ...]' },
      分类: '通用',
    },
  );

  // ─── 经验升级阈值 ───
  公式引擎.注册公式(
    '经验升级阈值',
    ({ 当前等级 }, 常量) => {
      const 系数 = 常量.升级经验系数 ?? 100;
      return 当前等级 * 系数;
    },
    {
      描述: '计算升级所需经验',
      参数说明: { 当前等级: '当前等级' },
      分类: '通用',
      公式文本: '当前等级 × 100',
    },
  );

  // ─── 升级检查 ───
  公式引擎.注册公式(
    '升级检查',
    ({ 当前经验, 当前等级 }) => {
      const 阈值 = 公式引擎.计算('经验升级阈值', { 当前等级 });
      if (当前经验 >= 阈值) {
        return {
          可升级: true,
          剩余经验: 当前经验 - 阈值,
          新等级: 当前等级 + 1,
        };
      }
      return {
        可升级: false,
        距离升级: 阈值 - 当前经验,
      };
    },
    {
      描述: '检查是否可以升级并返回相关信息',
      参数说明: {
        当前经验: '当前经验值',
        当前等级: '当前等级',
      },
      分类: '通用',
    },
  );
}

// ═══════════════════════════════════════════════════════════════
// 公式分类文档
// ═══════════════════════════════════════════════════════════════

const 公式分类文档 = {
  战斗: {
    描述: '与战斗计算相关的公式',
    包含: ['士气系数', '部曲战力', '战力估值偏差', '战斗损失率', '战斗士气变化', '冠军负伤概率', '冠军阵亡概率'],
  },
  任务: {
    描述: '与任务执行效率相关的公式',
    包含: [
      '调教效率',
      '惩戒效率',
      '劝慰效率',
      '潜入侦察效率',
      '潜入暴露概率',
      '直接侦察效率',
      '提振士气效率',
      '潜入劝诱成功率',
      '训练效率',
    ],
  },
  资源: {
    描述: '与资源产出相关的公式',
    包含: ['泌乳产量', '总泌乳产量', '祝福水晶效果', '献祭魔力获得', '喽啰维护消耗'],
  },
  繁殖: {
    描述: '与生育系统相关的公式',
    包含: ['冠军属性生成', '冠军属性预估范围', '喽啰产出计算', '生育行动点计算'],
  },
  情报: {
    描述: '与情报系统相关的公式',
    包含: ['锁定目标值', '锁定目标解析', '情报衰减', '情报阶段判定'],
  },
  属性: {
    描述: '与属性阶段判定相关的公式',
    包含: ['臣服度阶段判定', '淫乱度阶段判定', '士气阶段判定'],
  },
  经济: {
    描述: '与经济计算相关的公式',
    包含: ['武装成本计算', '商品性价比'],
  },
  通用: {
    描述: '通用工具类公式',
    包含: ['百分比计算', '范围限制', '随机范围', '概率判定', '加权随机选择', '经验升级阈值', '升级检查'],
  },
};

// ═══════════════════════════════════════════════════════════════
// 公式快速参考表
// ═══════════════════════════════════════════════════════════════

const 公式快速参考 = {
  // 战斗
  士气50战力系数: '1.0',
  部曲战力公式: '(喽啰数+力量/20) × 武装% × 士气系数',

  // 任务
  调教臣服度增加: '5×(智力/25)+5',
  潜入效率: '(臣服度/50)×(1-淫乱度/200)',
  暴露概率: '淫乱度/200',
  直接侦察效率: '敏捷/25',
  提振士气: '15×(淫乱度/50)×(总价值/200)',
  劝诱成功率: '负责人价值/目标价值/2.5',

  // 资源
  泌乳产量: '(淫乱度+45)/20, 需淫乱度≥25',
  祝福水晶恢复: '2000/(淫乱度+20)',
  献祭魔力: '总价值/100×效率',

  // 繁殖
  冠军属性: '(总价值/10+随机±5)×效率系数',
  喽啰产出: '100消耗→10产出, 不足100时10点/个',

  // 情报
  锁定值: '系数×(情报+25)/100',
};

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 初始化公式配置, 公式分类文档, 公式快速参考 };

export default 初始化公式配置;
```


src\config\items.js
```js
// ═══════════════════════════════════════════════════════════════
// config/items.js
// 商品配置 - 定义黑市所有商品及其效果
// ═══════════════════════════════════════════════════════════════

/**
 * 初始化默认商品配置
 * @param 商品注册表 - 商品定义注册表实例
 */
function 初始化商品配置(商品注册表) {
  // ═══════════════════════════════════════════════════════════════
  // 商品分类注册
  // ═══════════════════════════════════════════════════════════════

  商品注册表.注册商品分类('武装装备', {
    刷新周期: 1,
    随机刷新: false,
    描述: '用于提升喽啰战斗力的装备',
    排序权重: 100,
  });

  商品注册表.注册商品分类('奴隶商品', {
    刷新周期: 1,
    随机刷新: true,
    描述: '可购买的女性奴隶',
    排序权重: 90,
  });

  商品注册表.注册商品分类('特殊资源', {
    刷新周期: 1,
    随机刷新: false,
    描述: '稀有的特殊道具',
    排序权重: 80,
  });

  商品注册表.注册商品分类('消耗品', {
    刷新周期: 1,
    随机刷新: false,
    描述: '一次性使用的消耗品',
    排序权重: 70,
  });

  商品注册表.注册商品分类('稀有商品', {
    刷新周期: 4,
    随机刷新: true,
    描述: '每4周刷新的稀有商品',
    排序权重: 60,
  });

  // ═══════════════════════════════════════════════════════════════
  // 武装装备类商品
  // ═══════════════════════════════════════════════════════════════

  // ─── 低级装备 ───
  商品注册表.注册商品('破旧兵刃与皮甲残片', {
    分类: '武装装备',
    价格: 1,
    每周限购: Infinity,
    描述: '勉强能用的武器和护甲，聊胜于无',
    效果: {
      类型: '武装升级',
      目标等级: '低级武装',
      战斗力提升: 110, // 战斗力百分比
      每母乳武装数量: 10,
    },
    图标: '🗡️',
  });

  // ─── 中级装备 ───
  商品注册表.注册商品('标准铁剑与链甲套件', {
    分类: '武装装备',
    价格: 1,
    每周限购: Infinity,
    描述: '正规军队的标准装备',
    效果: {
      类型: '武装升级',
      目标等级: '中级武装',
      战斗力提升: 130,
      每母乳武装数量: 4,
    },
    图标: '⚔️',
  });

  // ─── 高级装备 ───
  商品注册表.注册商品('盗取的骑士全装', {
    分类: '武装装备',
    价格: 1,
    每周限购: Infinity,
    描述: '从战场上获取的骑士装备，非常珍贵',
    效果: {
      类型: '武装升级',
      目标等级: '高级武装',
      战斗力提升: 180,
      每母乳武装数量: 1,
    },
    图标: '🛡️',
  });

  // ─── 精英装备 ───
  商品注册表.注册商品('附魔战争装备', {
    分类: '武装装备',
    价格: 10,
    每周限购: 5,
    描述: '带有魔法增强的顶级装备',
    效果: {
      类型: '武装升级',
      目标等级: '精英武装',
      战斗力提升: 250,
      每母乳武装数量: 1,
    },
    稀有度: 3,
    图标: '✨',
  });

  // ═══════════════════════════════════════════════════════════════
  // 特殊资源类商品
  // ═══════════════════════════════════════════════════════════════

  // ─── 祝福水晶 ───
  商品注册表.注册商品('神殿祝福水晶', {
    分类: '特殊资源',
    价格: 25,
    每周限购: 3,
    描述: '神殿中流出的神圣水晶，可恢复雌性价值',
    效果: {
      类型: '祝福水晶',
      计算公式: '2000 / (淫乱度 + 20)',
      说明: '淫乱度越低，恢复效果越好',
    },
    图标: '💎',
  });

  // ─── 净化水晶 ───
  商品注册表.注册商品('神殿净化水晶', {
    分类: '特殊资源',
    价格: 15,
    每周限购: 3,
    描述: '可以净化淫乱的神圣之物',
    效果: {
      类型: '净化水晶',
      淫乱度减少: 10,
    },
    图标: '✝️',
  });

  // ─── 强效净化水晶 ───
  商品注册表.注册商品('大神殿净化水晶', {
    分类: '特殊资源',
    价格: 40,
    每周限购: 1,
    描述: '来自大神殿的强效净化水晶',
    效果: {
      类型: '净化水晶',
      淫乱度减少: 30,
    },
    稀有度: 2,
    图标: '🔮',
  });

  // ─── 魔力水晶 ───
  商品注册表.注册商品('黑暗魔力水晶', {
    分类: '特殊资源',
    价格: 50,
    每周限购: 2,
    描述: '蕴含黑暗魔力的水晶，可为领主补充魔力',
    效果: {
      类型: '魔力水晶',
      魔力恢复: 5,
    },
    稀有度: 2,
    图标: '🖤',
  });

  // ═══════════════════════════════════════════════════════════════
  // 消耗品类商品
  // ═══════════════════════════════════════════════════════════════

  // ─── 调教道具 ───
  商品注册表.注册商品('调教皮鞭', {
    分类: '消耗品',
    价格: 5,
    每周限购: 10,
    描述: '基础调教道具，提升单次调教效率',
    效果: {
      类型: '调教增幅',
      效率加成: 0.5,
      使用次数: 1,
    },
    图标: '🔗',
  });

  商品注册表.注册商品('精制调教工具套装', {
    分类: '消耗品',
    价格: 20,
    每周限购: 3,
    描述: '高级调教道具，大幅提升调教效率',
    效果: {
      类型: '调教增幅',
      效率加成: 1.0,
      使用次数: 3,
    },
    稀有度: 2,
    图标: '⛓️',
  });

  // ─── 催情药剂 ───
  商品注册表.注册商品('低级催情药剂', {
    分类: '消耗品',
    价格: 8,
    每周限购: 5,
    描述: '使用后增加目标母畜淫乱度',
    效果: {
      类型: '属性增加',
      目标属性: '淫乱度',
      增加量: 10,
    },
    图标: '🧪',
  });

  商品注册表.注册商品('高级催情药剂', {
    分类: '消耗品',
    价格: 25,
    每周限购: 2,
    描述: '强力催情药剂',
    效果: {
      类型: '属性增加',
      目标属性: '淫乱度',
      增加量: 25,
    },
    稀有度: 2,
    图标: '💜',
  });

  // ─── 顺从药剂 ───
  商品注册表.注册商品('顺从药剂', {
    分类: '消耗品',
    价格: 12,
    每周限购: 5,
    描述: '使用后增加目标母畜臣服度',
    效果: {
      类型: '属性增加',
      目标属性: '臣服度',
      增加量: 10,
    },
    图标: '💊',
  });

  // ─── 士气鼓舞物 ───
  商品注册表.注册商品('烈酒桶', {
    分类: '消耗品',
    价格: 10,
    每周限购: 5,
    描述: '给喽啰们喝的烈酒，提升士气',
    效果: {
      类型: '士气增加',
      增加量: 10,
    },
    图标: '🍺',
  });

  商品注册表.注册商品('战争号角', {
    分类: '消耗品',
    价格: 30,
    每周限购: 2,
    描述: '激励军队的号角，大幅提升士气',
    效果: {
      类型: '士气增加',
      增加量: 25,
    },
    稀有度: 2,
    图标: '📯',
  });

  // ═══════════════════════════════════════════════════════════════
  // 奴隶商品刷新规则
  // ═══════════════════════════════════════════════════════════════

  商品注册表.注册刷新规则('奴隶商品', (周次, 上下文) => {
    const 商品列表 = [];

    // ─── 低质奴隶（常驻）───
    商品列表.push({
      名称: '债务抵押的农家女',
      分类: '奴隶商品',
      价格: 5,
      每周限购: 3,
      描述: '因家庭债务被卖的普通农家女子',
      效果: {
        类型: '获得母畜',
        总雌性价值范围: [80, 120],
        初始臣服度: 10,
        原身份: '农家女',
        种族: '人类',
      },
      图标: '👩‍🌾',
    });

    商品列表.push({
      名称: '落魄商人之女',
      分类: '奴隶商品',
      价格: 8,
      每周限购: 2,
      描述: '商人破产后沦落的女儿',
      效果: {
        类型: '获得母畜',
        总雌性价值范围: [100, 150],
        初始臣服度: 5,
        原身份: '商人之女',
        种族: '人类',
      },
      图标: '👩‍💼',
    });

    // ─── 中质奴隶（常驻）───
    商品列表.push({
      名称: '破落贵族千金',
      分类: '奴隶商品',
      价格: 15,
      每周限购: 2,
      描述: '家道中落的贵族小姐',
      效果: {
        类型: '获得母畜',
        总雌性价值范围: [150, 200],
        初始臣服度: 0,
        原身份: '贵族',
        种族: '人类',
      },
      稀有度: 2,
      图标: '👸',
    });

    商品列表.push({
      名称: '流浪的女冒险者',
      分类: '奴隶商品',
      价格: 18,
      每周限购: 1,
      描述: '被俘获的低阶女冒险者',
      效果: {
        类型: '获得母畜',
        总雌性价值范围: [180, 250],
        初始臣服度: 0,
        原身份: '低阶冒险者',
        种族: '人类',
      },
      稀有度: 2,
      图标: '🗡️',
    });

    // ─── 每2周随机刷新一个特殊奴隶 ───
    if (周次 % 2 === 0) {
      const 特殊奴隶池 = [
        {
          名称: '精灵族少女',
          价格: 35,
          描述: '罕见的精灵族女性',
          效果: {
            类型: '获得母畜',
            总雌性价值范围: [250, 350],
            初始臣服度: 0,
            原身份: '普通人',
            种族: '精灵',
            特殊标签: ['精灵血脉'],
          },
          稀有度: 3,
          图标: '🧝‍♀️',
        },
        {
          名称: '半兽人女武者',
          价格: 25,
          描述: '拥有野性力量的半兽人',
          效果: {
            类型: '获得母畜',
            总雌性价值范围: [150, 200],
            初始臣服度: 0,
            原身份: '战士',
            种族: '兽人',
            特殊标签: ['野性'],
          },
          稀有度: 2,
          图标: '🐺',
        },
        {
          名称: '被逐出的女见习法师',
          价格: 40,
          描述: '因违规被驱逐的法师学徒',
          效果: {
            类型: '获得母畜',
            总雌性价值范围: [280, 350],
            初始臣服度: 5,
            原身份: '见习法师',
            种族: '人类',
            特殊标签: ['法师血脉'],
          },
          稀有度: 3,
          图标: '🧙‍♀️',
        },
      ];

      // 随机选择一个
      const 随机索引 = Math.floor(Math.random() * 特殊奴隶池.length);
      const 选中商品 = 特殊奴隶池[随机索引];

      商品列表.push({
        ...选中商品,
        分类: '奴隶商品',
        每周限购: 1,
      });
    }

    // ─── 每4周有概率刷新高价值奴隶 ───
    if (周次 % 4 === 0 && Math.random() < 0.5) {
      const 稀有奴隶池 = [
        {
          名称: '流亡小国的落难公主',
          价格: 80,
          描述: '亡国后流落黑市的公主',
          效果: {
            类型: '获得母畜',
            总雌性价值: 400,
            初始臣服度: 0,
            原身份: '公主',
            种族: '人类',
            特殊标签: ['王族血脉', '高贵'],
          },
          稀有度: 4,
          图标: '👑',
        },
        {
          名称: '堕落的圣殿女骑士',
          价格: 70,
          描述: '被判为异端的女骑士',
          效果: {
            类型: '获得母畜',
            总雌性价值: 380,
            初始臣服度: 0,
            原身份: '女骑士',
            种族: '人类',
            特殊标签: ['骑士训练', '神圣'],
          },
          稀有度: 4,
          图标: '⚔️',
        },
        {
          名称: '纯血精灵女祭司',
          价格: 100,
          描述: '极其罕见的精灵族祭司',
          效果: {
            类型: '获得母畜',
            总雌性价值: 500,
            初始臣服度: 0,
            原身份: '圣女',
            种族: '精灵',
            特殊标签: ['精灵血脉', '神圣', '纯血'],
          },
          稀有度: 5,
          图标: '🌟',
        },
      ];

      const 随机索引 = Math.floor(Math.random() * 稀有奴隶池.length);
      const 选中商品 = 稀有奴隶池[随机索引];

      商品列表.push({
        ...选中商品,
        分类: '奴隶商品',
        每周限购: 1,
      });
    }

    return 商品列表;
  });

  // ═══════════════════════════════════════════════════════════════
  // 稀有商品刷新规则
  // ═══════════════════════════════════════════════════════════════

  商品注册表.注册刷新规则('稀有商品', (周次, 上下文) => {
    const 商品列表 = [];

    // 每4周刷新的稀有商品池
    const 稀有商品池 = [
      {
        名称: '古代繁殖秘药',
        价格: 100,
        描述: '传说中能够大幅提升生育价值的秘药',
        效果: {
          类型: '价值提升',
          总雌性价值提升: 100,
        },
        稀有度: 4,
        图标: '📜',
      },
      {
        名称: '禁忌的献祭仪式书',
        价格: 80,
        描述: '记载着能够提升献祭效率的知识',
        效果: {
          类型: '献祭增幅',
          魔力获得加成: 0.5,
          持续: '永久',
        },
        稀有度: 4,
        图标: '📕',
      },
      {
        名称: '战神的祝福符文',
        价格: 60,
        描述: '永久提升军队基础战力',
        效果: {
          类型: '战力永久提升',
          战力提升: 10,
        },
        稀有度: 3,
        图标: '🔱',
      },
      {
        名称: '龙血催情剂',
        价格: 50,
        描述: '将目标母畜淫乱度直接提升至80',
        效果: {
          类型: '属性设置',
          目标属性: '淫乱度',
          设置值: 80,
        },
        稀有度: 3,
        图标: '🐉',
      },
      {
        名称: '精神控制权杖',
        价格: 70,
        描述: '将目标母畜臣服度直接提升至90',
        效果: {
          类型: '属性设置',
          目标属性: '臣服度',
          设置值: 90,
        },
        稀有度: 4,
        图标: '🪄',
      },
    ];

    // 随机选择2-3个稀有商品
    const 刷新数量 = 2 + Math.floor(Math.random() * 2);
    const 已选索引 = new Set();

    while (商品列表.length < 刷新数量 && 已选索引.size < 稀有商品池.length) {
      const 随机索引 = Math.floor(Math.random() * 稀有商品池.length);
      if (!已选索引.has(随机索引)) {
        已选索引.add(随机索引);
        商品列表.push({
          ...稀有商品池[随机索引],
          分类: '稀有商品',
          每周限购: 1,
        });
      }
    }

    return 商品列表;
  });
}

// ═══════════════════════════════════════════════════════════════
// 商品效果类型说明
// ═══════════════════════════════════════════════════════════════

const 商品效果类型说明 = {
  武装升级: {
    描述: '将未武装的喽啰升级为指定武装等级',
    参数: ['目标等级', '战斗力提升', '每母乳武装数量'],
  },
  获得母畜: {
    描述: '获得一名新的母畜',
    参数: ['总雌性价值范围', '初始臣服度', '原身份', '种族', '特殊标签'],
  },
  祝福水晶: {
    描述: '恢复母畜的剩余雌性价值',
    参数: ['计算公式'],
  },
  净化水晶: {
    描述: '降低母畜的淫乱度',
    参数: ['淫乱度减少'],
  },
  魔力水晶: {
    描述: '恢复领主的魔力',
    参数: ['魔力恢复'],
  },
  调教增幅: {
    描述: '提升调教任务效率',
    参数: ['效率加成', '使用次数'],
  },
  属性增加: {
    描述: '增加目标母畜的指定属性',
    参数: ['目标属性', '增加量'],
  },
  属性设置: {
    描述: '将目标母畜的指定属性设置为特定值',
    参数: ['目标属性', '设置值'],
  },
  士气增加: {
    描述: '增加军队士气',
    参数: ['增加量'],
  },
  价值提升: {
    描述: '提升母畜的总雌性价值',
    参数: ['总雌性价值提升'],
  },
  战力永久提升: {
    描述: '永久提升军队基础战力',
    参数: ['战力提升'],
  },
};

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 初始化商品配置, 商品效果类型说明 };
export default 初始化商品配置;
```


src\config\raid-targets.js
```js
// ═══════════════════════════════════════════════════════════════
// config/raid-targets.js
// 袭击目标配置 - 定义目标类型、战力范围、高价值目标生成规则
// ═══════════════════════════════════════════════════════════════

/**
 * 袭击目标类型配置
 * 定义每种目标的基础属性范围和特征
 */
const 袭击目标类型配置 = {
  村庄: {
    战力范围: { 最小: 20, 最大: 80 },
    高价值目标数量: { 最小: 1, 最大: 3 },
    描述模板: ['偏远的小村庄', '宁静的农业村落', '山脚下的村庄', '河边的渔村'],
    位置类型: ['平原', '山区', '河谷', '森林边缘'],
    高价值目标身份池: ['农家女', '村长之女', '工匠之女'],
    稀有身份概率: 0.1,
    稀有身份池: ['商人之女', '低阶冒险者'],
  },

  商队: {
    战力范围: { 最小: 40, 最大: 120 },
    高价值目标数量: { 最小: 1, 最大: 4 },
    描述模板: ['途经的贸易商队', '满载货物的大商队', '精灵商人的队伍', '跨国商队'],
    位置类型: ['商道', '山路', '平原', '边境'],
    高价值目标身份池: ['商人之女', '佣人', '普通人'],
    稀有身份概率: 0.15,
    稀有身份池: ['低阶冒险者', '见习法师', '贵族'],
  },

  城镇: {
    战力范围: { 最小: 100, 最大: 250 },
    高价值目标数量: { 最小: 2, 最大: 6 },
    描述模板: ['繁华的边境城镇', '矿业小城', '交通要道上的城镇', '古老的城镇'],
    位置类型: ['交叉路口', '矿区', '边境', '河岸'],
    高价值目标身份池: ['商人之女', '城主之女', '工匠之女', '低阶冒险者'],
    稀有身份概率: 0.2,
    稀有身份池: ['女骑士', '见习法师', '贵族'],
  },

  城市: {
    战力范围: { 最小: 300, 最大: 600 },
    高价值目标数量: { 最小: 3, 最大: 8 },
    描述模板: ['王国边陲的城市', '商业都市', '学院城市', '军事重镇'],
    位置类型: ['王国边境', '内陆', '沿海', '要塞区'],
    高价值目标身份池: ['贵族', '城主之女', '女骑士', '低阶冒险者', '见习法师'],
    稀有身份概率: 0.25,
    稀有身份池: ['高阶法师', '女将军', '大贵族'],
  },

  要塞: {
    战力范围: { 最小: 400, 最大: 800 },
    高价值目标数量: { 最小: 2, 最大: 5 },
    描述模板: ['边境要塞', '山间堡垒', '古老的防御工事', '骑士团驻地'],
    位置类型: ['山口', '边境', '战略要地', '峡谷'],
    高价值目标身份池: ['女骑士', '女侍卫', '女将军'],
    稀有身份概率: 0.3,
    稀有身份池: ['圣女', '公主', '高阶法师'],
  },

  修道院: {
    战力范围: { 最小: 60, 最大: 180 },
    高价值目标数量: { 最小: 2, 最大: 6 },
    描述模板: ['隐秘的修道院', '圣光教团分院', '山中修女院', '古老的祈祷所'],
    位置类型: ['山区', '森林深处', '湖边', '悬崖'],
    高价值目标身份池: ['普通人', '见习法师'],
    稀有身份概率: 0.35,
    稀有身份池: ['圣女', '高阶法师'],
    特殊标签: ['神圣'],
  },

  冒险者营地: {
    战力范围: { 最小: 80, 最大: 200 },
    高价值目标数量: { 最小: 1, 最大: 4 },
    描述模板: ['冒险者临时营地', '探险队宿营地', '迷宫入口的营地', '猎人集合点'],
    位置类型: ['迷宫附近', '荒野', '遗迹旁', '森林'],
    高价值目标身份池: ['低阶冒险者', '见习法师'],
    稀有身份概率: 0.25,
    稀有身份池: ['女骑士', '高阶法师', '盗贼'],
  },

  贵族庄园: {
    战力范围: { 最小: 150, 最大: 350 },
    高价值目标数量: { 最小: 2, 最大: 5 },
    描述模板: ['乡间贵族庄园', '伯爵领地', '男爵的宅邸', '退休骑士的庄园'],
    位置类型: ['田园', '丘陵', '葡萄园区', '湖畔'],
    高价值目标身份池: ['贵族', '大贵族', '佣人', '女侍卫'],
    稀有身份概率: 0.3,
    稀有身份池: ['公主', '女骑士'],
  },
};

/**
 * 高价值目标生成权重配置
 * 根据目标身份决定种族分布
 */
const 种族权重配置 = {
  默认: {
    人类: 70,
    精灵: 10,
    半精灵: 10,
    兽人: 5,
    矮人: 5,
  },
  精灵商队: {
    人类: 20,
    精灵: 50,
    半精灵: 25,
    兽人: 0,
    矮人: 5,
  },
  修道院: {
    人类: 80,
    精灵: 15,
    半精灵: 5,
    兽人: 0,
    矮人: 0,
  },
};

/**
 * 高价值目标年龄配置
 */
const 年龄范围配置 = {
  默认: { 最小: 16, 最大: 35 },
  贵族: { 最小: 16, 最大: 28 },
  冒险者: { 最小: 18, 最大: 32 },
  修女: { 最小: 18, 最大: 40 },
};

/**
 * 目标难度系数配置
 * 用于动态调整战力
 */
const 难度系数配置 = {
  简单: 0.7,
  普通: 1.0,
  困难: 1.3,
  噩梦: 1.6,
};

/**
 * 护卫战力贡献配置
 * 每个护卫贡献的战力
 */
const 护卫战力配置 = {
  民兵: 2,
  卫兵: 5,
  士兵: 8,
  骑士: 15,
  精英骑士: 25,
  法师: 20,
};

/**
 * 初始化袭击目标相关公式
 * @param 公式引擎 - 公式引擎实例
 */
function 初始化袭击目标公式(公式引擎) {
  // ─── 常量设置 ───
  公式引擎.批量设置常量({
    // 战力浮动范围
    目标战力浮动比例: 0.15,

    // 高价值目标价值浮动
    高价值目标价值浮动: 0.1,

    // 稀有度阈值
    稀有身份触发阈值: 0.1,
    传奇身份触发阈值: 0.02,

    // 护卫数量系数
    护卫数量战力系数: 0.3,
  });

  // ─── 目标战力计算 ───
  公式引擎.注册公式(
    '目标战力计算',
    ({ 基础战力, 难度系数, 随机浮动 }, 常量) => {
      const 浮动比例 = 常量.目标战力浮动比例 ?? 0.15;
      const 浮动值 = 基础战力 * 浮动比例 * 随机浮动;
      return Math.floor((基础战力 + 浮动值) * 难度系数);
    },
    {
      描述: '计算袭击目标的实际战力',
      参数说明: {
        基础战力: '目标类型的基础战力',
        难度系数: '游戏难度系数',
        随机浮动: '-1到1的随机浮动值',
      },
      分类: '袭击',
    },
  );

  // ─── 高价值目标数量计算 ───
  公式引擎.注册公式(
    '高价值目标数量计算',
    ({ 最小数量, 最大数量, 运气系数 }) => {
      const 基础数量 = Math.floor(Math.random() * (最大数量 - 最小数量 + 1)) + 最小数量;
      return Math.max(最小数量, Math.floor(基础数量 * 运气系数));
    },
    {
      描述: '计算目标中高价值目标的数量',
      参数说明: {
        最小数量: '最小数量',
        最大数量: '最大数量',
        运气系数: '运气系数，默认1.0',
      },
      分类: '袭击',
    },
  );

  // ─── 护卫数量估算 ───
  公式引擎.注册公式(
    '护卫数量估算',
    ({ 战力, 护卫类型战力 }, 常量) => {
      const 系数 = 常量.护卫数量战力系数 ?? 0.3;
      return Math.floor((战力 * 系数) / 护卫类型战力);
    },
    {
      描述: '根据战力估算护卫数量',
      参数说明: {
        战力: '目标总战力',
        护卫类型战力: '护卫类型的单位战力',
      },
      分类: '袭击',
    },
  );
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 袭击目标类型配置, 种族权重配置, 年龄范围配置, 难度系数配置, 护卫战力配置, 初始化袭击目标公式 };

export default 袭击目标类型配置;
```


src\config\spells.js
```js
// ═══════════════════════════════════════════════════════════════
// config/spells.js
// 法术配置 - 定义所有法术及其效果
// ═══════════════════════════════════════════════════════════════

/**
 * 初始化默认法术配置
 * @param 法术注册表 - 法术定义注册表实例
 */
function 初始化法术配置(法术注册表) {
  // ═══════════════════════════════════════════════════════════════
  // 增益类法术
  // ═══════════════════════════════════════════════════════════════

  // ─── 催化调教 ───
  法术注册表.注册法术('催化调教', {
    魔力消耗: 1,
    目标类型: '无',
    分类: '增益',
    效果描述: '下一次调教任务效率翻倍',
    效果参数: {
      调教倍率: 2,
      持续: '单次',
    },
    图标: '✨',
  });

  法术注册表.注册效果处理器('催化调教', (目标, 上下文) => {
    // 此法术效果由任务系统在下次调教时应用
    return {
      成功: true,
      效果类型: '调教增幅',
      倍率: 上下文.效果参数.调教倍率,
      描述: '下一次调教效率翻倍',
      需要标记: true,
      标记名称: 'buff_调教增幅',
    };
  });

  // ─── 战嚎祝福 ───
  法术注册表.注册法术('战嚎祝福', {
    魔力消耗: 3,
    目标类型: '无',
    分类: '增益',
    效果描述: '本次战斗军队战力+30%',
    效果参数: {
      战力加成: 0.3,
      持续: '单次战斗',
    },
    冷却周期: 2,
    图标: '🔥',
  });

  法术注册表.注册效果处理器('战嚎祝福', (目标, 上下文) => {
    return {
      成功: true,
      效果类型: '战力增幅',
      加成比例: 上下文.效果参数.战力加成,
      描述: '本次战斗战力+30%',
      需要标记: true,
      标记名称: 'buff_战力增幅',
    };
  });

  // ─── 铁壁守护 ───
  法术注册表.注册法术('铁壁守护', {
    魔力消耗: 2,
    目标类型: '无',
    分类: '增益',
    效果描述: '本次战斗存活率提升20%',
    效果参数: {
      存活率加成: 0.2,
      持续: '单次战斗',
    },
    冷却周期: 2,
    图标: '🛡️',
  });

  法术注册表.注册效果处理器('铁壁守护', (目标, 上下文) => {
    return {
      成功: true,
      效果类型: '存活率增幅',
      加成比例: 上下文.效果参数.存活率加成,
      描述: '本次战斗存活率提升20%',
      需要标记: true,
      标记名称: 'buff_铁壁',
    };
  });

  // ─── 急行军令 ───
  法术注册表.注册法术('急行军令', {
    魔力消耗: 2,
    目标类型: '无',
    分类: '增益',
    效果描述: '本周额外获得1点行动点',
    效果参数: {
      行动点增加: 1,
    },
    冷却周期: 4,
    图标: '⚡',
  });

  法术注册表.注册效果处理器('急行军令', (目标, 上下文) => {
    // 需要时间系统配合
    return {
      成功: true,
      效果类型: '行动点增加',
      增量: 上下文.效果参数.行动点增加,
      描述: '本周行动点+1',
      需要应用到: '时间系统',
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 情报类法术
  // ═══════════════════════════════════════════════════════════════

  // ─── 魔眼侦察 ───
  法术注册表.注册法术('魔眼侦察', {
    魔力消耗: 1,
    目标类型: '无',
    分类: '情报',
    效果描述: '立刻提高目标情报进度30点',
    效果参数: {
      情报增量: 30,
    },
    图标: '👁️',
  });

  法术注册表.注册效果处理器('魔眼侦察', (目标, 上下文) => {
    return {
      成功: true,
      效果类型: '情报增加',
      增量: 上下文.效果参数.情报增量,
      描述: '情报进度+30',
      需要应用到: '情报系统',
    };
  });

  // ─── 真视之眼 ───
  法术注册表.注册法术('真视之眼', {
    魔力消耗: 3,
    目标类型: '无',
    分类: '情报',
    效果描述: '完全揭示目标的真实战力',
    效果参数: {
      情报增量: 100,
    },
    冷却周期: 5,
    图标: '🔮',
  });

  法术注册表.注册效果处理器('真视之眼', (目标, 上下文) => {
    return {
      成功: true,
      效果类型: '情报完全揭示',
      增量: 上下文.效果参数.情报增量,
      描述: '完全揭示目标战力',
      需要应用到: '情报系统',
    };
  });

  // ─── 心灵探知 ───
  法术注册表.注册法术('心灵探知', {
    魔力消耗: 2,
    目标类型: '无',
    分类: '情报',
    效果描述: '锁定一个高价值目标',
    效果参数: {
      锁定数量: 1,
    },
    冷却周期: 2,
    图标: '🧠',
  });

  法术注册表.注册效果处理器('心灵探知', (目标, 上下文) => {
    return {
      成功: true,
      效果类型: '目标锁定',
      锁定数量: 上下文.效果参数.锁定数量,
      描述: '强制锁定一个高价值目标',
      需要应用到: '情报系统',
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 操控类法术（针对母畜）
  // ═══════════════════════════════════════════════════════════════

  // ─── 意志粉碎 ───
  法术注册表.注册法术('意志粉碎', {
    魔力消耗: 3,
    目标类型: '母畜',
    分类: '操控',
    效果描述: '目标母畜臣服度直接+50',
    效果参数: {
      臣服度增加: 50,
    },
    冷却周期: 3,
    图标: '💔',
  });

  法术注册表.注册效果处理器('意志粉碎', (目标, 上下文) => {
    if (!目标) {
      return { 成功: false, 原因: '无目标' };
    }

    const 旧臣服度 = 目标.获取属性('臣服度');
    目标.修改属性('臣服度', 上下文.效果参数.臣服度增加);
    const 新臣服度 = 目标.获取属性('臣服度');

    return {
      成功: true,
      效果类型: '臣服度增加',
      目标ID: 目标.实体ID,
      目标姓名: 目标.获取属性('姓名'),
      旧值: 旧臣服度,
      新值: 新臣服度,
      增量: 新臣服度 - 旧臣服度,
    };
  });

  // ─── 淫堕催化 ───
  法术注册表.注册法术('淫堕催化', {
    魔力消耗: 3,
    目标类型: '母畜',
    分类: '操控',
    效果描述: '目标母畜淫乱度直接+50',
    效果参数: {
      淫乱度增加: 50,
    },
    冷却周期: 3,
    图标: '💜',
  });

  法术注册表.注册效果处理器('淫堕催化', (目标, 上下文) => {
    if (!目标) {
      return { 成功: false, 原因: '无目标' };
    }

    const 旧淫乱度 = 目标.获取属性('淫乱度');
    目标.修改属性('淫乱度', 上下文.效果参数.淫乱度增加);
    const 新淫乱度 = 目标.获取属性('淫乱度');

    return {
      成功: true,
      效果类型: '淫乱度增加',
      目标ID: 目标.实体ID,
      目标姓名: 目标.获取属性('姓名'),
      旧值: 旧淫乱度,
      新值: 新淫乱度,
      增量: 新淫乱度 - 旧淫乱度,
    };
  });

  // ─── 双重催化 ───
  法术注册表.注册法术('双重催化', {
    魔力消耗: 5,
    目标类型: '母畜',
    分类: '操控',
    效果描述: '目标母畜臣服度和淫乱度各+30',
    效果参数: {
      臣服度增加: 30,
      淫乱度增加: 30,
    },
    冷却周期: 4,
    图标: '💫',
  });

  法术注册表.注册效果处理器('双重催化', (目标, 上下文) => {
    if (!目标) {
      return { 成功: false, 原因: '无目标' };
    }

    const 旧臣服度 = 目标.获取属性('臣服度');
    const 旧淫乱度 = 目标.获取属性('淫乱度');

    目标.修改属性('臣服度', 上下文.效果参数.臣服度增加);
    目标.修改属性('淫乱度', 上下文.效果参数.淫乱度增加);

    const 新臣服度 = 目标.获取属性('臣服度');
    const 新淫乱度 = 目标.获取属性('淫乱度');

    return {
      成功: true,
      效果类型: '双重增加',
      目标ID: 目标.实体ID,
      目标姓名: 目标.获取属性('姓名'),
      臣服度: { 旧值: 旧臣服度, 新值: 新臣服度 },
      淫乱度: { 旧值: 旧淫乱度, 新值: 新淫乱度 },
    };
  });

  // ─── 净化之光 ───
  法术注册表.注册法术('净化之光', {
    魔力消耗: 2,
    目标类型: '母畜',
    分类: '操控',
    效果描述: '目标母畜淫乱度-30（最低为0）',
    效果参数: {
      淫乱度减少: 30,
    },
    冷却周期: 2,
    图标: '✝️',
  });

  法术注册表.注册效果处理器('净化之光', (目标, 上下文) => {
    if (!目标) {
      return { 成功: false, 原因: '无目标' };
    }

    const 旧淫乱度 = 目标.获取属性('淫乱度');
    目标.修改属性('淫乱度', -上下文.效果参数.淫乱度减少);
    const 新淫乱度 = 目标.获取属性('淫乱度');

    return {
      成功: true,
      效果类型: '淫乱度减少',
      目标ID: 目标.实体ID,
      目标姓名: 目标.获取属性('姓名'),
      旧值: 旧淫乱度,
      新值: 新淫乱度,
      减少量: 旧淫乱度 - 新淫乱度,
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 恢复类法术
  // ═══════════════════════════════════════════════════════════════

  // ─── 孕力回复 ───
  法术注册表.注册法术('孕力回复', {
    魔力消耗: 5,
    目标类型: '母畜',
    分类: '恢复',
    效果描述: '目标母畜剩余雌性价值+100',
    效果参数: {
      雌性价值恢复: 100,
    },
    冷却周期: 5,
    图标: '💖',
  });

  法术注册表.注册效果处理器('孕力回复', (目标, 上下文) => {
    if (!目标) {
      return { 成功: false, 原因: '无目标' };
    }

    const 当前剩余 = 目标.获取属性('剩余雌性价值');
    const 总价值 = 目标.获取属性('总雌性价值');
    const 恢复量 = 上下文.效果参数.雌性价值恢复;

    const 新值 = Math.min(当前剩余 + 恢复量, 总价值);
    const 实际恢复 = 新值 - 当前剩余;

    目标.设置属性('剩余雌性价值', 新值);

    return {
      成功: true,
      效果类型: '雌性价值恢复',
      目标ID: 目标.实体ID,
      目标姓名: 目标.获取属性('姓名'),
      请求恢复: 恢复量,
      实际恢复: 实际恢复,
      当前剩余: 新值,
      总价值,
    };
  });

  // ─── 完全回复 ───
  法术注册表.注册法术('完全回复', {
    魔力消耗: 10,
    目标类型: '母畜',
    分类: '恢复',
    效果描述: '完全恢复目标母畜的剩余雌性价值',
    效果参数: {},
    冷却周期: 10,
    施放条件: 上下文 => {
      // 需要目标剩余价值低于50%才能施放
      if (!上下文.目标) return true;
      const 剩余 = 上下文.目标.获取属性('剩余雌性价值');
      const 总量 = 上下文.目标.获取属性('总雌性价值');
      return 剩余 < 总量 * 0.5;
    },
    图标: '💗',
  });

  法术注册表.注册效果处理器('完全回复', (目标, 上下文) => {
    if (!目标) {
      return { 成功: false, 原因: '无目标' };
    }

    const 当前剩余 = 目标.获取属性('剩余雌性价值');
    const 总价值 = 目标.获取属性('总雌性价值');

    目标.设置属性('剩余雌性价值', 总价值);

    return {
      成功: true,
      效果类型: '完全恢复',
      目标ID: 目标.实体ID,
      目标姓名: 目标.获取属性('姓名'),
      恢复量: 总价值 - 当前剩余,
      当前剩余: 总价值,
    };
  });

  // ─── 治愈之手 ───
  法术注册表.注册法术('治愈之手', {
    魔力消耗: 2,
    目标类型: '冠军',
    分类: '恢复',
    效果描述: '立刻治愈目标冠军的负伤状态',
    效果参数: {},
    图标: '🩹',
  });

  法术注册表.注册效果处理器('治愈之手', (目标, 上下文) => {
    if (!目标) {
      return { 成功: false, 原因: '无目标' };
    }

    if (!目标.拥有标签('负伤')) {
      return {
        成功: true,
        效果类型: '无需治疗',
        描述: '目标未负伤',
      };
    }

    目标.移除标签('负伤');

    return {
      成功: true,
      效果类型: '治愈负伤',
      目标ID: 目标.实体ID,
      目标姓名: 目标.获取属性('姓名'),
      描述: '负伤已治愈',
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 军事类法术
  // ═══════════════════════════════════════════════════════════════

  // ─── 士气鼓舞 ───
  法术注册表.注册法术('士气鼓舞', {
    魔力消耗: 2,
    目标类型: '无',
    分类: '军事',
    效果描述: '立刻提升军队士气20点',
    效果参数: {
      士气增加: 20,
    },
    冷却周期: 2,
    图标: '📣',
  });

  法术注册表.注册效果处理器('士气鼓舞', (目标, 上下文) => {
    return {
      成功: true,
      效果类型: '士气增加',
      增量: 上下文.效果参数.士气增加,
      描述: '士气+20',
      需要应用到: '军队状态',
    };
  });

  // ─── 狂战祝福 ───
  法术注册表.注册法术('狂战祝福', {
    魔力消耗: 4,
    目标类型: '冠军',
    分类: '军事',
    效果描述: '目标冠军本次战斗所率部曲战力翻倍',
    效果参数: {
      战力倍率: 2,
      持续: '单次战斗',
    },
    冷却周期: 5,
    图标: '⚔️',
  });

  法术注册表.注册效果处理器('狂战祝福', (目标, 上下文) => {
    if (!目标) {
      return { 成功: false, 原因: '无目标' };
    }

    目标.添加标签('buff_狂战');

    return {
      成功: true,
      效果类型: '部曲战力增幅',
      目标ID: 目标.实体ID,
      目标姓名: 目标.获取属性('姓名'),
      倍率: 上下文.效果参数.战力倍率,
      描述: '本次战斗部曲战力翻倍',
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 资源类法术
  // ═══════════════════════════════════════════════════════════════

  // ─── 丰饶祝福 ───
  法术注册表.注册法术('丰饶祝福', {
    魔力消耗: 3,
    目标类型: '无',
    分类: '资源',
    效果描述: '本周所有母畜泌乳产量翻倍',
    效果参数: {
      产量倍率: 2,
      持续: '本周',
    },
    冷却周期: 4,
    图标: '🌾',
  });

  法术注册表.注册效果处理器('丰饶祝福', (目标, 上下文) => {
    return {
      成功: true,
      效果类型: '泌乳增幅',
      倍率: 上下文.效果参数.产量倍率,
      描述: '本周泌乳产量翻倍',
      需要标记: true,
      标记名称: 'buff_丰饶',
    };
  });

  // ─── 繁殖祝福 ───
  法术注册表.注册法术('繁殖祝福', {
    魔力消耗: 4,
    目标类型: '母畜',
    分类: '资源',
    效果描述: '目标母畜下次生育产出翻倍',
    效果参数: {
      产出倍率: 2,
    },
    冷却周期: 5,
    图标: '🐣',
  });

  法术注册表.注册效果处理器('繁殖祝福', (目标, 上下文) => {
    if (!目标) {
      return { 成功: false, 原因: '无目标' };
    }

    目标.添加标签('buff_繁殖祝福');

    return {
      成功: true,
      效果类型: '繁殖增幅',
      目标ID: 目标.实体ID,
      目标姓名: 目标.获取属性('姓名'),
      倍率: 上下文.效果参数.产出倍率,
      描述: '下次生育产出翻倍',
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 特殊法术
  // ═══════════════════════════════════════════════════════════════

  // ─── 强制献祭 ───
  法术注册表.注册法术('强制献祭', {
    魔力消耗: 0, // 不消耗魔力，反而获得魔力
    目标类型: '母畜',
    分类: '特殊',
    效果描述: '强制将淫乱度≥80的母畜献祭，获得魔力',
    效果参数: {},
    施放条件: 上下文 => {
      if (!上下文.目标) return false;
      return 上下文.目标.获取属性('淫乱度') >= 80;
    },
    图标: '🔥',
  });

  法术注册表.注册效果处理器('强制献祭', (目标, 上下文) => {
    if (!目标) {
      return { 成功: false, 原因: '无目标' };
    }

    const 淫乱度 = 目标.获取属性('淫乱度');
    if (淫乱度 < 80) {
      return { 成功: false, 原因: '淫乱度不足80' };
    }

    const 总雌性价值 = 目标.获取属性('总雌性价值');
    // 强制献祭效率略低于完全淫堕献祭
    const 效率 = 淫乱度 / 100; // 80%~100%
    const 魔力获得 = Math.floor((总雌性价值 / 100) * 效率);

    return {
      成功: true,
      效果类型: '强制献祭',
      目标ID: 目标.实体ID,
      目标姓名: 目标.获取属性('姓名'),
      魔力获得,
      需移除母畜: true,
      描述: `献祭获得${魔力获得}点魔力`,
    };
  });

  // ─── 时间加速 ───
  法术注册表.注册法术('时间加速', {
    魔力消耗: 8,
    目标类型: '无',
    分类: '特殊',
    效果描述: '立刻进入下一周（跳过本周剩余行动点）',
    效果参数: {},
    冷却周期: 10,
    施放条件: 上下文 => true,
    图标: '⏰',
  });

  法术注册表.注册效果处理器('时间加速', (目标, 上下文) => {
    return {
      成功: true,
      效果类型: '时间加速',
      描述: '立刻进入下一周',
      需要应用到: '时间系统',
      特殊操作: '强制周结算',
    };
  });

  // ─── 命运改写 ───
  法术注册表.注册法术('命运改写', {
    魔力消耗: 10,
    目标类型: '母畜',
    分类: '特殊',
    效果描述: '将目标母畜的总雌性价值提升50%',
    效果参数: {
      价值提升比例: 0.5,
    },
    冷却周期: 20,
    图标: '⭐',
  });

  法术注册表.注册效果处理器('命运改写', (目标, 上下文) => {
    if (!目标) {
      return { 成功: false, 原因: '无目标' };
    }

    const 原总价值 = 目标.获取属性('总雌性价值');
    const 原剩余价值 = 目标.获取属性('剩余雌性价值');
    const 提升量 = Math.floor(原总价值 * 上下文.效果参数.价值提升比例);

    const 新总价值 = 原总价值 + 提升量;
    const 新剩余价值 = 原剩余价值 + 提升量;

    目标.设置属性('总雌性价值', 新总价值);
    目标.设置属性('剩余雌性价值', 新剩余价值);

    return {
      成功: true,
      效果类型: '价值提升',
      目标ID: 目标.实体ID,
      目标姓名: 目标.获取属性('姓名'),
      原总价值,
      新总价值,
      提升量,
      描述: `总雌性价值提升${提升量}`,
    };
  });
}

// ═══════════════════════════════════════════════════════════════
// 法术分类说明
// ═══════════════════════════════════════════════════════════════

const 法术分类说明 = {
  增益: {
    描述: '临时增强效果，通常持续单次行动或战斗',
    图标: '✨',
  },
  情报: {
    描述: '与情报收集相关的法术',
    图标: '👁️',
  },
  操控: {
    描述: '直接影响母畜属性的法术',
    图标: '💜',
  },
  恢复: {
    描述: '恢复类法术，用于治疗或恢复资源',
    图标: '💖',
  },
  军事: {
    描述: '影响军队战斗力或士气的法术',
    图标: '⚔️',
  },
  资源: {
    描述: '影响资源产出的法术',
    图标: '🌾',
  },
  特殊: {
    描述: '特殊效果法术',
    图标: '⭐',
  },
};

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 初始化法术配置, 法术分类说明 };
export default 初始化法术配置;
```


src\config\tasks.js
```js
// ═══════════════════════════════════════════════════════════════
// config/tasks.js
// 任务配置 - 定义所有任务类型及其执行器
// ═══════════════════════════════════════════════════════════════

/**
 * 初始化默认任务配置
 * @param 任务注册表 - 任务定义注册表实例
 */
function 初始化任务配置(任务注册表) {
  // ═══════════════════════════════════════════════════════════════
  // 调教类任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 调教（冠军 → 母畜）───
  任务注册表.注册任务类型('调教', {
    分类: '调教',
    行动点消耗: 1,
    负责人类型: ['冠军'],
    效率属性: ['智力'],
    产出类型: ['臣服度'],
    需要目标: true,
    目标类型: '母畜',
    描述: '冠军对母畜进行调教，提升其臣服度',
    图标: '🎓',
  });

  任务注册表.注册任务执行器('调教', 上下文 => {
    const { 负责人, 游戏状态, 属性注册表, 公式引擎, 额外参数 } = 上下文;
    const 目标ID = 额外参数?.目标ID;

    const 目标母畜 = 游戏状态.获取母畜(目标ID);
    if (!目标母畜) {
      return { 成功: false, 原因: '目标不存在' };
    }

    const 智力 = 负责人.获取属性('智力');
    const 臣服度增加 = 公式引擎?.计算('调教效率', { 智力 }) ?? 5 * (智力 / 25) + 5;

    const 旧臣服度 = 目标母畜.获取属性('臣服度');
    目标母畜.修改属性('臣服度', 臣服度增加, 属性注册表);
    const 新臣服度 = 目标母畜.获取属性('臣服度');

    return {
      成功: true,
      效果: {
        臣服度增加: Math.floor(臣服度增加),
        当前臣服度: 新臣服度,
        原臣服度: 旧臣服度,
      },
      目标ID: 目标母畜.实体ID,
      目标姓名: 目标母畜.获取属性('姓名'),
    };
  });

  // ─── 惩戒（冠军 → 母畜）───
  任务注册表.注册任务类型('惩戒', {
    分类: '调教',
    行动点消耗: 1,
    负责人类型: ['冠军'],
    效率属性: ['力量'],
    产出类型: ['臣服度', '淫乱度'],
    需要目标: true,
    目标类型: '母畜',
    描述: '通过惩戒快速提升臣服度，但会大幅增加淫乱度',
    图标: '⚔️',
  });

  任务注册表.注册任务执行器('惩戒', 上下文 => {
    const { 负责人, 游戏状态, 属性注册表, 额外参数 } = 上下文;

    const 目标母畜 = 游戏状态.获取母畜(额外参数?.目标ID);
    if (!目标母畜) {
      return { 成功: false, 原因: '目标不存在' };
    }

    const 力量 = 负责人.获取属性('力量');
    const 臣服度增加 = 8 + Math.floor(力量 / 10);
    const 淫乱度增加 = 12 + Math.floor(力量 / 15);

    目标母畜.修改属性('臣服度', 臣服度增加, 属性注册表);
    目标母畜.修改属性('淫乱度', 淫乱度增加, 属性注册表);

    return {
      成功: true,
      效果: {
        臣服度增加,
        淫乱度增加,
        当前臣服度: 目标母畜.获取属性('臣服度'),
        当前淫乱度: 目标母畜.获取属性('淫乱度'),
      },
      目标ID: 目标母畜.实体ID,
    };
  });

  // ─── 劝慰（母畜 → 母畜）───
  任务注册表.注册任务类型('劝慰', {
    分类: '调教',
    行动点消耗: 1,
    负责人类型: ['母畜'],
    负责人条件: 上下文 => 上下文.负责人.获取属性('臣服度') >= 75,
    产出类型: ['臣服度'],
    需要目标: true,
    目标类型: '母畜',
    描述: '已归心的母畜劝慰新来者，同种族/身份有加成',
    图标: '💬',
  });

  任务注册表.注册任务执行器('劝慰', 上下文 => {
    const { 负责人, 游戏状态, 属性注册表, 额外参数 } = 上下文;

    const 目标母畜 = 游戏状态.获取母畜(额外参数?.目标ID);
    if (!目标母畜) {
      return { 成功: false, 原因: '目标不存在' };
    }

    if (负责人.实体ID === 目标母畜.实体ID) {
      return { 成功: false, 原因: '不能对自己执行此任务' };
    }

    let 臣服度增加 = 10;

    // 同种族加成 ×1.5
    if (负责人.获取属性('种族') === 目标母畜.获取属性('种族')) {
      臣服度增加 *= 1.5;
    }

    // 同身份加成 ×1.3
    if (负责人.获取属性('原身份') === 目标母畜.获取属性('原身份')) {
      臣服度增加 *= 1.3;
    }

    目标母畜.修改属性('臣服度', Math.floor(臣服度增加), 属性注册表);

    return {
      成功: true,
      效果: {
        臣服度增加: Math.floor(臣服度增加),
        当前臣服度: 目标母畜.获取属性('臣服度'),
      },
      目标ID: 目标母畜.实体ID,
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 侦察类任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 潜入侦察（母畜 → 目标）───
  任务注册表.注册任务类型('潜入侦察', {
    分类: '侦察',
    行动点消耗: 1,
    负责人类型: ['母畜'],
    负责人条件: 上下文 => 上下文.负责人.获取属性('臣服度') >= 90,
    产出类型: ['情报'],
    需要目标: true,
    描述: '派遣忠诚母畜潜入目标进行侦察，有暴露风险',
    图标: '🕵️',
  });

  任务注册表.注册任务执行器('潜入侦察', 上下文 => {
    const { 负责人, 情报系统, 属性注册表, 额外参数, 公式引擎, 事件总线 } = 上下文;
    const 目标ID = 额外参数?.目标ID;

    if (!情报系统) {
      return { 成功: false, 原因: '情报系统未初始化' };
    }

    if (!目标ID) {
      return { 成功: false, 原因: '未指定侦察目标' };
    }

    const 臣服度 = 负责人.获取属性('臣服度');
    const 淫乱度 = 负责人.获取属性('淫乱度');

    // 效率公式: 1 × (臣服度 ÷ 50) × (1 - 淫乱度 ÷ 200)
    const 效率 = 公式引擎?.计算('潜入侦察效率', { 臣服度, 淫乱度 }) ?? 1 * (臣服度 / 50) * (1 - 淫乱度 / 200);
    const 情报增量 = Math.floor(效率 * 20);

    // 暴露风险判定
    const 暴露概率 = 淫乱度 / 200;
    const 是否暴露 = Math.random() < 暴露概率;

    if (是否暴露) {
      事件总线?.发布('负责人暴露', {
        负责人ID: 负责人.实体ID,
        任务: '潜入侦察',
        目标ID,
      });
      return {
        成功: false,
        暴露: true,
        负责人ID: 负责人.实体ID,
        原因: '侦察员身份暴露',
      };
    }

    // 增加情报进度
    情报系统.增加情报进度(目标ID, 情报增量, '潜入侦察');

    // 尝试锁定目标
    const 锁定系数 = 负责人.获取属性('总雌性价值') / 100;
    const 新锁定目标 = 情报系统.尝试锁定目标(目标ID, 锁定系数);

    // 侦察会略微增加淫乱度
    负责人.修改属性('淫乱度', 2, 属性注册表);

    return {
      成功: true,
      效果: {
        情报增量,
        新锁定目标,
        淫乱度增加: 2,
      },
      目标ID,
    };
  });

  // ─── 直接侦察（冠军 → 目标）───
  任务注册表.注册任务类型('直接侦察', {
    分类: '侦察',
    行动点消耗: 1,
    负责人类型: ['冠军'],
    效率属性: ['敏捷'],
    产出类型: ['情报'],
    需要目标: true,
    描述: '派遣冠军直接侦察，效率较高但可能遭遇战斗',
    图标: '🔭',
  });

  任务注册表.注册任务执行器('直接侦察', 上下文 => {
    const { 负责人, 情报系统, 额外参数, 公式引擎, 事件总线 } = 上下文;
    const 目标ID = 额外参数?.目标ID;

    if (!情报系统) {
      return { 成功: false, 原因: '情报系统未初始化' };
    }

    if (!目标ID) {
      return { 成功: false, 原因: '未指定侦察目标' };
    }

    const 敏捷 = 负责人.获取属性('敏捷');
    const 效率 = 公式引擎?.计算('直接侦察效率', { 敏捷 }) ?? 1 * (敏捷 / 25);
    const 情报增量 = Math.floor(效率 * 15);

    // 增加情报进度
    情报系统.增加情报进度(目标ID, 情报增量, '直接侦察');

    // 遭遇战风险
    const 遭遇战概率 = 0.1;
    const 发生遭遇战 = Math.random() < 遭遇战概率;

    if (发生遭遇战) {
      事件总线?.发布('遭遇战发生', {
        冠军ID: 负责人.实体ID,
        目标ID,
      });
    }

    // 尝试锁定目标
    const 锁定系数 = 敏捷 / 10;
    const 新锁定目标 = 情报系统.尝试锁定目标(目标ID, 锁定系数);

    return {
      成功: true,
      效果: {
        情报增量,
        新锁定目标,
      },
      目标ID,
      遭遇战: 发生遭遇战,
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 繁殖类任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 生育冠军 ───
  任务注册表.注册任务类型('生育冠军', {
    分类: '繁殖',
    行动点消耗: 1,
    负责人类型: ['母畜'],
    负责人条件: 上下文 => {
      const 剩余价值 = 上下文.负责人.获取属性('剩余雌性价值');
      return 剩余价值 >= 100;
    },
    产出类型: ['冠军'],
    动态行动点计算: 上下文 => {
      const 臣服度 = 上下文.负责人.获取属性('臣服度');
      return 臣服度 >= 25 ? 1 : 2;
    },
    描述: '母畜生育一名冠军，消耗100雌性价值',
    图标: '👶',
  });

  任务注册表.注册任务执行器('生育冠军', 上下文 => {
    const { 负责人, 繁殖系统, 游戏状态, 事件总线 } = 上下文;

    if (!繁殖系统) {
      return { 成功: false, 原因: '繁殖系统未初始化' };
    }

    const 结果 = 繁殖系统.生育冠军(负责人);

    if (结果.成功) {
      // 将新冠军添加到游戏状态
      游戏状态?.添加冠军(结果.冠军);

      // 检查是否是首个冠军
      if (游戏状态?.冠军列表?.length === 1) {
        事件总线?.发布('首个冠军诞生', { 冠军: 结果.冠军 });
      }
    }

    return 结果;
  });

  // ─── 生育喽啰 ───
  任务注册表.注册任务类型('生育喽啰', {
    分类: '繁殖',
    行动点消耗: 0,
    负责人类型: ['母畜'],
    负责人条件: 上下文 => {
      const 剩余价值 = 上下文.负责人.获取属性('剩余雌性价值');
      return 剩余价值 > 0;
    },
    产出类型: ['喽啰'],
    动态行动点计算: 上下文 => {
      const 臣服度 = 上下文.负责人.获取属性('臣服度');
      return 臣服度 >= 25 ? 0 : 1;
    },
    描述: '母畜生育喽啰，消耗100雌性价值产出10喽啰',
    图标: '👥',
  });

  任务注册表.注册任务执行器('生育喽啰', 上下文 => {
    const { 负责人, 繁殖系统 } = 上下文;

    if (!繁殖系统) {
      return { 成功: false, 原因: '繁殖系统未初始化' };
    }

    return 繁殖系统.生育喽啰(负责人);
  });

  // ═══════════════════════════════════════════════════════════════
  // 军事类任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 提振士气 ───
  任务注册表.注册任务类型('提振士气', {
    分类: '军事',
    行动点消耗: 1,
    负责人类型: ['母畜'],
    负责人条件: 上下文 => 上下文.负责人.获取属性('臣服度') >= 75,
    产出类型: ['士气'],
    描述: '母畜在喽啰面前表演以提振士气',
    图标: '🎭',
    副作用: [
      上下文 => {
        const { 负责人, 属性注册表 } = 上下文;
        负责人.修改属性('淫乱度', 5, 属性注册表);
      },
    ],
  });

  任务注册表.注册任务执行器('提振士气', 上下文 => {
    const { 负责人, 游戏状态, 公式引擎 } = 上下文;

    const 淫乱度 = 负责人.获取属性('淫乱度');
    const 总雌性价值 = 负责人.获取属性('总雌性价值');

    const 士气提升 = 公式引擎?.计算('提振士气效率', { 淫乱度, 总雌性价值 }) ?? 15 * (淫乱度 / 50) * (总雌性价值 / 200);

    游戏状态?.修改士气(Math.floor(士气提升));

    return {
      成功: true,
      效果: {
        士气提升: Math.floor(士气提升),
        淫乱度增加: 5, // 由副作用处理
        当前士气: 游戏状态?.军队状态?.士气,
      },
    };
  });

  // ─── 训练喽啰 ───
  任务注册表.注册任务类型('训练喽啰', {
    分类: '军事',
    行动点消耗: 1,
    负责人类型: ['冠军'],
    效率属性: ['力量'],
    产出类型: ['战力'],
    描述: '冠军训练喽啰，提升基础战斗力',
    图标: '⚔️',
  });

  任务注册表.注册任务执行器('训练喽啰', 上下文 => {
    const { 负责人, 游戏状态 } = 上下文;

    const 力量 = 负责人.获取属性('力量');
    const 战力提升 = 2 + Math.floor(力量 / 20);

    if (游戏状态?.军队状态) {
      游戏状态.军队状态.战斗力基础值 = (游戏状态.军队状态.战斗力基础值 ?? 100) + 战力提升;
    }

    return {
      成功: true,
      效果: {
        战力提升,
        当前基础战力: 游戏状态?.军队状态?.战斗力基础值,
      },
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 资源类任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 泌乳 ───
  任务注册表.注册任务类型('泌乳', {
    分类: '资源',
    行动点消耗: 0,
    负责人类型: ['母畜'],
    负责人条件: 上下文 => 上下文.负责人.获取属性('淫乱度') >= 25,
    产出类型: ['母乳'],
    描述: '淫乱度达到25以上的母畜会产出母乳',
    图标: '🥛',
    副作用: [
      上下文 => {
        const { 负责人, 属性注册表 } = 上下文;
        负责人.修改属性('淫乱度', 3, 属性注册表);
      },
    ],
  });

  任务注册表.注册任务执行器('泌乳', 上下文 => {
    const { 负责人, 资源系统, 公式引擎 } = 上下文;

    const 淫乱度 = 负责人.获取属性('淫乱度');
    const 产量 = 公式引擎?.计算('泌乳产量', { 淫乱度 }) ?? Math.floor((淫乱度 + 45) / 20);

    if (资源系统) {
      资源系统.增加资源('母乳', 产量, '泌乳');
    }

    return {
      成功: true,
      效果: {
        母乳产量: 产量,
        淫乱度增加: 3, // 由副作用处理
      },
    };
  });

  // ═══════════════════════════════════════════════════════════════
  // 特殊任务
  // ═══════════════════════════════════════════════════════════════

  // ─── 潜入劝诱 ───
  任务注册表.注册任务类型('潜入劝诱', {
    分类: '特殊',
    行动点消耗: 1,
    负责人类型: ['母畜'],
    负责人条件: 上下文 => 上下文.负责人.获取属性('臣服度') >= 90,
    产出类型: ['母畜'],
    需要目标: true,
    描述: '派遣母畜劝诱目标地点的女性加入部落',
    图标: '💋',
  });

  任务注册表.注册任务执行器('潜入劝诱', 上下文 => {
    const { 负责人, 母畜工厂, 游戏状态, 额外参数, 公式引擎, 事件总线 } = 上下文;

    const 负责人价值 = 负责人.获取属性('总雌性价值');
    const 目标价值 = 额外参数?.目标价值 ?? 100;

    const 成功率 = 公式引擎?.计算('潜入劝诱成功率', { 负责人价值, 目标价值 }) ?? 负责人价值 / 目标价值 / 2.5;
    const 是否成功 = Math.random() < 成功率;

    if (!是否成功) {
      const 暴露概率 = 0.3;
      const 是否暴露 = Math.random() < 暴露概率;

      if (是否暴露) {
        事件总线?.发布('负责人暴露', {
          负责人ID: 负责人.实体ID,
          任务: '潜入劝诱',
        });
      }

      return {
        成功: false,
        暴露: 是否暴露,
        负责人ID: 负责人.实体ID,
        原因: '劝诱失败',
      };
    }

    // 创建新母畜
    if (母畜工厂) {
      const 新母畜 = 母畜工厂.从劝诱创建({
        目标配置: 额外参数?.目标配置 ?? { 原身份: '普通人' },
        初始臣服度: 20,
      });
      游戏状态?.添加母畜(新母畜);

      return {
        成功: true,
        新母畜ID: 新母畜.实体ID,
        效果: {
          获得母畜: 新母畜.获取属性('姓名'),
          初始臣服度: 20,
        },
      };
    }

    return {
      成功: true,
      需创建母畜: true,
      初始臣服度: 20,
      目标配置: 额外参数?.目标配置,
    };
  });

  // ─── 休整 ───
  任务注册表.注册任务类型('休整', {
    分类: '通用',
    行动点消耗: 1,
    负责人类型: ['冠军', '母畜'],
    描述: '休息恢复，冠军恢复负伤状态，母畜略微降低淫乱度',
    图标: '💤',
  });

  任务注册表.注册任务执行器('休整', 上下文 => {
    const { 负责人, 属性注册表 } = 上下文;

    const 效果 = {};

    if (负责人.实体类型 === '冠军') {
      if (负责人.拥有标签('负伤')) {
        负责人.移除标签('负伤');
        效果.状态恢复 = '负伤痊愈';
      } else {
        效果.状态恢复 = '无需恢复';
      }
    } else if (负责人.实体类型 === '母畜') {
      const 旧淫乱度 = 负责人.获取属性('淫乱度');
      if (旧淫乱度 > 0) {
        负责人.修改属性('淫乱度', -5, 属性注册表);
        效果.淫乱度降低 = Math.min(5, 旧淫乱度);
        效果.当前淫乱度 = 负责人.获取属性('淫乱度');
      } else {
        效果.状态恢复 = '无需恢复';
      }
    }

    return {
      成功: true,
      效果,
    };
  });
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 初始化任务配置 };
export default 初始化任务配置;
```


src\core\entities.js
```js
// ═══════════════════════════════════════════════════════════════
// core/entities.js
// 实体基类与所有实体类型定义
// ═══════════════════════════════════════════════════════════════

/**
 * 实体基类
 * 所有游戏实体的基础，提供属性管理和事件钩子
 */
class 实体基类 {
  constructor(实体类型, 初始数据 = {}) {
    this.实体ID = this.生成唯一ID();
    this.实体类型 = 实体类型;
    this.属性容器 = new Map();
    this.状态标签 = new Set();
    this.元数据 = {
      创建时间: Date.now(),
      ...初始数据.元数据,
    };
    this.事件监听器 = new Map();
  }

  // ─── ID生成 ───

  static #idCounter = 0;

  生成唯一ID() {
    return `${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
  }

  // ─── 属性操作 ───

  设置属性(属性名, 值) {
    const 旧值 = this.属性容器.get(属性名);
    this.属性容器.set(属性名, 值);
    this.触发事件('属性变更', {
      属性名,
      旧值,
      新值: 值,
    });
  }

  获取属性(属性名, 默认值 = null) {
    return this.属性容器.has(属性名) ? this.属性容器.get(属性名) : 默认值;
  }

  修改属性(属性名, 增量, 属性注册表 = null) {
    const 当前值 = this.获取属性(属性名, 0);
    let 新值 = 当前值 + 增量;

    // 如果有属性注册表，应用范围限制
    if (属性注册表) {
      const 配置 = 属性注册表.获取属性配置(属性名);
      if (配置) {
        新值 = Math.max(配置.最小值, Math.min(配置.最大值, 新值));
      }
    }

    this.设置属性(属性名, 新值);
    return 新值;
  }

  批量设置属性(属性对象) {
    Object.entries(属性对象).forEach(([属性名, 值]) => {
      this.设置属性(属性名, 值);
    });
  }

  获取所有属性() {
    return Object.fromEntries(this.属性容器);
  }

  // ─── 状态标签操作 ───

  添加标签(标签) {
    if (!this.状态标签.has(标签)) {
      this.状态标签.add(标签);
      this.触发事件('标签添加', { 标签 });
    }
  }

  移除标签(标签) {
    if (this.状态标签.has(标签)) {
      this.状态标签.delete(标签);
      this.触发事件('标签移除', { 标签 });
    }
  }

  拥有标签(标签) {
    return this.状态标签.has(标签);
  }

  获取所有标签() {
    return Array.from(this.状态标签);
  }

  切换标签(标签) {
    if (this.拥有标签(标签)) {
      this.移除标签(标签);
      return false;
    } else {
      this.添加标签(标签);
      return true;
    }
  }

  // ─── 事件系统 ───

  监听事件(事件名, 处理器) {
    if (!this.事件监听器.has(事件名)) {
      this.事件监听器.set(事件名, []);
    }
    this.事件监听器.get(事件名).push(处理器);

    // 返回取消监听函数
    return () => {
      const 列表 = this.事件监听器.get(事件名);
      const 索引 = 列表?.indexOf(处理器);
      if (索引 !== undefined && 索引 !== -1) {
        列表.splice(索引, 1);
      }
    };
  }

  触发事件(事件名, 数据 = {}) {
    const 处理器列表 = this.事件监听器.get(事件名) ?? [];
    处理器列表.forEach(处理器 => {
      try {
        处理器(数据, this);
      } catch (错误) {
        console.error(`实体事件处理错误 [${事件名}]:`, 错误);
      }
    });
  }

  // ─── 序列化 ───

  序列化() {
    return {
      实体ID: this.实体ID,
      实体类型: this.实体类型,
      属性: Object.fromEntries(this.属性容器),
      标签: Array.from(this.状态标签),
      元数据: { ...this.元数据 },
    };
  }

  static 从序列化恢复(数据, 构造器 = null) {
    const 目标构造器 = 构造器 ?? this;
    const 实体 = new 目标构造器({});

    实体.实体ID = 数据.实体ID;
    实体.实体类型 = 数据.实体类型;

    if (数据.属性) {
      Object.entries(数据.属性).forEach(([k, v]) => {
        实体.属性容器.set(k, v);
      });
    }

    if (数据.标签) {
      数据.标签.forEach(t => 实体.状态标签.add(t));
    }

    实体.元数据 = 数据.元数据 ?? {};

    return 实体;
  }

  // ─── 克隆 ───

  克隆() {
    const 数据 = this.序列化();
    数据.实体ID = this.生成唯一ID(); // 新ID
    return this.constructor.从序列化恢复(数据, this.constructor);
  }
}

// ═══════════════════════════════════════════════════════════════
// 领主实体
// ═══════════════════════════════════════════════════════════════

/**
 * 领主实体
 * 玩家控制的主角，拥有魔力资源
 */
class 领主实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('领主', 初始数据);

    // 核心属性
    this.设置属性('魔力', 初始数据.魔力 ?? 0);
    this.设置属性('最大魔力', 初始数据.最大魔力 ?? 100);
    this.设置属性('姓名', 初始数据.姓名 ?? '无名领主');
  }

  // ─── 魔力操作 ───

  消耗魔力(数量) {
    const 当前魔力 = this.获取属性('魔力');
    if (当前魔力 < 数量) {
      return { 成功: false, 原因: '魔力不足', 当前: 当前魔力, 需要: 数量 };
    }
    this.设置属性('魔力', 当前魔力 - 数量);
    return { 成功: true, 剩余: 当前魔力 - 数量 };
  }

  获得魔力(数量) {
    const 当前魔力 = this.获取属性('魔力');
    const 最大魔力 = this.获取属性('最大魔力');
    const 新魔力 = Math.min(当前魔力 + 数量, 最大魔力);
    const 实际获得 = 新魔力 - 当前魔力;

    this.设置属性('魔力', 新魔力);

    return { 实际获得, 当前: 新魔力, 溢出: 数量 - 实际获得 };
  }

  获取魔力百分比() {
    const 当前 = this.获取属性('魔力');
    const 最大 = this.获取属性('最大魔力');
    return 最大 > 0 ? (当前 / 最大) * 100 : 0;
  }
}

// ═══════════════════════════════════════════════════════════════
// 冠军实体
// ═══════════════════════════════════════════════════════════════

/**
 * 冠军实体
 * 部落的精英战士，拥有三维属性，可统帅喽啰
 */
class 冠军实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('冠军', 初始数据);

    // 基础信息
    this.设置属性('姓名', 初始数据.姓名 ?? '无名冠军');
    this.设置属性('外貌描述', 初始数据.外貌描述 ?? '');
    this.设置属性('性别', 初始数据.性别 ?? '男');

    // 三维属性
    this.设置属性('力量', 初始数据.力量 ?? 10);
    this.设置属性('敏捷', 初始数据.敏捷 ?? 10);
    this.设置属性('智力', 初始数据.智力 ?? 10);

    // 状态属性
    this.设置属性('经验', 初始数据.经验 ?? 0);
    this.设置属性('等级', 初始数据.等级 ?? 1);

    // 成长记录
    this.成长日志 = [];

    // 来源信息
    this.来源信息 = 初始数据.来源信息 ?? null;
  }

  // ─── 属性计算 ───

  计算可统帅喽啰数() {
    return this.获取属性('力量');
  }

  计算总属性值() {
    return this.获取属性('力量') + this.获取属性('敏捷') + this.获取属性('智力');
  }

  获取主属性() {
    const 力量 = this.获取属性('力量');
    const 敏捷 = this.获取属性('敏捷');
    const 智力 = this.获取属性('智力');

    if (力量 >= 敏捷 && 力量 >= 智力) return '力量';
    if (敏捷 >= 力量 && 敏捷 >= 智力) return '敏捷';
    return '智力';
  }

  // ─── 成长系统 ───

  记录成长事件(事件描述, 属性变化 = {}) {
    this.成长日志.push({
      时间戳: Date.now(),
      描述: 事件描述,
      属性变化,
    });
  }

  增加经验(数量) {
    const 当前经验 = this.获取属性('经验');
    const 当前等级 = this.获取属性('等级');
    const 新经验 = 当前经验 + 数量;

    this.设置属性('经验', 新经验);

    // 检查升级（每100经验升一级）
    const 升级阈值 = 当前等级 * 100;
    if (新经验 >= 升级阈值) {
      this.设置属性('等级', 当前等级 + 1);
      this.设置属性('经验', 新经验 - 升级阈值);
      return { 升级: true, 新等级: 当前等级 + 1 };
    }

    return { 升级: false };
  }

  // ─── 状态检查 ───

  是否可战斗() {
    return !this.拥有标签('负伤') && !this.拥有标签('外出');
  }

  是否可执行任务() {
    return !this.拥有标签('休息中') && !this.拥有标签('外出');
  }

  // ─── 序列化扩展 ───

  序列化() {
    const 基础数据 = super.序列化();
    return {
      ...基础数据,
      成长日志: [...this.成长日志],
      来源信息: this.来源信息 ? { ...this.来源信息 } : null,
    };
  }

  static 从序列化恢复(数据) {
    const 实体 = super.从序列化恢复(数据, 冠军实体);
    实体.成长日志 = 数据.成长日志 ?? [];
    实体.来源信息 = 数据.来源信息 ?? null;
    return 实体;
  }
}

// ═══════════════════════════════════════════════════════════════
// 母畜实体
// ═══════════════════════════════════════════════════════════════

/**
 * 母畜实体
 * 被俘获的女性，拥有雌性价值、臣服度、淫乱度
 */
class 母畜实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('母畜', 初始数据);

    // 身份信息
    this.设置属性('姓名', 初始数据.姓名 ?? '无名母畜');
    this.设置属性('原身份', 初始数据.原身份 ?? '普通人');
    this.设置属性('种族', 初始数据.种族 ?? '人类');
    this.设置属性('外貌描述', 初始数据.外貌描述 ?? '');
    this.设置属性('年龄', 初始数据.年龄 ?? 20);

    // 核心属性
    const 总雌性价值 = 初始数据.总雌性价值 ?? 100;
    this.设置属性('总雌性价值', 总雌性价值);
    this.设置属性('剩余雌性价值', 初始数据.剩余雌性价值 ?? 总雌性价值);
    this.设置属性('臣服度', 初始数据.臣服度 ?? 0);
    this.设置属性('淫乱度', 初始数据.淫乱度 ?? 0);

    // 捕获状态
    this.设置属性('已捕获', 初始数据.已捕获 ?? false);
    this.设置属性('已锁定', 初始数据.已锁定 ?? false);

    // 来源信息
    this.设置属性('来源类型', 初始数据.来源类型 ?? null); // '袭击' | '劝诱' | '黑市' | '创建'
    this.设置属性('来源目标ID', 初始数据.来源目标ID ?? null); // 袭击目标ID

    // 特殊标签
    if (初始数据.特殊标签) {
      初始数据.特殊标签.forEach(标签 => this.添加标签(标签));
    }

    // 生育记录
    this.生育记录 = {
      冠军: [],
      喽啰总数: 0,
    };
  }

  // ─── 阶段判定 ───

  获取臣服阶段() {
    const 臣服度 = this.获取属性('臣服度');

    if (臣服度 >= 90) return { 名称: '忠诚期', 等级: 5 };
    if (臣服度 >= 75) return { 名称: '归心期', 等级: 4 };
    if (臣服度 >= 50) return { 名称: '顺从期', 等级: 3 };
    if (臣服度 >= 25) return { 名称: '动摇期', 等级: 2 };
    return { 名称: '抗拒期', 等级: 1 };
  }

  获取淫乱阶段() {
    const 淫乱度 = this.获取属性('淫乱度');

    if (淫乱度 >= 100) return { 名称: '完全淫堕', 等级: 5 };
    if (淫乱度 >= 75) return { 名称: '淫堕期', 等级: 4 };
    if (淫乱度 >= 50) return { 名称: '渴求期', 等级: 3 };
    if (淫乱度 >= 25) return { 名称: '泌乳期', 等级: 2 };
    return { 名称: '常态期', 等级: 1 };
  }

  // ─── 能力判定 ───

  可担任任务类型列表() {
    const 臣服度 = this.获取属性('臣服度');
    const 淫乱度 = this.获取属性('淫乱度');
    const 剩余价值 = this.获取属性('剩余雌性价值');
    const 可用任务 = [];

    // 基础：繁殖相关
    if (剩余价值 > 0) {
      if (臣服度 >= 25) {
        可用任务.push('生育喽啰');
      }
      if (剩余价值 >= 100) {
        可用任务.push('生育冠军');
      }
    }

    // 泌乳期以上：泌乳
    if (淫乱度 >= 25) {
      可用任务.push('泌乳');
    }

    // 归心期以上：提振士气、劝慰
    if (臣服度 >= 75) {
      可用任务.push('提振士气');
      可用任务.push('劝慰');
    }

    // 忠诚期：潜入类任务
    if (臣服度 >= 90) {
      可用任务.push('潜入侦察');
      可用任务.push('潜入劝诱');
    }

    // 完全淫堕：可献祭
    if (淫乱度 >= 100) {
      可用任务.push('献祭母畜');
    }

    return 可用任务;
  }

  // ─── 资源消耗 ───

  消耗雌性价值(数量) {
    const 剩余 = this.获取属性('剩余雌性价值');
    if (剩余 < 数量) {
      return { 成功: false, 原因: '剩余雌性价值不足', 当前: 剩余, 需要: 数量 };
    }
    this.设置属性('剩余雌性价值', 剩余 - 数量);
    return { 成功: true, 剩余: 剩余 - 数量 };
  }

  获取雌性价值百分比() {
    const 剩余 = this.获取属性('剩余雌性价值');
    const 总量 = this.获取属性('总雌性价值');
    return 总量 > 0 ? (剩余 / 总量) * 100 : 0;
  }

  // ─── 产出计算 ───

  计算泌乳产量() {
    const 淫乱度 = this.获取属性('淫乱度');
    if (淫乱度 < 25) return 0;
    return Math.floor((淫乱度 + 45) / 20);
  }

  // ─── 生育记录 ───

  记录生育冠军(冠军ID, 冠军姓名) {
    this.生育记录.冠军.push({
      冠军ID,
      冠军姓名,
      时间戳: Date.now(),
    });
  }

  记录生育喽啰(数量) {
    this.生育记录.喽啰总数 += 数量;
  }

  获取生育统计() {
    return {
      冠军数量: this.生育记录.冠军.length,
      喽啰总数: this.生育记录.喽啰总数,
      冠军详情: [...this.生育记录.冠军],
    };
  }

  // ─── 捕获状态管理 ───

  是否已捕获() {
    return this.获取属性('已捕获') === true;
  }

  是否已锁定() {
    return this.获取属性('已锁定') === true;
  }

  锁定() {
    if (!this.是否已捕获()) {
      this.设置属性('已锁定', true);
      this.触发事件('目标锁定', { 实体ID: this.实体ID });
      return true;
    }
    return false;
  }

  取消锁定() {
    this.设置属性('已锁定', false);
  }

  标记捕获(来源类型 = '袭击') {
    if (this.是否已捕获()) return false;

    this.设置属性('已捕获', true);
    this.设置属性('已锁定', false);
    this.设置属性('来源类型', 来源类型);
    this.设置属性('臣服度', 0);
    this.设置属性('淫乱度', 0);
    this.设置属性('剩余雌性价值', this.获取属性('总雌性价值'));

    this.触发事件('目标捕获', {
      实体ID: this.实体ID,
      来源类型,
    });

    return true;
  }

  // ─── 作为高价值目标时的便捷方法 ───

  获取目标概览() {
    return {
      ID: this.实体ID,
      姓名: this.获取属性('姓名'),
      原身份: this.获取属性('原身份'),
      种族: this.获取属性('种族'),
      年龄: this.获取属性('年龄'),
      总雌性价值: this.获取属性('总雌性价值'),
      已锁定: this.是否已锁定(),
      已捕获: this.是否已捕获(),
      特殊标签: this.获取所有标签(),
    };
  }

  // ─── 序列化扩展 ───

  序列化() {
    const 基础数据 = super.序列化();
    return {
      ...基础数据,
      生育记录: {
        冠军: [...this.生育记录.冠军],
        喽啰总数: this.生育记录.喽啰总数,
      },
    };
  }

  static 从序列化恢复(数据) {
    const 实体 = super.从序列化恢复(数据, 母畜实体);
    实体.生育记录 = 数据.生育记录 ?? { 冠军: [], 喽啰总数: 0 };
    return 实体;
  }
}

// ═══════════════════════════════════════════════════════════════
// 喽啰池
// ═══════════════════════════════════════════════════════════════

/**
 * 喽啰池
 * 喽啰以数值形式存在，按武装等级分组管理
 */
class 喽啰池 {
  constructor() {
    this.武装分组 = new Map();

    // 默认分组：未武装
    this.武装分组.set('未武装', {
      数量: 0,
      战斗力: 100,
      描述: '未经武装的喽啰',
    });
  }

  // ─── 武装等级管理 ───

  注册武装等级(等级名, 配置) {
    if (!this.武装分组.has(等级名)) {
      this.武装分组.set(等级名, {
        数量: 0,
        战斗力: 配置.战斗力 ?? 100,
        描述: 配置.描述 ?? '',
        升级自: 配置.升级自 ?? null,
        升级消耗: 配置.升级消耗 ?? null,
      });
    }
  }

  获取武装等级配置(等级名) {
    return this.武装分组.get(等级名);
  }

  获取所有武装等级() {
    return Array.from(this.武装分组.keys());
  }

  // ─── 数量操作 ───

  增加喽啰(数量, 武装等级 = '未武装') {
    const 分组 = this.武装分组.get(武装等级);
    if (!分组) {
      console.warn(`未知武装等级: ${武装等级}，添加到未武装`);
      this.武装分组.get('未武装').数量 += 数量;
      return;
    }
    分组.数量 += 数量;
  }

  减少喽啰(数量, 武装等级 = '未武装') {
    const 分组 = this.武装分组.get(武装等级);
    if (!分组) return { 成功: false, 原因: '未知武装等级' };

    const 实际减少 = Math.min(数量, 分组.数量);
    分组.数量 -= 实际减少;

    return {
      成功: true,
      实际减少,
      剩余: 分组.数量,
    };
  }

  获取分组数量(武装等级) {
    return this.武装分组.get(武装等级)?.数量 ?? 0;
  }

  // ─── 武装升级 ───

  武装升级(数量, 从等级, 到等级) {
    const 源分组 = this.武装分组.get(从等级);
    const 目标分组 = this.武装分组.get(到等级);

    if (!源分组) return { 成功: false, 原因: `未知来源等级: ${从等级}` };
    if (!目标分组) return { 成功: false, 原因: `未知目标等级: ${到等级}` };
    if (源分组.数量 < 数量) {
      return {
        成功: false,
        原因: '来源分组数量不足',
        当前: 源分组.数量,
        需要: 数量,
      };
    }

    源分组.数量 -= 数量;
    目标分组.数量 += 数量;

    return {
      成功: true,
      升级数量: 数量,
      来源剩余: 源分组.数量,
      目标当前: 目标分组.数量,
    };
  }

  批量武装升级(配置列表, 事务模式 = false) {
    /**
     * 配置列表格式: [{ 数量, 从等级, 到等级 }, ...]
     */
    const 结果列表 = [];

    if (事务模式) {
      // 先验证全部可行
      for (const 配置 of 配置列表) {
        if (this.获取分组数量(配置.从等级) < 配置.数量) {
          return { 成功: false, 原因: `${配置.从等级} 数量不足` };
        }
      }
    }

    for (const 配置 of 配置列表) {
      const 结果 = this.武装升级(配置.数量, 配置.从等级, 配置.到等级);
      结果列表.push({ ...配置, ...结果 });

      if (!结果.成功) break; // 失败时中断
    }

    return 结果列表;
  }

  // ─── 统计 ───

  获取总数量() {
    let 总数 = 0;
    this.武装分组.forEach(分组 => {
      总数 += 分组.数量;
    });
    return 总数;
  }

  获取分组详情() {
    return Array.from(this.武装分组.entries()).map(([等级, 数据]) => ({
      等级,
      ...数据,
    }));
  }

  计算加权战斗力() {
    let 加权总和 = 0;
    let 总数量 = 0;

    this.武装分组.forEach(分组 => {
      加权总和 += 分组.数量 * 分组.战斗力;
      总数量 += 分组.数量;
    });

    return 总数量 > 0 ? 加权总和 / 总数量 : 100;
  }

  计算总战斗力() {
    let 总战力 = 0;
    this.武装分组.forEach(分组 => {
      总战力 += 分组.数量 * (分组.战斗力 / 100);
    });
    return 总战力;
  }

  // ─── 分配喽啰 ───

  分配喽啰(需求数量, 优先等级列表 = null) {
    /**
     * 按优先级分配喽啰，返回分配结果
     * 优先等级列表: ['高级', '中级', '低级', '未武装']
     */
    const 等级顺序 = 优先等级列表 ?? Array.from(this.武装分组.keys()).reverse();
    const 分配结果 = [];
    let 剩余需求 = 需求数量;

    for (const 等级 of 等级顺序) {
      if (剩余需求 <= 0) break;

      const 分组 = this.武装分组.get(等级);
      if (!分组 || 分组.数量 === 0) continue;

      const 分配数量 = Math.min(剩余需求, 分组.数量);
      分配结果.push({
        等级,
        数量: 分配数量,
        战斗力: 分组.战斗力,
      });

      剩余需求 -= 分配数量;
    }

    return {
      分配详情: 分配结果,
      已分配: 需求数量 - 剩余需求,
      未满足: 剩余需求,
    };
  }

  // ─── 序列化 ───

  序列化() {
    return {
      分组: Array.from(this.武装分组.entries()).map(([等级, 数据]) => ({
        等级,
        ...数据,
      })),
    };
  }

  static 从序列化恢复(数据) {
    const 池 = new 喽啰池();
    池.武装分组.clear();

    if (数据.分组) {
      数据.分组.forEach(分组数据 => {
        const { 等级, ...配置 } = 分组数据;
        池.武装分组.set(等级, 配置);
      });
    }

    return 池;
  }
}



// ═══════════════════════════════════════════════════════════════
// 袭击目标实体
// ═══════════════════════════════════════════════════════════════

/**
 * 袭击目标实体
 * 表示一个可被袭击的目标（村庄、商队、城市等）
 * 内部的高价值目标直接使用母畜实体（未捕获状态）
 */
class 袭击目标实体 extends 实体基类 {
  constructor(初始数据 = {}) {
    super('袭击目标', 初始数据);

    // 基础信息
    this.设置属性('名称', 初始数据.名称 ?? '未知目标');
    this.设置属性('类型', 初始数据.类型 ?? '村庄');
    this.设置属性('描述', 初始数据.描述 ?? '');
    this.设置属性('位置', 初始数据.位置 ?? '未知');

    // 战斗属性
    this.设置属性('战斗力', 初始数据.战斗力 ?? 50);
    this.设置属性('护卫描述', 初始数据.护卫描述 ?? '');

    // 高价值目标列表（直接使用母畜实体，未捕获状态）
    this.高价值目标列表 = [];
    if (初始数据.高价值目标列表) {
      初始数据.高价值目标列表.forEach(目标 => {
        if (目标 instanceof 母畜实体) {
          目标.设置属性('来源目标ID', this.实体ID);
          this.高价值目标列表.push(目标);
        }
      });
    }

    // 状态
    this.设置属性('已被袭击', 初始数据.已被袭击 ?? false);
    this.设置属性('发现周次', 初始数据.发现周次 ?? null);

    // 额外数据
    this.额外数据 = 初始数据.额外数据 ?? {};
  }

  // ─── 高价值目标管理 ───

  添加高价值目标(母畜实体实例) {
    if (!(母畜实体实例 instanceof 母畜实体)) {
      console.warn('添加的目标必须是母畜实体');
      return false;
    }
    母畜实体实例.设置属性('来源目标ID', this.实体ID);
    this.高价值目标列表.push(母畜实体实例);
    return true;
  }

  获取高价值目标(目标ID) {
    return this.高价值目标列表.find(t => t.实体ID === 目标ID) ?? null;
  }

  获取所有高价值目标() {
    return [...this.高价值目标列表];
  }

  获取已锁定目标() {
    return this.高价值目标列表.filter(t => t.是否已锁定() && !t.是否已捕获());
  }

  获取未锁定目标() {
    return this.高价值目标列表.filter(t => !t.是否已锁定() && !t.是否已捕获());
  }

  获取可俘获目标() {
    return this.高价值目标列表.filter(t => !t.是否已捕获());
  }

  获取高价值目标数量() {
    return this.高价值目标列表.length;
  }

  获取未俘获目标数量() {
    return this.高价值目标列表.filter(t => !t.是否已捕获()).length;
  }

  // ─── 锁定操作 ───

  锁定目标(目标ID) {
    const 目标 = this.获取高价值目标(目标ID);
    if (目标 && !目标.是否已捕获()) {
      return 目标.锁定();
    }
    return false;
  }

  取消锁定目标(目标ID) {
    const 目标 = this.获取高价值目标(目标ID);
    if (目标) {
      目标.取消锁定();
      return true;
    }
    return false;
  }

  // ─── 俘获操作 ───

  俘获目标(目标ID, 来源类型 = '袭击') {
    const 目标 = this.获取高价值目标(目标ID);
    if (目标 && !目标.是否已捕获()) {
      return 目标.标记捕获(来源类型);
    }
    return false;
  }

  批量俘获(目标ID列表, 来源类型 = '袭击') {
    let 成功数 = 0;
    目标ID列表.forEach(id => {
      if (this.俘获目标(id, 来源类型)) {
        成功数++;
      }
    });
    return 成功数;
  }

  俘获所有已锁定目标(来源类型 = '袭击') {
    const 已锁定 = this.获取已锁定目标();
    return this.批量俘获(
      已锁定.map(t => t.实体ID),
      来源类型
    );
  }

  // ─── 状态查询 ───

  是否已被袭击() {
    return this.获取属性('已被袭击');
  }

  标记已袭击() {
    this.设置属性('已被袭击', true);
  }

  是否有剩余目标() {
    return this.获取未俘获目标数量() > 0;
  }

  // ─── 统计信息 ───

  获取目标概览() {
    return {
      ID: this.实体ID,
      名称: this.获取属性('名称'),
      类型: this.获取属性('类型'),
      描述: this.获取属性('描述'),
      位置: this.获取属性('位置'),
      战斗力: this.获取属性('战斗力'),
      高价值目标数: this.高价值目标列表.length,
      已锁定数: this.获取已锁定目标().length,
      未俘获数: this.获取未俘获目标数量(),
      已被袭击: this.是否已被袭击(),
    };
  }

  获取高价值目标详情() {
    return this.高价值目标列表.map(目标 => 目标.获取目标概览());
  }

  // ─── 价值估算 ───

  计算总雌性价值() {
    return this.高价值目标列表.filter(t => !t.是否已捕获()).reduce((sum, t) => sum + t.获取属性('总雌性价值'), 0);
  }

  计算已锁定价值() {
    return this.获取已锁定目标().reduce((sum, t) => sum + t.获取属性('总雌性价值'), 0);
  }

  // ─── 序列化 ───

  序列化() {
    const 基础数据 = super.序列化();
    return {
      ...基础数据,
      高价值目标列表: this.高价值目标列表.map(t => t.序列化()),
      额外数据: this.额外数据,
    };
  }

  static 从序列化恢复(数据) {
    // 先恢复高价值目标列表
    const 恢复的目标列表 = (数据.高价值目标列表 ?? []).map(目标数据 => 母畜实体.从序列化恢复(目标数据));

    // 创建袭击目标实体
    const 实体 = new 袭击目标实体({
      ...数据.属性,
      高价值目标列表: 恢复的目标列表,
      额外数据: 数据.额外数据,
    });

    实体.实体ID = 数据.实体ID;

    if (数据.标签) {
      数据.标签.forEach(t => 实体.状态标签.add(t));
    }

    实体.元数据 = 数据.元数据 ?? {};

    return 实体;
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 实体基类, 领主实体, 冠军实体, 母畜实体, 喽啰池, 袭击目标实体 };

```


src\core\factories.js
```js
// ═══════════════════════════════════════════════════════════════
// core/factories.js
// 工厂类 - 负责创建游戏实体
// ═══════════════════════════════════════════════════════════════

import { 冠军实体, 母畜实体, 袭击目标实体, 领主实体 } from './entities.js';

// ═══════════════════════════════════════════════════════════════
// 冠军工厂
// ═══════════════════════════════════════════════════════════════

/**
 * 冠军工厂
 * 负责创建冠军实体，支持从母畜生育和直接创建
 */
class 冠军工厂 {
  constructor(属性注册表 = null) {
    this.属性注册表 = 属性注册表;

    // 效率系数表：身份类型 -> 属性系数
    this.效率系数表 = new Map();

    // 种族系数表：种族 -> 属性系数
    this.种族系数表 = new Map();

    // 姓名生成器
    this.姓名生成器 = null;
    this.姓名池 = {
      前缀: [],
      主名: [],
      后缀: [],
    };

    // 外貌生成器
    this.外貌生成器 = null;

    // 默认属性范围
    this.默认属性范围 = {
      力量: { 最小: 5, 最大: 20 },
      敏捷: { 最小: 5, 最大: 20 },
      智力: { 最小: 5, 最大: 20 },
    };

    // 生育消耗配置
    this.生育消耗 = 100;

    // 随机浮动范围
    this.随机浮动范围 = 5;
  }

  // ─── 配置方法 ───

  设置属性注册表(注册表) {
    this.属性注册表 = 注册表;
  }

  设置生育消耗(数值) {
    this.生育消耗 = 数值;
  }

  设置随机浮动范围(范围) {
    this.随机浮动范围 = 范围;
  }

  // ─── 效率系数管理 ───

  注册效率系数(身份类型, 系数配置) {
    this.效率系数表.set(身份类型, {
      力量: 系数配置.力量 ?? 1.0,
      敏捷: 系数配置.敏捷 ?? 1.0,
      智力: 系数配置.智力 ?? 1.0,
    });
  }

  批量注册效率系数(配置对象) {
    Object.entries(配置对象).forEach(([身份, 系数]) => {
      this.注册效率系数(身份, 系数);
    });
  }

  获取效率系数(身份类型) {
    return (
      this.效率系数表.get(身份类型) ?? {
        力量: 1.0,
        敏捷: 1.0,
        智力: 1.0,
      }
    );
  }

  获取所有效率系数() {
    return Object.fromEntries(this.效率系数表);
  }

  // ─── 种族系数管理 ───

  注册种族系数(种族, 系数配置) {
    this.种族系数表.set(种族, {
      力量: 系数配置.力量 ?? 1.0,
      敏捷: 系数配置.敏捷 ?? 1.0,
      智力: 系数配置.智力 ?? 1.0,
    });
  }

  批量注册种族系数(配置对象) {
    Object.entries(配置对象).forEach(([种族, 系数]) => {
      this.注册种族系数(种族, 系数);
    });
  }

  获取种族系数(种族) {
    return (
      this.种族系数表.get(种族) ?? {
        力量: 1.0,
        敏捷: 1.0,
        智力: 1.0,
      }
    );
  }

  // ─── 姓名生成器 ───

  设置姓名生成器(生成函数) {
    this.姓名生成器 = 生成函数;
  }

  设置姓名池(池配置) {
    if (池配置.前缀) this.姓名池.前缀 = 池配置.前缀;
    if (池配置.主名) this.姓名池.主名 = 池配置.主名;
    if (池配置.后缀) this.姓名池.后缀 = 池配置.后缀;
  }

  生成随机姓名(上下文 = {}) {
    if (this.姓名生成器) {
      return this.姓名生成器(上下文);
    }

    if (this.姓名池.主名.length > 0) {
      const 随机选择 = 数组 => {
        if (!数组 || 数组.length === 0) return '';
        return 数组[Math.floor(Math.random() * 数组.length)];
      };

      const 前缀 = Math.random() < 0.3 ? 随机选择(this.姓名池.前缀) : '';
      const 主名 = 随机选择(this.姓名池.主名);
      const 后缀 = Math.random() < 0.2 ? 随机选择(this.姓名池.后缀) : '';

      return `${前缀}${主名}${后缀}`.trim();
    }

    return `冠军_${Date.now().toString(36).slice(-4)}`;
  }

  // ─── 外貌生成器 ───

  设置外貌生成器(生成函数) {
    this.外貌生成器 = 生成函数;
  }

  生成随机外貌(上下文 = {}) {
    if (this.外貌生成器) {
      return this.外貌生成器(上下文);
    }
    return '';
  }

  // ─── 属性计算辅助 ───

  计算随机浮动() {
    const 范围 = this.随机浮动范围;
    return Math.floor(Math.random() * (范围 * 2 + 1)) - 范围;
  }

  计算属性值(基础值, 效率系数, 种族系数 = 1.0) {
    const 浮动 = this.计算随机浮动();
    const 原始值 = (基础值 + 浮动) * 效率系数 * 种族系数;
    return Math.max(1, Math.round(原始值));
  }

  // ─── 创建方法 ───

  从母畜生育(母畜, 选项 = {}) {
    const 剩余价值 = 母畜.获取属性('剩余雌性价值');
    if (剩余价值 < this.生育消耗) {
      return {
        成功: false,
        原因: '剩余雌性价值不足',
        当前: 剩余价值,
        需要: this.生育消耗,
      };
    }

    const 母畜身份 = 母畜.获取属性('原身份');
    const 母畜种族 = 母畜.获取属性('种族');
    const 总雌性价值 = 母畜.获取属性('总雌性价值');

    const 效率系数 = this.获取效率系数(母畜身份);
    const 种族系数 = this.获取种族系数(母畜种族);

    const 基础值 = 总雌性价值 / 10;

    const 力量 = this.计算属性值(基础值, 效率系数.力量, 种族系数.力量);
    const 敏捷 = this.计算属性值(基础值, 效率系数.敏捷, 种族系数.敏捷);
    const 智力 = this.计算属性值(基础值, 效率系数.智力, 种族系数.智力);

    const 生成上下文 = {
      母畜,
      母畜身份,
      母畜种族,
      性别: 选项.性别 ?? '男',
      ...选项,
    };

    const 姓名 = 选项.姓名 ?? this.生成随机姓名(生成上下文);
    const 外貌描述 = 选项.外貌描述 ?? this.生成随机外貌(生成上下文);

    const 冠军数据 = {
      姓名,
      外貌描述,
      性别: 生成上下文.性别,
      力量,
      敏捷,
      智力,
      来源信息: {
        类型: '生育',
        母畜ID: 母畜.实体ID,
        母畜姓名: 母畜.获取属性('姓名'),
        母畜身份,
        母畜种族,
        母畜总雌性价值: 总雌性价值,
        出生时间: Date.now(),
      },
    };

    const 新冠军 = new 冠军实体(冠军数据);

    新冠军.记录成长事件(`由${母畜.获取属性('姓名')}(${母畜身份})所生`, { 力量, 敏捷, 智力 });

    if (选项.标签) {
      选项.标签.forEach(标签 => 新冠军.添加标签(标签));
    }

    if (选项.继承标签) {
      选项.继承标签.forEach(标签 => {
        if (母畜.拥有标签(标签)) {
          新冠军.添加标签(标签);
        }
      });
    }

    return {
      成功: true,
      冠军: 新冠军,
      消耗雌性价值: this.生育消耗,
      属性: { 力量, 敏捷, 智力 },
    };
  }

  直接创建(配置) {
    let 力量, 敏捷, 智力;

    if (配置.属性等级) {
      const 属性 = this.根据等级生成属性(配置.属性等级);
      力量 = 配置.力量 ?? 属性.力量;
      敏捷 = 配置.敏捷 ?? 属性.敏捷;
      智力 = 配置.智力 ?? 属性.智力;
    } else {
      力量 = 配置.力量 ?? this.随机属性值('力量');
      敏捷 = 配置.敏捷 ?? this.随机属性值('敏捷');
      智力 = 配置.智力 ?? this.随机属性值('智力');
    }

    const 生成上下文 = {
      性别: 配置.性别 ?? '男',
      来源: 配置.来源 ?? '未知',
      ...配置,
    };

    const 冠军数据 = {
      姓名: 配置.姓名 ?? this.生成随机姓名(生成上下文),
      外貌描述: 配置.外貌描述 ?? this.生成随机外貌(生成上下文),
      性别: 生成上下文.性别,
      力量,
      敏捷,
      智力,
      经验: 配置.经验 ?? 0,
      等级: 配置.等级 ?? 1,
      来源信息: {
        类型: 配置.来源类型 ?? '创建',
        来源: 配置.来源 ?? '未知',
        创建时间: Date.now(),
        备注: 配置.备注 ?? null,
      },
    };

    const 新冠军 = new 冠军实体(冠军数据);

    if (配置.标签) {
      配置.标签.forEach(标签 => 新冠军.添加标签(标签));
    }

    新冠军.记录成长事件(`来源: ${配置.来源 ?? '未知'}`);

    return 新冠军;
  }

  // ─── 辅助方法 ───

  随机属性值(属性名) {
    const 范围 = this.默认属性范围[属性名] ?? { 最小: 5, 最大: 20 };
    return Math.floor(Math.random() * (范围.最大 - 范围.最小 + 1)) + 范围.最小;
  }

  根据等级生成属性(等级) {
    const 等级配置 = {
      弱小: { 基础: 5, 浮动: 3 },
      普通: { 基础: 10, 浮动: 5 },
      精英: { 基础: 20, 浮动: 5 },
      传奇: { 基础: 35, 浮动: 10 },
    };

    const 配置 = 等级配置[等级] ?? 等级配置.普通;
    const 生成 = () => 配置.基础 + Math.floor(Math.random() * (配置.浮动 * 2 + 1)) - 配置.浮动;

    return {
      力量: Math.max(1, 生成()),
      敏捷: Math.max(1, 生成()),
      智力: Math.max(1, 生成()),
    };
  }

  批量创建(数量, 配置模板 = {}) {
    const 冠军列表 = [];

    for (let i = 0; i < 数量; i++) {
      const 个体配置 = {
        ...配置模板,
        姓名: 配置模板.固定姓名 ? 配置模板.姓名 : null,
      };
      冠军列表.push(this.直接创建(个体配置));
    }

    return 冠军列表;
  }

  // ─── 预估方法 ───

  预估生育属性(母畜) {
    const 母畜身份 = 母畜.获取属性('原身份');
    const 母畜种族 = 母畜.获取属性('种族');
    const 总雌性价值 = 母畜.获取属性('总雌性价值');

    const 效率系数 = this.获取效率系数(母畜身份);
    const 种族系数 = this.获取种族系数(母畜种族);

    const 基础值 = 总雌性价值 / 10;
    const 范围 = this.随机浮动范围;

    return {
      力量: {
        最小: Math.max(1, Math.round((基础值 - 范围) * 效率系数.力量 * 种族系数.力量)),
        最大: Math.round((基础值 + 范围) * 效率系数.力量 * 种族系数.力量),
        期望: Math.round(基础值 * 效率系数.力量 * 种族系数.力量),
      },
      敏捷: {
        最小: Math.max(1, Math.round((基础值 - 范围) * 效率系数.敏捷 * 种族系数.敏捷)),
        最大: Math.round((基础值 + 范围) * 效率系数.敏捷 * 种族系数.敏捷),
        期望: Math.round(基础值 * 效率系数.敏捷 * 种族系数.敏捷),
      },
      智力: {
        最小: Math.max(1, Math.round((基础值 - 范围) * 效率系数.智力 * 种族系数.智力)),
        最大: Math.round((基础值 + 范围) * 效率系数.智力 * 种族系数.智力),
        期望: Math.round(基础值 * 效率系数.智力 * 种族系数.智力),
      },
    };
  }
}

// ═══════════════════════════════════════════════════════════════
// 母畜工厂
// ═══════════════════════════════════════════════════════════════

/**
 * 母畜工厂
 * 负责创建母畜实体，支持多种来源
 */
class 母畜工厂 {
  constructor(属性注册表 = null) {
    this.属性注册表 = 属性注册表;

    // 女性随机配置（可选注入）
    this.女性随机配置 = null;

    // 身份价值表：身份类型 -> 价值范围
    this.身份价值表 = new Map();

    // 种族价值修正表
    this.种族价值修正表 = new Map();

    // 姓名生成器
    this.姓名生成器 = null;
    this.姓名池 = {
      人类: [],
      精灵: [],
      兽人: [],
      通用: [],
    };

    // 外貌生成器
    this.外貌生成器 = null;

    // 默认价值范围
    this.默认价值范围 = { 最小: 80, 最大: 120 };
  }

  // ─── 配置方法 ───

  设置属性注册表(注册表) {
    this.属性注册表 = 注册表;
  }

  设置女性随机配置(配置实例) {
    this.女性随机配置 = 配置实例;
  }

  // ─── 身份价值管理 ───

  注册身份价值(身份类型, 价值范围) {
    this.身份价值表.set(身份类型, {
      最小: 价值范围.最小 ?? 价值范围.固定 ?? 100,
      最大: 价值范围.最大 ?? 价值范围.固定 ?? 100,
      固定: 价值范围.固定 ?? null,
    });
  }

  批量注册身份价值(配置对象) {
    Object.entries(配置对象).forEach(([身份, 范围]) => {
      this.注册身份价值(身份, 范围);
    });
  }

  获取身份价值范围(身份类型) {
    return this.身份价值表.get(身份类型) ?? { ...this.默认价值范围 };
  }

  获取所有身份价值() {
    return Object.fromEntries(this.身份价值表);
  }

  // ─── 种族修正管理 ───

  注册种族价值修正(种族, 修正配置) {
    this.种族价值修正表.set(种族, {
      乘数: 修正配置.乘数 ?? 1.0,
      加成: 修正配置.加成 ?? 0,
    });
  }

  获取种族价值修正(种族) {
    return this.种族价值修正表.get(种族) ?? { 乘数: 1.0, 加成: 0 };
  }

  // ─── 姓名生成器 ───

  设置姓名生成器(生成函数) {
    this.姓名生成器 = 生成函数;
  }

  设置姓名池(种族, 姓名列表) {
    this.姓名池[种族] = 姓名列表;
  }

  批量设置姓名池(配置) {
    Object.entries(配置).forEach(([种族, 列表]) => {
      this.姓名池[种族] = 列表;
    });
  }

  生成随机姓名(上下文 = {}) {
    if (this.姓名生成器) {
      return this.姓名生成器(上下文);
    }

    const 种族 = 上下文.种族 ?? '人类';
    let 候选池 = this.姓名池[种族];

    if (!候选池 || 候选池.length === 0) {
      候选池 = this.姓名池.通用;
    }

    if (候选池 && 候选池.length > 0) {
      return 候选池[Math.floor(Math.random() * 候选池.length)];
    }

    return `女子_${Date.now().toString(36).slice(-4)}`;
  }

  // ─── 外貌生成器 ───

  设置外貌生成器(生成函数) {
    this.外貌生成器 = 生成函数;
  }

  生成随机外貌(上下文 = {}) {
    if (this.外貌生成器) {
      return this.外貌生成器(上下文);
    }
    return '';
  }

  // ─── 价值计算 ───

  计算总雌性价值(身份, 种族 = '人类', 选项 = {}) {
    const 范围 = this.获取身份价值范围(身份);

    let 基础价值;
    if (范围.固定 !== null) {
      基础价值 = 范围.固定;
    } else {
      基础价值 = Math.floor(Math.random() * (范围.最大 - 范围.最小 + 1)) + 范围.最小;
    }

    const 修正 = this.获取种族价值修正(种族);
    let 最终价值 = Math.round(基础价值 * 修正.乘数 + 修正.加成);

    if (选项.价值修正) {
      最终价值 = Math.round(最终价值 * (选项.价值修正.乘数 ?? 1.0) + (选项.价值修正.加成 ?? 0));
    }

    return Math.max(10, 最终价值);
  }

  // ─── 创建方法 ───

  创建母畜(配置) {
    const 身份 = 配置.原身份 ?? '普通人';
    const 种族 = 配置.种族 ?? '人类';
    const 年龄 = 配置.年龄 ?? 20 + Math.floor(Math.random() * 10);

    const 总雌性价值 = 配置.总雌性价值 ?? this.计算总雌性价值(身份, 种族, 配置);

    const 生成上下文 = {
      原身份: 身份,
      种族,
      年龄,
      ...配置,
    };

    const 母畜数据 = {
      姓名: 配置.姓名 ?? this.生成随机姓名(生成上下文),
      原身份: 身份,
      种族,
      年龄,
      外貌描述: 配置.外貌描述 ?? this.生成随机外貌(生成上下文),
      总雌性价值,
      剩余雌性价值: 配置.剩余雌性价值 ?? 总雌性价值,
      臣服度: 配置.臣服度 ?? 0,
      淫乱度: 配置.淫乱度 ?? 0,
      特殊标签: 配置.特殊标签 ?? [],
      已捕获: 配置.已捕获 ?? true,
      已锁定: 配置.已锁定 ?? false,
      来源类型: 配置.来源类型 ?? '创建',
    };

    const 新母畜 = new 母畜实体(母畜数据);

    新母畜.元数据.来源 = 配置.来源 ?? '未知';
    新母畜.元数据.来源类型 = 配置.来源类型 ?? '创建';
    新母畜.元数据.俘获时间 = 配置.俘获时间 ?? Date.now();

    if (配置.额外标签) {
      配置.额外标签.forEach(标签 => 新母畜.添加标签(标签));
    }

    return 新母畜;
  }

  // ─── 从高价值目标创建（俘获） ───

  从高价值目标创建(母畜实体实例) {
    /**
     * 从已存在的高价值目标（母畜实体）转化为正式母畜
     * 不进行随机，直接继承所有属性
     */
    if (母畜实体实例.是否已捕获()) {
      return 母畜实体实例;
    }

    母畜实体实例.标记捕获('袭击');

    return 母畜实体实例;
  }

  // ─── 从劝诱创建 ───

  从劝诱创建(母畜实体实例) {
    /**
     * 从潜入劝诱成功的目标创建母畜
     * 不进行随机，直接继承属性，但来源类型不同
     */
    if (母畜实体实例.是否已捕获()) {
      return 母畜实体实例;
    }

    母畜实体实例.标记捕获('劝诱');
    母畜实体实例.设置属性('臣服度', 20);

    return 母畜实体实例;
  }

  // ─── 从黑市购买创建 ───

  从黑市购买创建(商品配置) {
    /**
     * 从黑市购买创建母畜
     * 需要进行随机生成
     */
    if (this.女性随机配置) {
      const 随机属性 = this.女性随机配置.为黑市商品生成(商品配置);

      return this.创建母畜({
        ...随机属性,
        臣服度: 商品配置.初始臣服度 ?? 10,
        来源: `黑市购买: ${商品配置.商品名称 ?? '奴隶'}`,
        来源类型: '黑市',
        已捕获: true,
      });
    }

    return false;
  }

  // ─── 旧方法兼容 ───

  从战斗俘获创建(战利品配置) {
    /**
     * @deprecated 使用 从高价值目标创建 代替
     */
    return this.创建母畜({
      ...战利品配置.目标信息,
      臣服度: 战利品配置.初始臣服度 ?? 0,
      淫乱度: 0,
      来源: 战利品配置.俘获来源 ?? '战斗俘获',
      来源类型: '袭击',
      已捕获: true,
    });
  }

  // ─── 批量创建 ───

  批量创建(数量, 配置模板 = {}) {
    const 母畜列表 = [];

    for (let i = 0; i < 数量; i++) {
      const 个体配置 = {
        ...配置模板,
        姓名: 配置模板.固定姓名 ? 配置模板.姓名 : null,
        总雌性价值: 配置模板.固定价值 ? 配置模板.总雌性价值 : null,
      };
      母畜列表.push(this.创建母畜(个体配置));
    }

    return 母畜列表;
  }

  // ─── 预估方法 ───

  预估身份价值(身份, 种族 = '人类') {
    const 范围 = this.获取身份价值范围(身份);
    const 修正 = this.获取种族价值修正(种族);

    return {
      最小: Math.round(范围.最小 * 修正.乘数 + 修正.加成),
      最大: Math.round(范围.最大 * 修正.乘数 + 修正.加成),
      期望: Math.round(((范围.最小 + 范围.最大) / 2) * 修正.乘数 + 修正.加成),
    };
  }
}

// ═══════════════════════════════════════════════════════════════
// 领主工厂
// ═══════════════════════════════════════════════════════════════

/**
 * 领主工厂
 * 负责创建领主实体
 */
class 领主工厂 {
  constructor() {
    this.默认配置 = {
      魔力: 0,
      最大魔力: 100,
      姓名: '无名领主',
    };
  }

  设置默认配置(配置) {
    this.默认配置 = { ...this.默认配置, ...配置 };
  }

  创建领主(配置 = {}) {
    return new 领主实体({
      ...this.默认配置,
      ...配置,
    });
  }
}

// ═══════════════════════════════════════════════════════════════
// 袭击目标工厂
// ═══════════════════════════════════════════════════════════════

/**
 * 袭击目标工厂
 * 负责生成随机的袭击目标及其高价值目标
 */
class 袭击目标工厂 {
  constructor(女性随机配置实例 = null, 公式引擎 = null) {
    this.女性随机配置 = 女性随机配置实例;
    this.公式引擎 = 公式引擎;

    // 类型配置
    this.类型配置 = new Map();

    // 难度系数
    this.难度系数 = {
      简单: 0.7,
      普通: 1.0,
      困难: 1.3,
      噩梦: 1.6,
    };

    // 当前难度
    this.当前难度 = '普通';
  }

  // ─── 配置方法 ───

  设置女性随机配置(配置实例) {
    this.女性随机配置 = 配置实例;
  }

  设置公式引擎(引擎) {
    this.公式引擎 = 引擎;
  }

  注册目标类型(类型名, 配置) {
    /**
     * 配置示例:
     * {
     *   战力范围: { 最小: 20, 最大: 80 },
     *   高价值目标数量: { 最小: 1, 最大: 3 },
     *   描述模板: ['偏远的小村庄', '宁静的农业村落'],
     *   位置类型: ['平原', '山区', '河谷'],
     *   高价值目标身份池: ['农家女', '村长之女'],
     *   稀有身份概率: 0.1,
     *   稀有身份池: ['商人之女', '低阶冒险者'],
     *   种族权重覆盖: { 人类: 80, 精灵: 20 },  // 可选
     *   特殊标签: ['神圣'],  // 可选
     * }
     */
    this.类型配置.set(类型名, 配置);
  }

  批量注册目标类型(配置对象) {
    Object.entries(配置对象).forEach(([类型, 配置]) => {
      this.注册目标类型(类型, 配置);
    });
  }

  设置难度(难度) {
    if (this.难度系数[难度]) {
      this.当前难度 = 难度;
    }
  }

  获取难度系数() {
    return this.难度系数[this.当前难度] ?? 1.0;
  }

  // ─── 工具方法 ───

  随机选择(数组) {
    if (!数组 || 数组.length === 0) return null;
    return 数组[Math.floor(Math.random() * 数组.length)];
  }

  随机范围(最小, 最大) {
    return Math.floor(Math.random() * (最大 - 最小 + 1)) + 最小;
  }

  // ─── 高价值目标生成 ───

  // 袭击目标工厂中的方法
  生成高价值目标(类型配置, 选项 = {}) {
    if (!this.女性随机配置) {
      throw new Error('女性随机配置未设置');
    }

    // 构建约束条件
    const 约束条件 = {
      身份池: 类型配置.高价值目标身份池,
    };

    // 处理稀有身份
    if (类型配置.稀有身份池 && Math.random() < (类型配置.稀有身份概率 ?? 0)) {
      约束条件.身份池 = 类型配置.稀有身份池;
    }

    // 处理种族权重覆盖
    if (类型配置.种族权重覆盖) {
      约束条件.种族权重覆盖 = 类型配置.种族权重覆盖;
    }

    // 处理特殊标签
    if (类型配置.特殊标签) {
      约束条件.额外标签 = 类型配置.特殊标签;
    }

    // 使用女性随机配置生成基础属性
    const 随机属性 = this.女性随机配置.随机生成(约束条件);

    // 创建母畜实体（未捕获状态）
    const 目标 = new 母畜实体({
      ...随机属性,
      已捕获: false,
      已锁定: false,
      来源类型: '袭击',
    });

    return 目标;
  }

  // ─── 袭击目标生成 ───

  生成袭击目标(类型, 选项 = {}) {
    const 类型配置 = this.类型配置.get(类型);
    if (!类型配置) {
      throw new Error(`未知的袭击目标类型: ${类型}`);
    }

    // 计算战斗力
    const 基础战力 = this.随机范围(类型配置.战力范围.最小, 类型配置.战力范围.最大);
    const 难度系数 = this.难度系数[选项.难度] ?? this.获取难度系数();
    const 实际战力 = Math.floor(基础战力 * 难度系数);

    // 确定高价值目标数量
    const 数量配置 = 类型配置.高价值目标数量;
    const 目标数量 = 选项.高价值目标数量 ?? this.随机范围(数量配置.最小, 数量配置.最大);

    // 生成高价值目标列表
    const 高价值目标列表 = [];
    for (let i = 0; i < 目标数量; i++) {
      高价值目标列表.push(this.生成高价值目标(类型配置, 选项));
    }

    // 生成描述和位置
    const 描述 = 选项.描述 ?? this.随机选择(类型配置.描述模板 ?? []);
    const 位置 = 选项.位置 ?? this.随机选择(类型配置.位置类型 ?? []);

    // 生成名称
    const 名称 = 选项.名称 ?? this.生成目标名称(类型, 位置);

    // 生成护卫描述
    const 护卫描述 = this.生成护卫描述(类型, 实际战力);

    // 创建实体
    const 目标 = new 袭击目标实体({
      名称,
      类型,
      描述,
      位置,
      战斗力: 实际战力,
      护卫描述,
      高价值目标列表,
      发现周次: 选项.发现周次 ?? null,
      额外数据: {
        难度: 选项.难度 ?? this.当前难度,
        生成时间: Date.now(),
      },
    });

    return 目标;
  }

  生成目标名称(类型, 位置) {
    const 名称模板 = {
      村庄: ['${位置}村', '${随机}村', '${位置}的小村'],
      商队: ['${位置}商队', '过路商队', '远方的商队'],
      城镇: ['${位置}镇', '${随机}城镇', '边境城镇'],
      城市: ['${随机}城', '${位置}城', '${随机}都'],
      要塞: ['${位置}要塞', '${随机}堡', '边境堡垒'],
      修道院: ['${位置}修道院', '圣${随机}院', '隐修院'],
      冒险者营地: ['${位置}营地', '探险者营地', '临时营地'],
      贵族庄园: ['${随机}庄园', '${位置}领主府', '贵族宅邸'],
    };

    const 随机字 = ['安', '宁', '和', '平', '丰', '盛', '明', '清', '瑞', '祥'];

    const 模板列表 = 名称模板[类型] ?? ['未知地点'];
    let 名称 = this.随机选择(模板列表);

    名称 = 名称.replace('${位置}', 位置 ?? '');
    名称 = 名称.replace('${随机}', this.随机选择(随机字));

    return 名称.trim() || '未知地点';
  }

  生成护卫描述(类型, 战力) {
    if (战力 < 50) return '几乎没有防御力量';
    if (战力 < 100) return '少量民兵守卫';
    if (战力 < 200) return '有一定数量的卫兵';
    if (战力 < 400) return '驻扎着士兵和少量骑士';
    if (战力 < 600) return '有精锐骑士团驻守';
    return '重兵把守，防御森严';
  }

  // ─── 批量生成 ───

  批量生成(配置列表) {
    /**
     * @param 配置列表 - [{ 类型, 选项? }, ...]
     */
    return 配置列表.map(({ 类型, 选项 }) => this.生成袭击目标(类型, 选项 ?? {}));
  }

  随机生成多个(数量, 允许类型 = null) {
    const 可用类型 = 允许类型 ?? Array.from(this.类型配置.keys());
    const 结果 = [];

    for (let i = 0; i < 数量; i++) {
      const 类型 = this.随机选择(可用类型);
      if (类型) {
        结果.push(this.生成袭击目标(类型));
      }
    }

    return 结果;
  }

  按难度递进生成(周次) {
    const 所有类型 = Array.from(this.类型配置.keys());
    if (所有类型.length === 0) {
      throw new Error('未注册任何目标类型');
    }

    // 早期只生成简单目标
    if (周次 <= 4) {
      const 早期类型 = 所有类型.filter(t => ['村庄', '商队'].includes(t));
      const 类型 = this.随机选择(早期类型.length > 0 ? 早期类型 : 所有类型);
      return this.生成袭击目标(类型, { 难度: '简单' });
    }

    // 中期
    if (周次 <= 12) {
      const 中期类型 = 所有类型.filter(t => ['村庄', '商队', '城镇', '冒险者营地', '修道院'].includes(t));
      const 类型 = this.随机选择(中期类型.length > 0 ? 中期类型 : 所有类型);
      return this.生成袭击目标(类型, { 难度: '普通' });
    }

    // 后期
    if (周次 <= 24) {
      const 后期类型 = 所有类型.filter(t => ['城镇', '城市', '要塞', '贵族庄园', '修道院'].includes(t));
      const 类型 = this.随机选择(后期类型.length > 0 ? 后期类型 : 所有类型);
      const 难度 = Math.random() < 0.3 ? '困难' : '普通';
      return this.生成袭击目标(类型, { 难度 });
    }

    // 末期全面开放
    const 难度选项 = ['普通', '困难', '噩梦'];
    const 难度 = this.随机选择(难度选项);
    return this.生成袭击目标(this.随机选择(所有类型), { 难度 });
  }
}

// ═══════════════════════════════════════════════════════════════
// 工厂管理器
// ═══════════════════════════════════════════════════════════════

/**
 * 工厂管理器
 * 统一管理所有工厂实例
 */
class 工厂管理器 {
  constructor(属性注册表 = null) {
    this.冠军工厂 = new 冠军工厂(属性注册表);
    this.母畜工厂 = new 母畜工厂(属性注册表);
    this.领主工厂 = new 领主工厂();
    this.袭击目标工厂 = new 袭击目标工厂();
    this.属性注册表 = 属性注册表;

    // 女性随机配置
    this.女性随机配置 = null;

    // 自定义工厂扩展
    this.扩展工厂 = new Map();
  }

  设置属性注册表(注册表) {
    this.属性注册表 = 注册表;
    this.冠军工厂.设置属性注册表(注册表);
    this.母畜工厂.设置属性注册表(注册表);
  }

  设置女性随机配置(配置实例) {
    this.女性随机配置 = 配置实例;
    this.母畜工厂.设置女性随机配置(配置实例);
    this.袭击目标工厂.设置女性随机配置(配置实例);
  }

  设置公式引擎(引擎) {
    this.袭击目标工厂.设置公式引擎(引擎);
  }

  // ─── 工厂访问 ───

  获取冠军工厂() {
    return this.冠军工厂;
  }

  获取母畜工厂() {
    return this.母畜工厂;
  }

  获取领主工厂() {
    return this.领主工厂;
  }

  获取袭击目标工厂() {
    return this.袭击目标工厂;
  }

  // ─── 扩展工厂 ───

  注册扩展工厂(名称, 工厂实例) {
    this.扩展工厂.set(名称, 工厂实例);
  }

  获取扩展工厂(名称) {
    return this.扩展工厂.get(名称);
  }

  // ─── 快捷创建方法 ───

  创建冠军(配置) {
    return this.冠军工厂.直接创建(配置);
  }

  创建母畜(配置) {
    return this.母畜工厂.创建母畜(配置);
  }

  创建领主(配置) {
    return this.领主工厂.创建领主(配置);
  }

  从母畜生育冠军(母畜, 选项) {
    return this.冠军工厂.从母畜生育(母畜, 选项);
  }

  // ─── 袭击目标相关快捷方法 ───

  创建袭击目标(类型, 选项) {
    return this.袭击目标工厂.生成袭击目标(类型, 选项);
  }

  俘获高价值目标(母畜实体实例) {
    return this.母畜工厂.从高价值目标创建(母畜实体实例);
  }

  劝诱高价值目标(母畜实体实例) {
    return this.母畜工厂.从劝诱创建(母畜实体实例);
  }

  从黑市购买母畜(商品配置) {
    return this.母畜工厂.从黑市购买创建(商品配置);
  }

  // ─── 批量俘获 ───

  批量俘获目标(母畜实体列表) {
    return 母畜实体列表.map(实体 => this.俘获高价值目标(实体));
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 冠军工厂, 工厂管理器, 母畜工厂, 袭击目标工厂, 领主工厂 };
```


src\core\registries.js
```js
// ═══════════════════════════════════════════════════════════════
// core/registries.js
// 注册表系统 - 管理游戏中的各类定义
// ═══════════════════════════════════════════════════════════════

/**
 * 属性定义注册表
 * 管理所有属性类型的定义、范围、阶段
 */
class 属性定义注册表 {
  constructor() {
    this.属性类型映射 = new Map();
    this.属性计算器映射 = new Map();
    this.属性验证器映射 = new Map();
  }

  // ─── 属性类型注册 ───

  注册属性类型(属性名, 配置) {
    this.属性类型映射.set(属性名, {
      默认值: 配置.默认值 ?? 0,
      最小值: 配置.最小值 ?? 0,
      最大值: 配置.最大值 ?? Infinity,
      阶段定义: 配置.阶段定义 ?? [],
      衰减配置: 配置.衰减配置 ?? null,
      增长配置: 配置.增长配置 ?? null,
      描述: 配置.描述 ?? '',
      单位: 配置.单位 ?? '',
      ...配置,
    });
  }

  注册属性计算器(属性名, 计算函数) {
    /**
     * 计算函数签名: (上下文) => 计算值
     * 用于派生属性的动态计算
     */
    this.属性计算器映射.set(属性名, 计算函数);
  }

  注册属性验证器(属性名, 验证函数) {
    /**
     * 验证函数签名: (新值, 上下文) => { 有效: boolean, 原因?: string }
     */
    if (!this.属性验证器映射.has(属性名)) {
      this.属性验证器映射.set(属性名, []);
    }
    this.属性验证器映射.get(属性名).push(验证函数);
  }

  // ─── 属性查询 ───

  获取属性配置(属性名) {
    return this.属性类型映射.get(属性名);
  }

  获取所有属性() {
    return Array.from(this.属性类型映射.entries()).map(([名称, 配置]) => ({
      名称,
      ...配置,
    }));
  }

  是否已注册(属性名) {
    return this.属性类型映射.has(属性名);
  }

  // ─── 属性阶段 ───

  获取属性阶段(属性名, 当前值) {
    const 配置 = this.属性类型映射.get(属性名);
    if (!配置?.阶段定义?.length) return null;

    for (const 阶段 of 配置.阶段定义) {
      if (当前值 >= 阶段.下限 && 当前值 <= 阶段.上限) {
        return { ...阶段 };
      }
    }

    return null;
  }

  获取下一阶段(属性名, 当前值) {
    const 配置 = this.属性类型映射.get(属性名);
    if (!配置?.阶段定义?.length) return null;

    const 当前阶段 = this.获取属性阶段(属性名, 当前值);
    if (!当前阶段) return null;

    const 当前索引 = 配置.阶段定义.findIndex(阶段 => 阶段.名称 === 当前阶段.名称);

    if (当前索引 < 配置.阶段定义.length - 1) {
      return { ...配置.阶段定义[当前索引 + 1] };
    }

    return null; // 已是最高阶段
  }

  // ─── 派生属性计算 ───

  计算派生属性(属性名, 上下文) {
    const 计算器 = this.属性计算器映射.get(属性名);
    return 计算器 ? 计算器(上下文) : null;
  }

  // ─── 属性验证 ───

  验证属性值(属性名, 新值, 上下文 = {}) {
    // 范围验证
    const 配置 = this.属性类型映射.get(属性名);
    if (配置) {
      if (新值 < 配置.最小值) {
        return { 有效: false, 原因: `低于最小值 ${配置.最小值}` };
      }
      if (新值 > 配置.最大值) {
        return { 有效: false, 原因: `超过最大值 ${配置.最大值}` };
      }
    }

    // 自定义验证器
    const 验证器列表 = this.属性验证器映射.get(属性名) ?? [];
    for (const 验证器 of 验证器列表) {
      const 结果 = 验证器(新值, 上下文);
      if (!结果.有效) {
        return 结果;
      }
    }

    return { 有效: true };
  }

  // ─── 值规范化 ───

  规范化属性值(属性名, 值) {
    const 配置 = this.属性类型映射.get(属性名);
    if (!配置) return 值;

    return Math.max(配置.最小值, Math.min(配置.最大值, 值));
  }
}

// ═══════════════════════════════════════════════════════════════
// 任务定义注册表
// ═══════════════════════════════════════════════════════════════

/**
 * 任务定义注册表
 * 管理所有任务类型的定义、条件、执行器
 */
class 任务定义注册表 {
  constructor() {
    // 核心映射
    this.任务类型映射 = new Map();
    this.任务执行器映射 = new Map();
    this.任务验证器映射 = new Map();

    // 系统依赖
    this.系统依赖 = new Map();

    // 任务分类索引
    this.分类索引 = new Map();

    // 任务统计
    this.执行统计 = new Map();
  }

  // ─── 系统依赖管理 ───

  注入系统依赖(依赖配置) {
    Object.entries(依赖配置).forEach(([名称, 系统]) => {
      this.系统依赖.set(名称, 系统);
    });
  }

  获取系统(系统名) {
    return this.系统依赖.get(系统名);
  }

  移除系统依赖(系统名) {
    this.系统依赖.delete(系统名);
  }

  更新系统依赖(系统名, 新系统) {
    this.系统依赖.set(系统名, 新系统);
  }

  // ─── 任务类型注册 ───

  注册任务类型(任务名, 定义) {
    const 完整定义 = {
      // 基础配置
      行动点消耗: 定义.行动点消耗 ?? 1,
      负责人类型: 定义.负责人类型 ?? [],
      负责人条件: 定义.负责人条件 ?? (() => true),

      // 效果配置
      效率属性: 定义.效率属性 ?? [],
      产出类型: 定义.产出类型 ?? [],
      副作用: 定义.副作用 ?? [],

      // 条件配置
      前置条件: 定义.前置条件 ?? (() => true),
      冷却周期: 定义.冷却周期 ?? 0,
      每周限制: 定义.每周限制 ?? Infinity,

      // 分类与描述
      分类: 定义.分类 ?? '通用',
      描述: 定义.描述 ?? '',
      图标: 定义.图标 ?? null,

      // 目标配置
      需要目标: 定义.需要目标 ?? false,
      目标类型: 定义.目标类型 ?? null,
      目标条件: 定义.目标条件 ?? null,

      // 资源配置
      消耗资源: 定义.消耗资源 ?? null,
      产出资源: 定义.产出资源 ?? null,

      // 动态计算
      动态行动点计算: 定义.动态行动点计算 ?? null,

      ...定义,
    };

    this.任务类型映射.set(任务名, 完整定义);

    // 更新分类索引
    const 分类 = 完整定义.分类;
    if (!this.分类索引.has(分类)) {
      this.分类索引.set(分类, new Set());
    }
    this.分类索引.get(分类).add(任务名);

    // 初始化统计
    this.执行统计.set(任务名, {
      总执行次数: 0,
      成功次数: 0,
      失败次数: 0,
    });
  }

  注册任务执行器(任务名, 执行函数) {
    this.任务执行器映射.set(任务名, 执行函数);
  }

  注册任务验证器(任务名, 验证函数) {
    if (!this.任务验证器映射.has(任务名)) {
      this.任务验证器映射.set(任务名, []);
    }
    this.任务验证器映射.get(任务名).push(验证函数);
  }

  // ─── 任务查询 ───

  获取任务定义(任务名) {
    return this.任务类型映射.get(任务名);
  }

  获取分类任务列表(分类) {
    const 任务名集合 = this.分类索引.get(分类);
    if (!任务名集合) return [];

    return Array.from(任务名集合).map(名称 => ({
      名称,
      ...this.任务类型映射.get(名称),
    }));
  }

  获取所有分类() {
    return Array.from(this.分类索引.keys());
  }

  获取所有任务列表() {
    return Array.from(this.任务类型映射.entries()).map(([名称, 定义]) => ({
      名称,
      ...定义,
    }));
  }

  是否已注册(任务名) {
    return this.任务类型映射.has(任务名);
  }

  // ─── 上下文构建 ───

  构建执行上下文(基础上下文) {
    const 扩展上下文 = { ...基础上下文 };

    // 注入所有系统依赖
    this.系统依赖.forEach((系统, 名称) => {
      扩展上下文[名称] = 系统;
    });

    return 扩展上下文;
  }

  // ─── 任务验证 ───

  验证任务可执行性(任务名, 上下文) {
    const 定义 = this.任务类型映射.get(任务名);
    if (!定义) {
      return { 可执行: false, 原因: '未知任务类型' };
    }

    const { 负责人, 时间系统 } = 上下文;

    // 检查负责人类型
    if (负责人 && !定义.负责人类型.includes(负责人.实体类型)) {
      return { 可执行: false, 原因: '负责人类型不匹配' };
    }

    // 检查负责人条件
    if (负责人 && !定义.负责人条件(上下文)) {
      return { 可执行: false, 原因: '负责人条件不满足' };
    }

    // 检查前置条件
    if (!定义.前置条件(上下文)) {
      return { 可执行: false, 原因: '前置条件不满足' };
    }

    // 检查行动点
    const 实际消耗 = this.计算实际行动点(任务名, 上下文);
    if (时间系统 && 时间系统.剩余行动点 < 实际消耗) {
      return { 可执行: false, 原因: '行动点不足' };
    }

    // 检查资源消耗
    if (定义.消耗资源) {
      const 资源系统 = this.获取系统('资源系统');
      if (资源系统) {
        for (const [资源名, 数量] of Object.entries(定义.消耗资源)) {
          if (资源系统.获取资源(资源名) < 数量) {
            return { 可执行: false, 原因: `${资源名}不足` };
          }
        }
      }
    }

    // 检查目标
    if (定义.需要目标 && !上下文.额外参数?.目标ID) {
      return { 可执行: false, 原因: '需要指定目标' };
    }

    // 执行自定义验证器
    const 验证器列表 = this.任务验证器映射.get(任务名) ?? [];
    for (const 验证器 of 验证器列表) {
      const 结果 = 验证器(上下文);
      if (!结果.通过) {
        return { 可执行: false, 原因: 结果.原因 };
      }
    }

    return { 可执行: true };
  }

  计算实际行动点(任务名, 上下文) {
    const 定义 = this.任务类型映射.get(任务名);
    if (!定义) return 1;

    if (定义.动态行动点计算) {
      return 定义.动态行动点计算(上下文);
    }

    return 定义.行动点消耗;
  }

  // ─── 负责人筛选 ───

  获取负责人可执行任务(负责人, 游戏状态) {
    const 可执行任务 = [];

    this.任务类型映射.forEach((定义, 任务名) => {
      if (!定义.负责人类型.includes(负责人.实体类型)) return;

      const 上下文 = this.构建执行上下文({
        任务名,
        负责人,
        游戏状态,
      });

      const 验证结果 = this.验证任务可执行性(任务名, 上下文);
      if (验证结果.可执行) {
        可执行任务.push({
          名称: 任务名,
          行动点消耗: this.计算实际行动点(任务名, 上下文),
          ...定义,
        });
      }
    });

    return 可执行任务;
  }

  // ─── 统计 ───

  记录执行结果(任务名, 成功) {
    const 统计 = this.执行统计.get(任务名);
    if (统计) {
      统计.总执行次数++;
      if (成功) {
        统计.成功次数++;
      } else {
        统计.失败次数++;
      }
    }
  }

  获取任务统计(任务名) {
    return this.执行统计.get(任务名);
  }

  获取所有统计() {
    return Object.fromEntries(this.执行统计);
  }

  重置统计() {
    this.执行统计.forEach(统计 => {
      统计.总执行次数 = 0;
      统计.成功次数 = 0;
      统计.失败次数 = 0;
    });
  }
}

// ═══════════════════════════════════════════════════════════════
// 法术定义注册表
// ═══════════════════════════════════════════════════════════════

/**
 * 法术定义注册表
 * 管理所有法术的定义和效果处理器
 */
class 法术定义注册表 {
  constructor() {
    this.法术映射 = new Map();
    this.法术效果处理器 = new Map();
    this.法术分类索引 = new Map();
  }

  // ─── 法术注册 ───

  注册法术(法术名, 定义) {
    const 完整定义 = {
      魔力消耗: 定义.魔力消耗 ?? 1,
      目标类型: 定义.目标类型 ?? '无', // '母畜' | '冠军' | '军队' | '无'
      效果描述: 定义.效果描述 ?? '',
      效果参数: 定义.效果参数 ?? {},
      施放条件: 定义.施放条件 ?? (() => true),
      冷却周期: 定义.冷却周期 ?? 0,
      分类: 定义.分类 ?? '通用',
      图标: 定义.图标 ?? null,
      ...定义,
    };

    this.法术映射.set(法术名, 完整定义);

    // 更新分类索引
    const 分类 = 完整定义.分类;
    if (!this.法术分类索引.has(分类)) {
      this.法术分类索引.set(分类, new Set());
    }
    this.法术分类索引.get(分类).add(法术名);
  }

  注册效果处理器(法术名, 处理函数) {
    /**
     * 处理函数签名: (目标, 上下文) => 效果结果
     */
    this.法术效果处理器.set(法术名, 处理函数);
  }

  // ─── 法术查询 ───

  获取法术定义(法术名) {
    return this.法术映射.get(法术名);
  }

  获取分类法术列表(分类) {
    const 法术名集合 = this.法术分类索引.get(分类);
    if (!法术名集合) return [];

    return Array.from(法术名集合).map(名称 => ({
      名称,
      ...this.法术映射.get(名称),
    }));
  }

  获取所有法术列表() {
    return Array.from(this.法术映射.entries()).map(([名称, 定义]) => ({
      名称,
      ...定义,
    }));
  }

  是否已注册(法术名) {
    return this.法术映射.has(法术名);
  }

  // ─── 法术执行 ───

  执行法术效果(法术名, 目标, 上下文) {
    const 处理器 = this.法术效果处理器.get(法术名);
    if (!处理器) {
      return { 成功: false, 原因: '效果处理器未注册' };
    }

    try {
      return 处理器(目标, 上下文);
    } catch (错误) {
      console.error(`法术效果执行错误 [${法术名}]:`, 错误);
      return { 成功: false, 原因: '效果执行异常' };
    }
  }

  // ─── 法术验证 ───

  验证施放条件(法术名, 目标, 上下文) {
    const 定义 = this.法术映射.get(法术名);
    if (!定义) {
      return { 可施放: false, 原因: '未知法术' };
    }

    // 检查目标类型
    if (定义.目标类型 !== '无') {
      if (!目标) {
        return { 可施放: false, 原因: '需要指定目标' };
      }
      if (定义.目标类型 !== 目标.实体类型) {
        return { 可施放: false, 原因: '目标类型不匹配' };
      }
    }

    // 检查施放条件
    if (!定义.施放条件({ 目标, ...上下文 })) {
      return { 可施放: false, 原因: '施放条件不满足' };
    }

    return { 可施放: true };
  }
}

// ═══════════════════════════════════════════════════════════════
// 商品定义注册表
// ═══════════════════════════════════════════════════════════════

/**
 * 商品定义注册表
 * 管理黑市商品的定义和刷新规则
 */
class 商品定义注册表 {
  constructor() {
    this.商品分类 = new Map();
    this.商品映射 = new Map();
    this.刷新规则映射 = new Map();
  }

  // ─── 分类管理 ───

  注册商品分类(分类名, 配置) {
    this.商品分类.set(分类名, {
      刷新周期: 配置.刷新周期 ?? 1,
      随机刷新: 配置.随机刷新 ?? false,
      限购规则: 配置.限购规则 ?? null,
      描述: 配置.描述 ?? '',
      排序权重: 配置.排序权重 ?? 0,
      ...配置,
    });
  }

  获取分类配置(分类名) {
    return this.商品分类.get(分类名);
  }

  获取所有分类() {
    return Array.from(this.商品分类.entries())
      .sort((a, b) => (b[1].排序权重 ?? 0) - (a[1].排序权重 ?? 0))
      .map(([名称, 配置]) => ({ 名称, ...配置 }));
  }

  // ─── 商品注册 ───

  注册商品(商品名, 定义) {
    this.商品映射.set(商品名, {
      分类: 定义.分类 ?? '通用',
      价格: 定义.价格 ?? 1,
      效果: 定义.效果 ?? {},
      每周限购: 定义.每周限购 ?? Infinity,
      稀有度: 定义.稀有度 ?? 1,
      刷新权重: 定义.刷新权重 ?? 100,
      购买条件: 定义.购买条件 ?? (() => true),
      描述: 定义.描述 ?? '',
      图标: 定义.图标 ?? null,
      ...定义,
    });
  }

  注册刷新规则(分类名, 规则函数) {
    /**
     * 规则函数签名: (周次, 上下文) => 商品列表
     */
    this.刷新规则映射.set(分类名, 规则函数);
  }

  // ─── 商品查询 ───

  获取商品定义(商品名) {
    return this.商品映射.get(商品名);
  }

  获取分类商品列表(分类名) {
    return Array.from(this.商品映射.entries())
      .filter(([_, 定义]) => 定义.分类 === 分类名)
      .map(([名称, 定义]) => ({ 名称, ...定义 }));
  }

  获取所有商品列表() {
    return Array.from(this.商品映射.entries()).map(([名称, 定义]) => ({
      名称,
      ...定义,
    }));
  }

  // ─── 刷新逻辑 ───

  执行分类刷新(分类名, 周次, 上下文 = {}) {
    const 刷新规则 = this.刷新规则映射.get(分类名);
    if (刷新规则) {
      return 刷新规则(周次, 上下文);
    }

    // 默认：返回该分类的所有商品
    return this.获取分类商品列表(分类名);
  }

  // ─── 随机商品生成 ───

  按权重随机选择(商品列表, 数量) {
    if (商品列表.length === 0) return [];
    if (商品列表.length <= 数量) return [...商品列表];

    const 结果 = [];
    const 候选池 = [...商品列表];

    for (let i = 0; i < 数量 && 候选池.length > 0; i++) {
      const 总权重 = 候选池.reduce((sum, item) => sum + (item.刷新权重 ?? 100), 0);
      let 随机值 = Math.random() * 总权重;

      for (let j = 0; j < 候选池.length; j++) {
        随机值 -= 候选池[j].刷新权重 ?? 100;
        if (随机值 <= 0) {
          结果.push(候选池[j]);
          候选池.splice(j, 1);
          break;
        }
      }
    }

    return 结果;
  }
}

// ═══════════════════════════════════════════════════════════════
// 事件定义注册表
// ═══════════════════════════════════════════════════════════════

/**
 * 事件定义注册表
 * 管理游戏中所有可触发事件的定义
 */
class 事件定义注册表 {
  constructor() {
    this.事件类型映射 = new Map();
    this.事件处理器映射 = new Map();
    this.事件条件映射 = new Map();
    this.事件权重映射 = new Map();
    this.事件冷却映射 = new Map();
    this.事件分类索引 = new Map();
  }

  // ─── 事件注册 ───

  注册事件类型(事件名, 定义) {
    const 完整定义 = {
      分类: 定义.分类 ?? '通用',
      触发时机: 定义.触发时机 ?? 'manual',
      优先级: 定义.优先级 ?? 0,
      可重复: 定义.可重复 ?? true,
      冷却周期: 定义.冷却周期 ?? 0,
      前置事件: 定义.前置事件 ?? [],
      互斥事件: 定义.互斥事件 ?? [],
      参与者类型: 定义.参与者类型 ?? [],
      效果描述: 定义.效果描述 ?? '',
      ...定义,
    };

    this.事件类型映射.set(事件名, 完整定义);

    // 更新分类索引
    const 分类 = 完整定义.分类;
    if (!this.事件分类索引.has(分类)) {
      this.事件分类索引.set(分类, new Set());
    }
    this.事件分类索引.get(分类).add(事件名);
  }

  注册事件条件(事件名, 条件函数) {
    if (!this.事件条件映射.has(事件名)) {
      this.事件条件映射.set(事件名, []);
    }
    this.事件条件映射.get(事件名).push(条件函数);
  }

  注册事件处理器(事件名, 处理函数) {
    this.事件处理器映射.set(事件名, 处理函数);
  }

  注册事件权重(事件名, 权重计算函数) {
    this.事件权重映射.set(事件名, 权重计算函数);
  }

  // ─── 事件查询 ───

  获取事件定义(事件名) {
    return this.事件类型映射.get(事件名);
  }

  获取分类事件列表(分类) {
    const 事件名集合 = this.事件分类索引.get(分类);
    if (!事件名集合) return [];

    return Array.from(事件名集合).map(名称 => ({
      名称,
      ...this.事件类型映射.get(名称),
    }));
  }

  // ─── 事件检查 ───

  检查事件条件(事件名, 上下文) {
    const 条件列表 = this.事件条件映射.get(事件名) ?? [];

    for (const 条件 of 条件列表) {
      const 结果 = 条件(上下文);
      if (!结果.满足) {
        return { 可触发: false, 原因: 结果.原因 };
      }
    }

    // 检查冷却
    const 定义 = this.事件类型映射.get(事件名);
    if (定义?.冷却周期 > 0) {
      const 上次触发 = this.事件冷却映射.get(事件名);
      if (上次触发 && 上下文.当前周次 - 上次触发 < 定义.冷却周期) {
        return { 可触发: false, 原因: '事件冷却中' };
      }
    }

    // 检查互斥事件
    if (定义?.互斥事件?.length > 0) {
      for (const 互斥事件名 of 定义.互斥事件) {
        if (上下文.本周已触发事件?.includes(互斥事件名)) {
          return { 可触发: false, 原因: `与事件[${互斥事件名}]互斥` };
        }
      }
    }

    return { 可触发: true };
  }

  // ─── 事件执行 ───

  执行事件(事件名, 上下文) {
    const 处理器 = this.事件处理器映射.get(事件名);
    if (!处理器) {
      return { 成功: false, 原因: '事件处理器未注册' };
    }

    const 结果 = 处理器(上下文);

    // 记录冷却
    const 定义 = this.事件类型映射.get(事件名);
    if (定义?.冷却周期 > 0) {
      this.事件冷却映射.set(事件名, 上下文.当前周次);
    }

    return 结果;
  }

  // ─── 随机事件池 ───

  计算事件权重(事件名, 上下文) {
    const 权重函数 = this.事件权重映射.get(事件名);
    return 权重函数 ? 权重函数(上下文) : 100;
  }

  获取可触发随机事件池(上下文) {
    const 随机事件列表 = this.获取分类事件列表('随机');
    const 可触发事件 = [];

    for (const 事件 of 随机事件列表) {
      const 检查结果 = this.检查事件条件(事件.名称, 上下文);
      if (检查结果.可触发) {
        const 权重 = this.计算事件权重(事件.名称, 上下文);
        可触发事件.push({ ...事件, 权重 });
      }
    }

    return 可触发事件;
  }

  // ─── 冷却管理 ───

  重置所有冷却() {
    this.事件冷却映射.clear();
  }

  重置事件冷却(事件名) {
    this.事件冷却映射.delete(事件名);
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 事件定义注册表, 任务定义注册表, 商品定义注册表, 属性定义注册表, 法术定义注册表 };
```


src\game\controller.js
```js
// ═══════════════════════════════════════════════════════════════
// game/controller.js
// 游戏控制器 - 统一管理所有系统，提供高层API
// ═══════════════════════════════════════════════════════════════

import { 游戏状态 } from './state.js';
import { 事件总线 } from '../systems/event-bus.js';
import { 公式引擎 } from '../systems/formula.js';
import { 时间系统 } from '../systems/time.js';
import { 资源系统 } from '../systems/resource.js';
import { 任务系统 } from '../systems/task.js';
import { 情报系统 } from '../systems/intel.js';
import { 战斗系统 } from '../systems/combat.js';
import { 繁殖系统 } from '../systems/breeding.js';
import { 法术系统 } from '../systems/spell.js';
import { 黑市系统 } from '../systems/market.js';

import { 属性定义注册表, 任务定义注册表, 法术定义注册表, 商品定义注册表 } from '../core/registries.js';
import { 工厂管理器 } from '../core/factories.js';

import { 初始化属性配置 } from '../config/attributes.js';
import { 初始化任务配置 } from '../config/tasks.js';
import { 初始化法术配置 } from '../config/spells.js';
import { 初始化商品配置 } from '../config/items.js';
import { 初始化公式配置 } from '../config/formulas.js';

/**
 * 游戏控制器
 * 作为游戏的中央协调器，负责初始化、管理所有系统并提供统一API
 */
class 游戏控制器 {
  constructor(配置 = {}) {
    // ─── 控制器状态 ───
    this.已初始化 = false;
    this.配置 = {
      游戏版本: '1.0.0',
      调试模式: false,
      自动保存: true,
      自动保存间隔: 5, // 每5周自动保存
      ...配置,
    };

    // ─── 核心组件占位 ───
    this.事件总线 = null;
    this.游戏状态 = null;

    // ─── 注册表 ───
    this.属性注册表 = null;
    this.任务注册表 = null;
    this.法术注册表 = null;
    this.商品注册表 = null;

    // ─── 工厂 ───
    this.工厂管理器 = null;

    // ─── 引擎与系统 ───
    this.公式引擎 = null;
    this.时间系统 = null;
    this.资源系统 = null;
    this.任务系统 = null;
    this.情报系统 = null;
    this.战斗系统 = null;
    this.繁殖系统 = null;
    this.法术系统 = null;
    this.黑市系统 = null;

    // ─── 插件系统 ───
    this.插件列表 = [];
    this.插件钩子 = new Map();

    // ─── 存档管理 ───
    this.存档适配器 = 配置.存档适配器 ?? null;
    this.当前存档名 = null;

    // ─── 游戏循环状态 ───
    this.游戏运行中 = false;
  }

  // ═══════════════════════════════════════════════════════════════
  // 初始化
  // ═══════════════════════════════════════════════════════════════

  初始化() {
    /**
     * 初始化游戏控制器及所有子系统
     * 必须在开始游戏前调用
     */
    if (this.已初始化) {
      console.warn('游戏控制器已初始化，跳过重复初始化');
      return this;
    }

    // 1. 创建事件总线
    this.事件总线 = new 事件总线({
      调试模式: this.配置.调试模式,
      启用历史记录: true,
    });

    // 2. 创建注册表
    this.属性注册表 = new 属性定义注册表();
    this.任务注册表 = new 任务定义注册表();
    this.法术注册表 = new 法术定义注册表();
    this.商品注册表 = new 商品定义注册表();

    // 3. 创建公式引擎
    this.公式引擎 = new 公式引擎();

    // 4. 加载默认配置
    this.加载默认配置();

    // 5. 创建工厂管理器
    this.工厂管理器 = new 工厂管理器(this.属性注册表);
    this.配置工厂();

    // 6. 创建各系统（暂时不传入游戏状态依赖）
    this.创建系统();

    // 7. 注入系统间依赖
    this.注入系统依赖();

    // 8. 注册周结算处理器
    this.注册周结算处理器();

    // 9. 初始化插件
    this.初始化插件();

    this.已初始化 = true;

    this.事件总线.发布('控制器初始化完成', { 版本: this.配置.游戏版本 });

    return this;
  }

  加载默认配置() {
    // 加载属性配置
    初始化属性配置(this.属性注册表);

    // 加载公式配置
    初始化公式配置(this.公式引擎);

    // 加载任务配置
    初始化任务配置(this.任务注册表);

    // 加载法术配置
    初始化法术配置(this.法术注册表);

    // 加载商品配置
    初始化商品配置(this.商品注册表);
  }

  配置工厂() {
    const 冠军工厂 = this.工厂管理器.获取冠军工厂();
    const 母畜工厂 = this.工厂管理器.获取母畜工厂();
    const 袭击目标工厂 = this.工厂管理器.获取袭击目标工厂();

    // 初始化女性随机配置
    const { 女性随机配置, 初始化女性随机配置 } = require('../config/female-generation.js');
    const 女性配置实例 = new 女性随机配置();
    初始化女性随机配置(女性配置实例);
    this.工厂管理器.设置女性随机配置(女性配置实例);

    // 初始化袭击目标类型配置
    const { 袭击目标类型配置 } = require('../config/raid-targets.js');
    if (袭击目标类型配置) {
      袭击目标工厂.批量注册目标类型(袭击目标类型配置);
    }

    // 从配置导入效率系数（原有逻辑）
    try {
      const { 冠军效率系数配置, 身份价值配置, 种族价值修正配置 } = require('../config/attributes.js');

      if (冠军效率系数配置) {
        冠军工厂.批量注册效率系数(冠军效率系数配置);
      }
      if (身份价值配置) {
        母畜工厂.批量注册身份价值(身份价值配置);
      }
      if (种族价值修正配置) {
        Object.entries(种族价值修正配置).forEach(([种族, 修正]) => {
          母畜工厂.注册种族价值修正(种族, 修正);
        });
      }
    } catch (e) {
      // 配置可能未导出，使用默认值
    }
  }

  创建系统() {
    // 时间系统
    this.时间系统 = new 时间系统(this.事件总线, {
      周行动点上限: 3,
    });

    // 资源系统
    this.资源系统 = new 资源系统(this.事件总线);
    this.资源系统.注册资源类型('母乳', {
      初始值: 0,
      最小值: 0,
      描述: '母畜产出的母乳，用于黑市交易',
    });

    // 情报系统
    this.情报系统 = new 情报系统(this.事件总线, this.公式引擎);

    // 战斗系统
    this.战斗系统 = new 战斗系统(this.事件总线, this.公式引擎, this.情报系统);

    // 任务系统（需要任务注册表）
    this.任务系统 = new 任务系统(this.事件总线, this.任务注册表, this.时间系统, this.公式引擎);

    // 繁殖系统（需要冠军工厂和喽啰池，稍后绑定）
    this.繁殖系统 = new 繁殖系统(this.事件总线, this.工厂管理器.获取冠军工厂(), null, this.属性注册表);

    // 法术系统
    this.法术系统 = new 法术系统(this.事件总线, this.法术注册表, null);

    // 黑市系统
    this.黑市系统 = new 黑市系统(this.事件总线, this.商品注册表, this.资源系统);
  }

  注入系统依赖() {
    // 任务注册表注入系统依赖
    this.任务注册表.注入系统依赖({
      事件总线: this.事件总线,
      公式引擎: this.公式引擎,
      属性注册表: this.属性注册表,
      情报系统: this.情报系统,
      繁殖系统: this.繁殖系统,
      资源系统: this.资源系统,
      母畜工厂: this.工厂管理器.获取母畜工厂(),
    });
  }

  注册周结算处理器() {
    // 资源产出（泌乳）
    this.时间系统.注册周结算处理器(游戏状态 => {
      if (!游戏状态) return null;

      // 泌乳产出
      let 总泌乳量 = 0;
      const 泌乳母畜 = 游戏状态.获取泌乳状态母畜();

      泌乳母畜.forEach(母畜 => {
        const 产量 = this.公式引擎.计算('泌乳产量', {
          淫乱度: 母畜.获取属性('淫乱度'),
        });
        总泌乳量 += 产量;

        // 泌乳增加淫乱度
        母畜.修改属性('淫乱度', 3, this.属性注册表);
      });

      if (总泌乳量 > 0) {
        this.资源系统.增加资源('母乳', 总泌乳量, '周结算泌乳');
      }

      return {
        类型: '泌乳产出',
        泌乳母畜数: 泌乳母畜.length,
        总产量: 总泌乳量,
      };
    }, 100);

    // 士气衰减
    this.时间系统.注册周结算处理器(游戏状态 => {
      if (!游戏状态) return null;

      const 旧士气 = 游戏状态.获取士气();
      游戏状态.修改士气(-5);

      return {
        类型: '士气衰减',
        旧士气,
        新士气: 游戏状态.获取士气(),
        衰减量: 5,
      };
    }, 50);

    // 情报衰减
    this.时间系统.注册周结算处理器(游戏状态 => {
      const 衰减记录 = this.情报系统.周结算处理(this.时间系统.当前周次);
      return {
        类型: '情报衰减',
        衰减目标数: 衰减记录.length,
        详情: 衰减记录,
      };
    }, 40);

    // 任务系统周重置
    this.时间系统.注册周结算处理器(() => {
      return this.任务系统.周结算处理();
    }, 30);

    // 自动保存
    this.时间系统.注册周结算处理器(游戏状态 => {
      if (!this.配置.自动保存) return null;

      if (this.时间系统.当前周次 % this.配置.自动保存间隔 === 0) {
        this.自动保存();
        return { 类型: '自动保存' };
      }
      return null;
    }, 10);

    // 新周处理：刷新黑市
    this.时间系统.注册新周处理器(游戏状态 => {
      const 刷新结果 = this.黑市系统.刷新商品(this.时间系统.当前周次, { 游戏状态 });

      this.法术系统.设置当前周次(this.时间系统.当前周次);
      this.情报系统.设置当前周次(this.时间系统.当前周次);
    }, 100);
  }

  初始化插件() {
    this.插件列表.forEach(插件 => {
      try {
        if (typeof 插件.初始化 === 'function') {
          插件.初始化(this);
        }
      } catch (错误) {
        console.error(`插件初始化失败 [${插件.名称 ?? '未知'}]:`, 错误);
      }
    });
  }

  // ═══════════════════════════════════════════════════════════════
  // 游戏生命周期
  // ═══════════════════════════════════════════════════════════════

  创建新游戏(配置 = {}) {
    /**
     * 创建新游戏
     */
    if (!this.已初始化) {
      this.初始化();
    }

    // 创建游戏状态
    this.游戏状态 = 游戏状态.创建新游戏({
      游戏版本: this.配置.游戏版本,
      存档名称: 配置.存档名称 ?? '新游戏',
      领主姓名: 配置.领主姓名,
      初始魔力: 配置.初始魔力 ?? 0,
      初始喽啰数量: 配置.初始喽啰数量 ?? 50,
      ...配置,
    });

    // 绑定游戏状态到各系统
    this.绑定游戏状态();

    // 发布新游戏事件
    this.事件总线.发布('新游戏开始', {
      存档名称: this.游戏状态.元数据.存档名称,
    });

    // 刷新首周黑市
    this.黑市系统.刷新商品(1, { 游戏状态: this.游戏状态 });

    this.游戏运行中 = true;

    // 执行插件钩子
    this.执行插件钩子('新游戏开始', { 游戏状态: this.游戏状态 });

    return this.游戏状态;
  }

  绑定游戏状态() {
    // 繁殖系统绑定喽啰池
    this.繁殖系统.设置喽啰池(this.游戏状态.获取喽啰池());

    // 法术系统绑定领主
    this.法术系统.设置领主(this.游戏状态.获取领主());

    // 任务注册表更新游戏状态引用
    this.任务注册表.注入系统依赖({
      游戏状态: this.游戏状态,
    });
  }

  加载游戏(存档数据) {
    /**
     * 从存档数据加载游戏
     */
    if (!this.已初始化) {
      this.初始化();
    }

    try {
      // 恢复游戏状态
      this.游戏状态 = 游戏状态.从存档加载(存档数据, {
        游戏版本: this.配置.游戏版本,
      });

      // 恢复各系统状态
      if (存档数据.系统状态) {
        this.恢复系统状态(存档数据.系统状态);
      }

      // 绑定游戏状态
      this.绑定游戏状态();

      this.事件总线.发布('游戏加载完成', {
        存档名称: this.游戏状态.元数据.存档名称,
        周次: this.时间系统.当前周次,
      });

      this.游戏运行中 = true;

      // 执行插件钩子
      this.执行插件钩子('游戏加载', { 游戏状态: this.游戏状态 });

      return { 成功: true, 游戏状态: this.游戏状态 };
    } catch (错误) {
      console.error('加载游戏失败:', 错误);
      return { 成功: false, 原因: 错误.message };
    }
  }

  恢复系统状态(系统状态) {
    if (系统状态.时间系统) {
      this.时间系统.从序列化恢复(系统状态.时间系统);
    }
    if (系统状态.资源系统) {
      this.资源系统.从序列化恢复(系统状态.资源系统);
    }
    if (系统状态.情报系统) {
      this.情报系统.从序列化恢复(系统状态.情报系统);
    }
    if (系统状态.任务系统) {
      this.任务系统.从序列化恢复(系统状态.任务系统);
    }
    if (系统状态.法术系统) {
      this.法术系统.从序列化恢复(系统状态.法术系统);
    }
    if (系统状态.黑市系统) {
      this.黑市系统.从序列化恢复(系统状态.黑市系统);
    }
    if (系统状态.战斗系统) {
      this.战斗系统.从序列化恢复(系统状态.战斗系统);
    }
    if (系统状态.繁殖系统) {
      this.繁殖系统.从序列化恢复(系统状态.繁殖系统);
    }
  }

  保存游戏() {
    /**
     * 保存当前游戏状态
     */
    if (!this.游戏状态) {
      return { 成功: false, 原因: '无游戏状态可保存' };
    }

    const 存档数据 = {
      版本: this.配置.游戏版本,
      保存时间: Date.now(),
      游戏状态: this.游戏状态.序列化(),
      系统状态: {
        时间系统: this.时间系统.序列化(),
        资源系统: this.资源系统.序列化(),
        情报系统: this.情报系统.序列化(),
        任务系统: this.任务系统.序列化(),
        法术系统: this.法术系统.序列化(),
        黑市系统: this.黑市系统.序列化(),
        战斗系统: this.战斗系统.序列化(),
        繁殖系统: this.繁殖系统.序列化(),
      },
    };

    // 执行插件钩子
    this.执行插件钩子('保存前', { 存档数据 });

    // 如果有存档适配器，使用它保存
    if (this.存档适配器) {
      try {
        this.存档适配器.保存(this.当前存档名 ?? 'autosave', 存档数据);
      } catch (错误) {
        console.error('存档适配器保存失败:', 错误);
      }
    }

    this.事件总线.发布('游戏保存', {
      存档名称: this.游戏状态.元数据.存档名称,
    });

    return { 成功: true, 存档数据 };
  }

  自动保存() {
    const 结果 = this.保存游戏();
    if (结果.成功) {
      this.事件总线.发布('自动保存完成', {
        周次: this.时间系统.当前周次,
      });
    }
    return 结果;
  }

  // ═══════════════════════════════════════════════════════════════
  // 游戏流程控制
  // ═══════════════════════════════════════════════════════════════

  结束当前周() {
    /**
     * 结束当前周，触发周结算
     */
    if (!this.游戏运行中) {
      return { 成功: false, 原因: '游戏未运行' };
    }

    // 执行插件钩子
    this.执行插件钩子('周结算前', {
      周次: this.时间系统.当前周次,
    });

    const 结果 = this.时间系统.结束当前周(this.游戏状态);

    // 执行插件钩子
    this.执行插件钩子('周结算后', {
      周次: this.时间系统.当前周次,
      结果,
    });

    return 结果;
  }

  暂停游戏() {
    this.时间系统.暂停();
    this.游戏运行中 = false;
  }

  恢复游戏() {
    this.时间系统.恢复();
    this.游戏运行中 = true;
  }

  // ═══════════════════════════════════════════════════════════════
  // 高层API - 任务
  // ═══════════════════════════════════════════════════════════════

  执行任务(任务名, 负责人ID, 额外参数 = {}) {
    /**
     * 执行任务的统一入口
     */
    if (!this.游戏运行中) {
      return { 成功: false, 原因: '游戏未运行' };
    }

    // 获取负责人实体
    let 负责人 = this.游戏状态.获取冠军(负责人ID);
    if (!负责人) {
      负责人 = this.游戏状态.获取母畜(负责人ID);
    }

    if (!负责人) {
      return { 成功: false, 原因: '负责人不存在' };
    }

    return this.任务系统.执行任务(任务名, 负责人, this.游戏状态, 额外参数);
  }

  获取可执行任务(负责人ID) {
    /**
     * 获取指定负责人可执行的任务列表
     */
    let 负责人 = this.游戏状态.获取冠军(负责人ID);
    if (!负责人) {
      负责人 = this.游戏状态.获取母畜(负责人ID);
    }

    if (!负责人) return [];

    return this.任务系统.获取可执行任务列表(负责人, this.游戏状态);
  }

  // ═══════════════════════════════════════════════════════════════
  // 高层API - 战斗
  // ═══════════════════════════════════════════════════════════════

  发起战斗(出击配置, 目标ID) {
    /**
     * 发起战斗
     * @param 出击配置 - { 部曲列表: [{ 冠军ID, 喽啰配置 }] }
     */
    if (!this.游戏运行中) {
      return { 成功: false, 原因: '游戏未运行' };
    }

    // 消耗行动点
    const 消耗结果 = this.时间系统.消耗行动点(1);
    if (!消耗结果.成功) {
      return { 成功: false, 原因: 消耗结果.原因 };
    }

    // 构建完整出击配置
    const 完整配置 = {
      部曲列表: 出击配置.部曲列表.map(部曲 => ({
        冠军: this.游戏状态.获取冠军(部曲.冠军ID),
        喽啰配置: 部曲.喽啰配置,
      })),
      士气: this.游戏状态.获取士气(),
    };

    // 获取目标情报
    const 目标情报 = this.情报系统.获取目标情报(目标ID);
    if (!目标情报) {
      return { 成功: false, 原因: '目标不存在' };
    }

    // 执行战斗
    const 战斗结果 = this.战斗系统.执行战斗(完整配置, 目标情报.实际战力, { 目标ID });

    // 应用战斗结果
    this.应用战斗结果(战斗结果);

    return { 成功: true, 战斗结果 };
  }

  应用战斗结果(战斗结果) {
    // 处理喽啰损失
    if (战斗结果.喽啰损失?.明细) {
      战斗结果.喽啰损失.明细.forEach(损失 => {
        this.游戏状态.减少喽啰(损失.损失数量, 损失.武装等级);
      });
    }

    // 处理冠军损失
    if (战斗结果.冠军损失?.损失情况) {
      战斗结果.冠军损失.损失情况.forEach(损失 => {
        const 冠军 = this.游戏状态.获取冠军(损失.冠军ID);
        if (冠军) {
          if (损失.状态 === '阵亡') {
            this.游戏状态.移除冠军(损失.冠军ID);
          } else if (损失.状态 === '负伤') {
            冠军.添加标签('负伤');
          }
        }
      });
    }

    // 士气变化
    if (战斗结果.士气变化) {
      this.游戏状态.修改士气(战斗结果.士气变化);
    }

    // 处理战利品（俘获目标）
    if (战斗结果.战利品?.俘获目标) {
      战斗结果.战利品.俘获目标.forEach(目标信息 => {
        const 新母畜 = this.工厂管理器.获取母畜工厂().从战斗俘获创建({
          目标信息,
          俘获来源: `战斗俘获`,
        });
        this.游戏状态.添加母畜(新母畜);
      });
    }

    // 更新统计
    this.游戏状态.更新统计('总战斗次数');
    if (战斗结果.是否胜利) {
      this.游戏状态.更新统计('总胜利次数');
    }
  }

  预估战斗结果(出击配置, 目标ID) {
    /**
     * 预估战斗结果（不消耗行动点）
     */
    const 目标情报 = this.情报系统.获取目标情报(目标ID);
    if (!目标情报) return null;

    const 战力估值 = this.情报系统.获取战力估值(目标ID);
    if (!战力估值) return null;

    const 完整配置 = {
      部曲列表: 出击配置.部曲列表.map(部曲 => ({
        冠军: this.游戏状态.获取冠军(部曲.冠军ID),
        喽啰配置: 部曲.喽啰配置,
      })),
      士气: this.游戏状态.获取士气(),
    };

    return this.战斗系统.预估战斗结果(完整配置, {
      最小: 战力估值.估计最小,
      最大: 战力估值.估计最大,
    });
  }

  // ═══════════════════════════════════════════════════════════════
  // 高层API - 繁殖
  // ═══════════════════════════════════════════════════════════════

  生育冠军(母畜ID) {
    /**
     * 母畜生育冠军
     */
    const 母畜 = this.游戏状态.获取母畜(母畜ID);
    if (!母畜) {
      return { 成功: false, 原因: '母畜不存在' };
    }

    // 检查行动点需求
    const 臣服度 = 母畜.获取属性('臣服度');
    const 行动点需求 = 臣服度 >= 25 ? 1 : 2;

    const 消耗结果 = this.时间系统.消耗行动点(行动点需求);
    if (!消耗结果.成功) {
      return { 成功: false, 原因: 消耗结果.原因 };
    }

    const 结果 = this.繁殖系统.生育冠军(母畜);

    if (结果.成功) {
      this.游戏状态.添加冠军(结果.冠军);
    }

    return 结果;
  }

  生育喽啰(母畜ID) {
    /**
     * 母畜生育喽啰
     */
    const 母畜 = this.游戏状态.获取母畜(母畜ID);
    if (!母畜) {
      return { 成功: false, 原因: '母畜不存在' };
    }

    // 检查行动点需求
    const 臣服度 = 母畜.获取属性('臣服度');
    if (臣服度 < 25) {
      const 消耗结果 = this.时间系统.消耗行动点(1);
      if (!消耗结果.成功) {
        return { 成功: false, 原因: 消耗结果.原因 };
      }
    }

    return this.繁殖系统.生育喽啰(母畜);
  }

  // ═══════════════════════════════════════════════════════════════
  // 高层API - 法术
  // ═══════════════════════════════════════════════════════════════

  施放法术(法术名, 目标ID = null) {
    /**
     * 施放法术
     */
    let 目标 = null;
    if (目标ID) {
      目标 = this.游戏状态.获取冠军(目标ID) ?? this.游戏状态.获取母畜(目标ID);
    }

    const 结果 = this.法术系统.施放法术(法术名, 目标);

    // 处理特殊效果
    if (结果.成功 && 结果.效果结果) {
      this.应用法术效果(法术名, 结果.效果结果);
    }

    return 结果;
  }

  应用法术效果(法术名, 效果结果) {
    // 根据效果类型处理
    if (效果结果.需要应用到 === '时间系统') {
      if (效果结果.效果类型 === '行动点增加') {
        this.时间系统.恢复行动点(效果结果.增量);
      }
    }

    if (效果结果.需要应用到 === '情报系统') {
      // 情报相关效果
    }

    if (效果结果.需要应用到 === '军队状态') {
      if (效果结果.效果类型 === '士气增加') {
        this.游戏状态.修改士气(效果结果.增量);
      }
    }

    if (效果结果.需移除母畜) {
      this.游戏状态.移除母畜(效果结果.目标ID);
      this.游戏状态.更新统计('总献祭母畜数');
    }

    // 魔力获得
    if (效果结果.魔力获得) {
      this.游戏状态.获取领主().获得魔力(效果结果.魔力获得);
      this.游戏状态.更新统计('总获得魔力', 效果结果.魔力获得);
    }
  }

  献祭母畜(母畜ID) {
    /**
     * 献祭母畜获得魔力
     */
    const 母畜 = this.游戏状态.获取母畜(母畜ID);
    if (!母畜) {
      return { 成功: false, 原因: '母畜不存在' };
    }

    const 结果 = this.法术系统.献祭母畜(母畜);

    if (结果.成功 && 结果.需移除母畜) {
      this.游戏状态.移除母畜(母畜ID);
      this.游戏状态.更新统计('总献祭母畜数');
      this.游戏状态.更新统计('总获得魔力', 结果.魔力获得);
    }

    return 结果;
  }

  // ═══════════════════════════════════════════════════════════════
  // 高层API - 黑市
  // ═══════════════════════════════════════════════════════════════

  获取黑市商品() {
    return this.黑市系统.获取可用商品列表();
  }

  购买商品(商品名, 数量 = 1) {
    const 结果 = this.黑市系统.购买商品(商品名, 数量);

    if (结果.成功) {
      // 应用商品效果
      this.应用商品效果(结果.效果);
    }

    return 结果;
  }

  应用商品效果(效果) {
    if (!效果) return;

    switch (效果.类型) {
      case '获得母畜':
        const 新母畜 = this.工厂管理器.获取母畜工厂().从黑市购买创建(效果);
        this.游戏状态.添加母畜(新母畜);
        break;

      case '武装升级':
        // 武装升级需要UI交互选择喽啰
        break;

      case '属性增加':
      case '属性设置':
        // 需要目标选择
        break;

      case '士气增加':
        this.游戏状态.修改士气(效果.增加量);
        break;

      case '魔力水晶':
        this.游戏状态.获取领主()?.获得魔力(效果.魔力恢复);
        break;

      // 其他效果类型...
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // 高层API - 侦察与情报
  // ═══════════════════════════════════════════════════════════════

  创建侦察目标(目标配置) {
    /**
     * 创建新的侦察目标
     */
    return this.情报系统.创建目标(目标配置.目标ID ?? this.生成目标ID(), 目标配置);
  }

  生成目标ID() {
    return `target_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
  }

  获取目标情报(目标ID) {
    return this.情报系统.获取目标情报(目标ID);
  }

  获取所有侦察目标() {
    return this.情报系统.获取所有目标();
  }

  // ═══════════════════════════════════════════════════════════════
  // 插件系统
  // ═══════════════════════════════════════════════════════════════

  注册插件(插件) {
    /**
     * 注册插件
     * 插件结构: { 名称, 版本, 初始化(控制器), 钩子: { 钩子名: 处理函数 } }
     */
    this.插件列表.push(插件);

    // 注册钩子
    if (插件.钩子) {
      Object.entries(插件.钩子).forEach(([钩子名, 处理函数]) => {
        if (!this.插件钩子.has(钩子名)) {
          this.插件钩子.set(钩子名, []);
        }
        this.插件钩子.get(钩子名).push({
          插件名: 插件.名称,
          处理函数,
        });
      });
    }

    // 如果已初始化，立即初始化插件
    if (this.已初始化 && typeof 插件.初始化 === 'function') {
      插件.初始化(this);
    }
  }

  执行插件钩子(钩子名, 数据) {
    const 钩子列表 = this.插件钩子.get(钩子名);
    if (!钩子列表) return;

    钩子列表.forEach(({ 插件名, 处理函数 }) => {
      try {
        处理函数(数据, this);
      } catch (错误) {
        console.error(`插件钩子执行失败 [${插件名}:${钩子名}]:`, 错误);
      }
    });
  }

  // ═══════════════════════════════════════════════════════════════
  // 调试与工具
  // ═══════════════════════════════════════════════════════════════

  获取游戏概览() {
    if (!this.游戏状态) return null;

    return {
      ...this.游戏状态.获取游戏概览(),
      时间: this.时间系统.获取时间状态(),
      资源: this.资源系统.获取所有资源(),
      黑市: this.黑市系统.获取黑市状态(),
    };
  }

  获取详细状态() {
    if (!this.游戏状态) return null;

    return {
      游戏状态: this.游戏状态.获取详细状态(),
      时间系统: this.时间系统.获取时间状态(),
      资源系统: this.资源系统.获取所有资源(),
      情报系统: this.情报系统.获取所有目标(),
      任务统计: this.任务注册表.获取所有统计(),
    };
  }

  设置调试模式(启用) {
    this.配置.调试模式 = 启用;
    this.事件总线.设置调试模式(启用);
  }

  // ─── 快捷访问器 ───

  get 周次() {
    return this.时间系统?.当前周次 ?? 0;
  }

  get 行动点() {
    return this.时间系统?.剩余行动点 ?? 0;
  }

  get 领主() {
    return this.游戏状态?.获取领主();
  }

  get 冠军列表() {
    return this.游戏状态?.获取所有冠军() ?? [];
  }

  get 母畜列表() {
    return this.游戏状态?.获取所有母畜() ?? [];
  }

  get 喽啰总数() {
    return this.游戏状态?.获取喽啰总数() ?? 0;
  }

  get 士气() {
    return this.游戏状态?.获取士气() ?? 0;
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 游戏控制器 };
export default 游戏控制器;
```


src\game\state.js
```js
// ═══════════════════════════════════════════════════════════════
// game/state.js
// 游戏状态 - 管理所有游戏实体和全局状态
// ═══════════════════════════════════════════════════════════════

import { 领主实体, 冠军实体, 母畜实体, 喽啰池 } from '../core/entities.js';

/**
 * 游戏状态
 * 集中管理所有游戏实体和全局状态数据
 */
class 游戏状态 {
  constructor(配置 = {}) {
    // ─── 核心实体 ───
    this.领主 = null;
    this.冠军列表 = [];
    this.母畜列表 = [];
    this.喽啰池 = new 喽啰池();

    // ─── 军队状态 ───
    this.军队状态 = {
      士气: 配置.初始士气 ?? 50,
      战斗力基础值: 配置.初始战斗力 ?? 100,
      士气上限: 100,
      士气下限: 0,
    };

    // ─── 全局变量 ───
    this.全局变量 = new Map();

    // ─── 游戏标记 ───
    this.游戏标记 = new Set();

    // ─── 统计数据 ───
    this.统计数据 = {
      总生育冠军数: 0,
      总生育喽啰数: 0,
      总战斗次数: 0,
      总胜利次数: 0,
      总献祭母畜数: 0,
      总消耗母乳: 0,
      总获得魔力: 0,
    };

    // ─── 游戏进度 ───
    this.游戏进度 = {
      已完成事件: new Set(),
      已解锁功能: new Set(),
      已触发里程碑: new Set(),
    };

    // ─── 侦察目标列表 ───
    this.侦察目标列表 = [];

    // ─── 事件监听器 ───
    this.状态变更监听器 = [];

    // ─── 元数据 ───
    this.元数据 = {
      创建时间: Date.now(),
      最后保存时间: null,
      游戏版本: 配置.游戏版本 ?? '1.0.0',
      存档名称: 配置.存档名称 ?? '默认存档',
    };
  }

  // ═══════════════════════════════════════════════════════════════
  // 领主管理
  // ═══════════════════════════════════════════════════════════════

  设置领主(领主实体) {
    const 旧领主 = this.领主;
    this.领主 = 领主实体;
    this.触发状态变更('领主变更', { 旧领主, 新领主: 领主实体 });
  }

  获取领主() {
    return this.领主;
  }

  领主是否存在() {
    return this.领主 !== null;
  }

  // ═══════════════════════════════════════════════════════════════
  // 冠军管理
  // ═══════════════════════════════════════════════════════════════

  添加冠军(冠军实体) {
    if (!冠军实体) return false;

    // 检查是否已存在
    if (this.冠军列表.some(c => c.实体ID === 冠军实体.实体ID)) {
      console.warn(`冠军已存在: ${冠军实体.实体ID}`);
      return false;
    }

    this.冠军列表.push(冠军实体);
    this.统计数据.总生育冠军数++;

    this.触发状态变更('冠军添加', { 冠军: 冠军实体 });
    return true;
  }

  移除冠军(冠军ID) {
    const 索引 = this.冠军列表.findIndex(c => c.实体ID === 冠军ID);
    if (索引 === -1) return null;

    const 移除的冠军 = this.冠军列表.splice(索引, 1)[0];
    this.触发状态变更('冠军移除', { 冠军: 移除的冠军 });
    return 移除的冠军;
  }

  获取冠军(冠军ID) {
    return this.冠军列表.find(c => c.实体ID === 冠军ID) ?? null;
  }

  获取冠军通过姓名(姓名) {
    return this.冠军列表.find(c => c.获取属性('姓名') === 姓名) ?? null;
  }

  获取所有冠军() {
    return [...this.冠军列表];
  }

  获取可用冠军() {
    /**
     * 获取当前可执行任务的冠军（未负伤、未外出等）
     */
    return this.冠军列表.filter(c => c.是否可执行任务?.() ?? true);
  }

  获取可战斗冠军() {
    /**
     * 获取当前可参与战斗的冠军
     */
    return this.冠军列表.filter(c => c.是否可战斗?.() ?? true);
  }

  获取冠军数量() {
    return this.冠军列表.length;
  }

  // ─── 冠军查询 ───

  筛选冠军(条件函数) {
    /**
     * 根据条件筛选冠军
     * @param 条件函数 - (冠军) => boolean
     */
    return this.冠军列表.filter(条件函数);
  }

  按属性排序冠军(属性名, 降序 = true) {
    /**
     * 按指定属性排序冠军
     */
    return [...this.冠军列表].sort((a, b) => {
      const 值A = a.获取属性(属性名) ?? 0;
      const 值B = b.获取属性(属性名) ?? 0;
      return 降序 ? 值B - 值A : 值A - 值B;
    });
  }

  获取最强冠军(属性名 = '力量') {
    if (this.冠军列表.length === 0) return null;
    return this.按属性排序冠军(属性名, true)[0];
  }

  // ═══════════════════════════════════════════════════════════════
  // 母畜管理
  // ═══════════════════════════════════════════════════════════════

  添加母畜(母畜实体) {
    if (!母畜实体) return false;

    // 检查是否已存在
    if (this.母畜列表.some(m => m.实体ID === 母畜实体.实体ID)) {
      console.warn(`母畜已存在: ${母畜实体.实体ID}`);
      return false;
    }

    this.母畜列表.push(母畜实体);
    this.触发状态变更('母畜添加', { 母畜: 母畜实体 });
    return true;
  }

  移除母畜(母畜ID) {
    const 索引 = this.母畜列表.findIndex(m => m.实体ID === 母畜ID);
    if (索引 === -1) return null;

    const 移除的母畜 = this.母畜列表.splice(索引, 1)[0];
    this.触发状态变更('母畜移除', { 母畜: 移除的母畜 });
    return 移除的母畜;
  }

  获取母畜(母畜ID) {
    return this.母畜列表.find(m => m.实体ID === 母畜ID) ?? null;
  }

  获取母畜通过姓名(姓名) {
    return this.母畜列表.find(m => m.获取属性('姓名') === 姓名) ?? null;
  }

  获取所有母畜() {
    return [...this.母畜列表];
  }

  获取母畜数量() {
    return this.母畜列表.length;
  }

  // ─── 母畜分类查询 ───

  获取繁殖状态母畜() {
    /**
     * 获取处于繁殖状态且有剩余价值的母畜
     */
    return this.母畜列表.filter(m =>
      m.拥有标签('繁殖状态') &&
      m.获取属性('剩余雌性价值') > 0
    );
  }

  获取可生育冠军母畜() {
    /**
     * 获取可以生育冠军的母畜
     */
    return this.母畜列表.filter(m =>
      m.获取属性('剩余雌性价值') >= 100
    );
  }

  获取可生育喽啰母畜() {
    /**
     * 获取可以生育喽啰的母畜
     */
    return this.母畜列表.filter(m =>
      m.获取属性('剩余雌性价值') > 0 &&
      m.获取属性('臣服度') >= 25
    );
  }

  获取泌乳状态母畜() {
    /**
     * 获取可以泌乳的母畜（淫乱度>=25）
     */
    return this.母畜列表.filter(m =>
      m.获取属性('淫乱度') >= 25
    );
  }

  获取可献祭母畜() {
    /**
     * 获取可以献祭的母畜（淫乱度>=100）
     */
    return this.母畜列表.filter(m =>
      m.获取属性('淫乱度') >= 100
    );
  }

  获取忠诚母畜() {
    /**
     * 获取忠诚期母畜（臣服度>=90）
     */
    return this.母畜列表.filter(m =>
      m.获取属性('臣服度') >= 90
    );
  }

  获取归心母畜() {
    /**
     * 获取归心期及以上母畜（臣服度>=75）
     */
    return this.母畜列表.filter(m =>
      m.获取属性('臣服度') >= 75
    );
  }

  筛选母畜(条件函数) {
    /**
     * 根据条件筛选母畜
     * @param 条件函数 - (母畜) => boolean
     */
    return this.母畜列表.filter(条件函数);
  }

  按属性排序母畜(属性名, 降序 = true) {
    /**
     * 按指定属性排序母畜
     */
    return [...this.母畜列表].sort((a, b) => {
      const 值A = a.获取属性(属性名) ?? 0;
      const 值B = b.获取属性(属性名) ?? 0;
      return 降序 ? 值B - 值A : 值A - 值B;
    });
  }

  按种族分组母畜() {
    /**
     * 按种族对母畜进行分组
     */
    const 分组 = new Map();
    this.母畜列表.forEach(母畜 => {
      const 种族 = 母畜.获取属性('种族') ?? '未知';
      if (!分组.has(种族)) {
        分组.set(种族, []);
      }
      分组.get(种族).push(母畜);
    });
    return 分组;
  }

  按身份分组母畜() {
    /**
     * 按原身份对母畜进行分组
     */
    const 分组 = new Map();
    this.母畜列表.forEach(母畜 => {
      const 身份 = 母畜.获取属性('原身份') ?? '未知';
      if (!分组.has(身份)) {
        分组.set(身份, []);
      }
      分组.get(身份).push(母畜);
    });
    return 分组;
  }

  // ═══════════════════════════════════════════════════════════════
  // 喽啰池管理
  // ═══════════════════════════════════════════════════════════════

  获取喽啰池() {
    return this.喽啰池;
  }

  设置喽啰池(喽啰池实例) {
    this.喽啰池 = 喽啰池实例;
  }

  获取喽啰总数() {
    return this.喽啰池.获取总数量();
  }

  增加喽啰(数量, 武装等级 = '未武装') {
    this.喽啰池.增加喽啰(数量, 武装等级);
    this.统计数据.总生育喽啰数 += 数量;
    this.触发状态变更('喽啰变化', { 变化: 数量, 武装等级 });
  }

  减少喽啰(数量, 武装等级 = '未武装') {
    const 结果 = this.喽啰池.减少喽啰(数量, 武装等级);
    if (结果.成功) {
      this.触发状态变更('喽啰变化', { 变化: -结果.实际减少, 武装等级 });
    }
    return 结果;
  }

  武装升级喽啰(数量, 从等级, 到等级) {
    return this.喽啰池.武装升级(数量, 从等级, 到等级);
  }

  // ═══════════════════════════════════════════════════════════════
  // 军队状态管理
  // ═══════════════════════════════════════════════════════════════

  获取士气() {
    return this.军队状态.士气;
  }

  设置士气(值) {
    const 旧值 = this.军队状态.士气;
    this.军队状态.士气 = Math.max(
      this.军队状态.士气下限,
      Math.min(this.军队状态.士气上限, 值)
    );
    this.触发状态变更('士气变化', { 旧值, 新值: this.军队状态.士气 });
  }

  修改士气(增量) {
    const 旧值 = this.军队状态.士气;
    this.设置士气(this.军队状态.士气 + 增量);
    return this.军队状态.士气 - 旧值; // 返回实际变化量
  }

  获取基础战斗力() {
    return this.军队状态.战斗力基础值;
  }

  设置基础战斗力(值) {
    this.军队状态.战斗力基础值 = Math.max(0, 值);
  }

  修改基础战斗力(增量) {
    this.军队状态.战斗力基础值 = Math.max(0, this.军队状态.战斗力基础值 + 增量);
    return this.军队状态.战斗力基础值;
  }

  获取军队状态() {
    return { ...this.军队状态 };
  }

  获取军队概览() {
    return {
      士气: this.军队状态.士气,
      基础战斗力: this.军队状态.战斗力基础值,
      冠军数量: this.冠军列表.length,
      可战斗冠军: this.获取可战斗冠军().length,
      喽啰总数: this.喽啰池.获取总数量(),
      喽啰分组: this.喽啰池.获取分组详情(),
      加权战斗力: this.喽啰池.计算加权战斗力(),
    };
  }

  // ═══════════════════════════════════════════════════════════════
  // 全局变量管理
  // ═══════════════════════════════════════════════════════════════

  设置全局变量(键, 值) {
    const 旧值 = this.全局变量.get(键);
    this.全局变量.set(键, 值);
    this.触发状态变更('全局变量变更', { 键, 旧值, 新值: 值 });
  }

  获取全局变量(键, 默认值 = null) {
    return this.全局变量.has(键) ? this.全局变量.get(键) : 默认值;
  }

  删除全局变量(键) {
    const 存在 = this.全局变量.has(键);
    this.全局变量.delete(键);
    return 存在;
  }

  获取所有全局变量() {
    return Object.fromEntries(this.全局变量);
  }

  批量设置全局变量(变量对象) {
    Object.entries(变量对象).forEach(([键, 值]) => {
      this.全局变量.set(键, 值);
    });
  }

  // ═══════════════════════════════════════════════════════════════
  // 游戏标记管理
  // ═══════════════════════════════════════════════════════════════

  添加游戏标记(标记) {
    this.游戏标记.add(标记);
  }

  移除游戏标记(标记) {
    this.游戏标记.delete(标记);
  }

  拥有游戏标记(标记) {
    return this.游戏标记.has(标记);
  }

  获取所有游戏标记() {
    return Array.from(this.游戏标记);
  }

  // ═══════════════════════════════════════════════════════════════
  // 统计数据管理
  // ═══════════════════════════════════════════════════════════════

  获取统计数据() {
    return { ...this.统计数据 };
  }

  更新统计(统计项, 增量 = 1) {
    if (this.统计数据.hasOwnProperty(统计项)) {
      this.统计数据[统计项] += 增量;
    }
  }

  设置统计(统计项, 值) {
    if (this.统计数据.hasOwnProperty(统计项)) {
      this.统计数据[统计项] = 值;
    }
  }

  // ═══════════════════════════════════════════════════════════════
  // 游戏进度管理
  // ═══════════════════════════════════════════════════════════════

  标记事件完成(事件名) {
    this.游戏进度.已完成事件.add(事件名);
  }

  事件是否完成(事件名) {
    return this.游戏进度.已完成事件.has(事件名);
  }

  解锁功能(功能名) {
    this.游戏进度.已解锁功能.add(功能名);
    this.触发状态变更('功能解锁', { 功能名 });
  }

  功能是否解锁(功能名) {
    return this.游戏进度.已解锁功能.has(功能名);
  }

  触发里程碑(里程碑名) {
    if (!this.游戏进度.已触发里程碑.has(里程碑名)) {
      this.游戏进度.已触发里程碑.add(里程碑名);
      this.触发状态变更('里程碑达成', { 里程碑名 });
      return true;
    }
    return false;
  }

  里程碑是否触发(里程碑名) {
    return this.游戏进度.已触发里程碑.has(里程碑名);
  }

  获取游戏进度() {
    return {
      已完成事件: Array.from(this.游戏进度.已完成事件),
      已解锁功能: Array.from(this.游戏进度.已解锁功能),
      已触发里程碑: Array.from(this.游戏进度.已触发里程碑),
    };
  }

  // ═══════════════════════════════════════════════════════════════
  // 侦察目标管理
  // ═══════════════════════════════════════════════════════════════

  添加侦察目标(目标信息) {
    /**
     * 目标信息: { 目标ID, 名称, 位置, 预估战力, 高价值目标列表 }
     */
    this.侦察目标列表.push({
      ...目标信息,
      添加时间: Date.now(),
    });
    return 目标信息.目标ID;
  }

  移除侦察目标(目标ID) {
    const 索引 = this.侦察目标列表.findIndex(t => t.目标ID === 目标ID);
    if (索引 !== -1) {
      return this.侦察目标列表.splice(索引, 1)[0];
    }
    return null;
  }

  获取侦察目标(目标ID) {
    return this.侦察目标列表.find(t => t.目标ID === 目标ID) ?? null;
  }

  获取所有侦察目标() {
    return [...this.侦察目标列表];
  }

  // ═══════════════════════════════════════════════════════════════
  // 状态变更监听
  // ═══════════════════════════════════════════════════════════════

  添加状态变更监听器(监听器) {
    /**
     * 监听器签名: (变更类型, 数据) => void
     */
    this.状态变更监听器.push(监听器);
    return () => {
      const 索引 = this.状态变更监听器.indexOf(监听器);
      if (索引 !== -1) {
        this.状态变更监听器.splice(索引, 1);
      }
    };
  }

  触发状态变更(变更类型, 数据) {
    this.状态变更监听器.forEach(监听器 => {
      try {
        监听器(变更类型, 数据);
      } catch (错误) {
        console.error('状态变更监听器错误:', 错误);
      }
    });
  }

  // ═══════════════════════════════════════════════════════════════
  // 游戏概览
  // ═══════════════════════════════════════════════════════════════

  获取游戏概览() {
    return {
      // 领主
      领主姓名: this.领主?.获取属性('姓名') ?? '未设置',
      魔力: this.领主?.获取属性('魔力') ?? 0,
      最大魔力: this.领主?.获取属性('最大魔力') ?? 100,

      // 实体数量
      冠军数量: this.冠军列表.length,
      母畜数量: this.母畜列表.length,
      喽啰总数: this.喽啰池.获取总数量(),

      // 军队
      士气: this.军队状态.士气,
      基础战斗力: this.军队状态.战斗力基础值,

      // 统计
      统计: { ...this.统计数据 },

      // 元数据
      存档名称: this.元数据.存档名称,
      游戏版本: this.元数据.游戏版本,
    };
  }

  获取详细状态() {
    return {
      概览: this.获取游戏概览(),
      冠军列表: this.冠军列表.map(c => ({
        ID: c.实体ID,
        姓名: c.获取属性('姓名'),
        力量: c.获取属性('力量'),
        敏捷: c.获取属性('敏捷'),
        智力: c.获取属性('智力'),
        标签: c.获取所有标签(),
      })),
      母畜列表: this.母畜列表.map(m => ({
        ID: m.实体ID,
        姓名: m.获取属性('姓名'),
        原身份: m.获取属性('原身份'),
        种族: m.获取属性('种族'),
        总雌性价值: m.获取属性('总雌性价值'),
        剩余雌性价值: m.获取属性('剩余雌性价值'),
        臣服度: m.获取属性('臣服度'),
        淫乱度: m.获取属性('淫乱度'),
        标签: m.获取所有标签(),
      })),
      喽啰详情: this.喽啰池.获取分组详情(),
      军队状态: this.军队状态,
      侦察目标: this.侦察目标列表,
      全局变量: this.获取所有全局变量(),
      游戏标记: this.获取所有游戏标记(),
      游戏进度: this.获取游戏进度(),
    };
  }

  // ═══════════════════════════════════════════════════════════════
  // 验证与检查
  // ═══════════════════════════════════════════════════════════════

  验证状态完整性() {
    /**
     * 验证游戏状态的完整性
     * @returns { 有效: boolean, 问题列表: string[] }
     */
    const 问题列表 = [];

    // 检查领主
    if (!this.领主) {
      问题列表.push('领主未设置');
    }

    // 检查冠军ID唯一性
    const 冠军ID集合 = new Set();
    this.冠军列表.forEach(c => {
      if (冠军ID集合.has(c.实体ID)) {
        问题列表.push(`重复的冠军ID: ${c.实体ID}`);
      }
      冠军ID集合.add(c.实体ID);
    });

    // 检查母畜ID唯一性
    const 母畜ID集合 = new Set();
    this.母畜列表.forEach(m => {
      if (母畜ID集合.has(m.实体ID)) {
        问题列表.push(`重复的母畜ID: ${m.实体ID}`);
      }
      母畜ID集合.add(m.实体ID);
    });

    // 检查母畜属性有效性
    this.母畜列表.forEach(m => {
      const 剩余 = m.获取属性('剩余雌性价值');
      const 总量 = m.获取属性('总雌性价值');
      if (剩余 > 总量) {
        问题列表.push(`母畜 ${m.实体ID} 剩余价值超过总价值`);
      }
      if (m.获取属性('臣服度') < 0 || m.获取属性('臣服度') > 100) {
        问题列表.push(`母畜 ${m.实体ID} 臣服度超出范围`);
      }
      if (m.获取属性('淫乱度') < 0 || m.获取属性('淫乱度') > 100) {
        问题列表.push(`母畜 ${m.实体ID} 淫乱度超出范围`);
      }
    });

    // 检查士气范围
    if (this.军队状态.士气 < 0 || this.军队状态.士气 > 100) {
      问题列表.push('士气超出有效范围');
    }

    return {
      有效: 问题列表.length === 0,
      问题列表,
    };
  }

  修复状态问题() {
    /**
     * 尝试修复状态中的问题
     */
    const 修复记录 = [];

    // 修复士气范围
    if (this.军队状态.士气 < 0) {
      this.军队状态.士气 = 0;
      修复记录.push('士气修复为0');
    }
    if (this.军队状态.士气 > 100) {
      this.军队状态.士气 = 100;
      修复记录.push('士气修复为100');
    }

    // 修复母畜属性范围
    this.母畜列表.forEach(m => {
      const 剩余 = m.获取属性('剩余雌性价值');
      const 总量 = m.获取属性('总雌性价值');

      if (剩余 > 总量) {
        m.设置属性('剩余雌性价值', 总量);
        修复记录.push(`修复母畜 ${m.实体ID} 剩余价值`);
      }

      let 臣服度 = m.获取属性('臣服度');
      if (臣服度 < 0) {
        m.设置属性('臣服度', 0);
        修复记录.push(`修复母畜 ${m.实体ID} 臣服度下限`);
      }
      if (臣服度 > 100) {
        m.设置属性('臣服度', 100);
        修复记录.push(`修复母畜 ${m.实体ID} 臣服度上限`);
      }

      let 淫乱度 = m.获取属性('淫乱度');
      if (淫乱度 < 0) {
        m.设置属性('淫乱度', 0);
        修复记录.push(`修复母畜 ${m.实体ID} 淫乱度下限`);
      }
      if (淫乱度 > 100) {
        m.设置属性('淫乱度', 100);
        修复记录.push(`修复母畜 ${m.实体ID} 淫乱度上限`);
      }
    });

    return 修复记录;
  }

  // ═══════════════════════════════════════════════════════════════
  // 重置与清理
  // ═══════════════════════════════════════════════════════════════

  重置游戏状态() {
    /**
     * 完全重置游戏状态
     */
    this.领主 = null;
    this.冠军列表 = [];
    this.母畜列表 = [];
    this.喽啰池 = new 喽啰池();

    this.军队状态 = {
      士气: 50,
      战斗力基础值: 100,
      士气上限: 100,
      士气下限: 0,
    };

    this.全局变量.clear();
    this.游戏标记.clear();
    this.侦察目标列表 = [];

    this.统计数据 = {
      总生育冠军数: 0,
      总生育喽啰数: 0,
      总战斗次数: 0,
      总胜利次数: 0,
      总献祭母畜数: 0,
      总消耗母乳: 0,
      总获得魔力: 0,
    };

    this.游戏进度 = {
      已完成事件: new Set(),
      已解锁功能: new Set(),
      已触发里程碑: new Set(),
    };

    this.元数据.创建时间 = Date.now();
    this.元数据.最后保存时间 = null;

    this.触发状态变更('游戏重置', {});
  }

  // ═══════════════════════════════════════════════════════════════
  // 序列化与反序列化
  // ═══════════════════════════════════════════════════════════════

  序列化() {
    /**
     * 将游戏状态序列化为可存储的对象
     */
    this.元数据.最后保存时间 = Date.now();

    return {
      版本: this.元数据.游戏版本,
      元数据: { ...this.元数据 },

      领主: this.领主?.序列化() ?? null,
      冠军列表: this.冠军列表.map(c => c.序列化()),
      母畜列表: this.母畜列表.map(m => m.序列化()),
      喽啰池: this.喽啰池.序列化(),

      军队状态: { ...this.军队状态 },
      全局变量: Object.fromEntries(this.全局变量),
      游戏标记: Array.from(this.游戏标记),
      统计数据: { ...this.统计数据 },
      侦察目标列表: this.侦察目标列表,

      游戏进度: {
        已完成事件: Array.from(this.游戏进度.已完成事件),
        已解锁功能: Array.from(this.游戏进度.已解锁功能),
        已触发里程碑: Array.from(this.游戏进度.已触发里程碑),
      },
    };
  }

  从序列化恢复(数据) {
    /**
     * 从序列化数据恢复游戏状态
     */
    if (!数据) {
      throw new Error('无效的存档数据');
    }

    // 版本检查
    if (数据.版本 && 数据.版本 !== this.元数据.游戏版本) {
      console.warn(`存档版本不匹配: ${数据.版本} vs ${this.元数据.游戏版本}`);
      // 可在此处添加版本迁移逻辑
    }

    // 恢复元数据
    if (数据.元数据) {
      Object.assign(this.元数据, 数据.元数据);
    }

    // 恢复领主
    if (数据.领主) {
      this.领主 = 领主实体.从序列化恢复(数据.领主);
    }

    // 恢复冠军列表
    this.冠军列表 = (数据.冠军列表 ?? []).map(数据 =>
      冠军实体.从序列化恢复(数据)
    );

    // 恢复母畜列表
    this.母畜列表 = (数据.母畜列表 ?? []).map(数据 =>
      母畜实体.从序列化恢复(数据)
    );

    // 恢复喽啰池
    if (数据.喽啰池) {
      this.喽啰池 = 喽啰池.从序列化恢复(数据.喽啰池);
    }

    // 恢复军队状态
    if (数据.军队状态) {
      Object.assign(this.军队状态, 数据.军队状态);
    }

    // 恢复全局变量
    this.全局变量.clear();
    if (数据.全局变量) {
      Object.entries(数据.全局变量).forEach(([键, 值]) => {
        this.全局变量.set(键, 值);
      });
    }

    // 恢复游戏标记
    this.游戏标记.clear();
    if (数据.游戏标记) {
      数据.游戏标记.forEach(标记 => this.游戏标记.add(标记));
    }

    // 恢复统计数据
    if (数据.统计数据) {
      Object.assign(this.统计数据, 数据.统计数据);
    }

    // 恢复侦察目标
    this.侦察目标列表 = 数据.侦察目标列表 ?? [];

    // 恢复游戏进度
    if (数据.游戏进度) {
      this.游戏进度.已完成事件 = new Set(数据.游戏进度.已完成事件 ?? []);
      this.游戏进度.已解锁功能 = new Set(数据.游戏进度.已解锁功能 ?? []);
      this.游戏进度.已触发里程碑 = new Set(数据.游戏进度.已触发里程碑 ?? []);
    }

    this.触发状态变更('存档加载', { 版本: 数据.版本 });
  }

  // ═══════════════════════════════════════════════════════════════
  // 静态工厂方法
  // ═══════════════════════════════════════════════════════════════

  static 创建新游戏(配置 = {}) {
    /**
     * 创建新游戏状态的工厂方法
     */
    const 状态 = new 游戏状态(配置);

    // 创建默认领主
    const 领主 = new 领主实体({
      姓名: 配置.领主姓名 ?? '无名领主',
      魔力: 配置.初始魔力 ?? 0,
      最大魔力: 配置.最大魔力 ?? 100,
    });
    状态.设置领主(领主);

    // 初始化默认喽啰武装等级
    状态.喽啰池.注册武装等级('低级武装', { 战斗力: 110 });
    状态.喽啰池.注册武装等级('中级武装', { 战斗力: 130 });
    状态.喽啰池.注册武装等级('高级武装', { 战斗力: 180 });
    状态.喽啰池.注册武装等级('精英武装', { 战斗力: 250 });

    // 添加初始喽啰
    if (配置.初始喽啰数量) {
      状态.喽啰池.增加喽啰(配置.初始喽啰数量);
    }

    return 状态;
  }

  static 从存档加载(存档数据, 配置 = {}) {
    /**
     * 从存档数据加载游戏状态
     */
    const 状态 = new 游戏状态(配置);
    状态.从序列化恢复(存档数据);
    return 状态;
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 游戏状态 };
export default 游戏状态;
```


src\systems\breeding.js
```js
// ═══════════════════════════════════════════════════════════════
// systems/breeding.js
// 繁殖系统 - 管理母畜生育冠军和喽啰
// ═══════════════════════════════════════════════════════════════

/**
 * 繁殖系统
 * 管理母畜的生育功能，包括生育冠军和喽啰
 */
class 繁殖系统 {
  constructor(事件总线, 冠军工厂, 喽啰池, 属性注册表 = null, 公式引擎 = null) {
    this.事件总线 = 事件总线;
    this.冠军工厂 = 冠军工厂;
    this.喽啰池 = 喽啰池;
    this.属性注册表 = 属性注册表;
    this.公式引擎 = 公式引擎;

    // 生育历史
    this.生育历史 = [];
    this.历史上限 = 100;

    // 生育统计
    this.统计 = {
      总生育冠军数: 0,
      总生育喽啰数: 0,
    };
  }

  // ─── 配置获取 ───

  获取配置(配置名, 默认值) {
    return this.公式引擎?.获取常量(配置名, 默认值) ?? 默认值;
  }

  // ─── 配置方法 ───

  设置公式引擎(引擎) {
    this.公式引擎 = 引擎;
  }

  设置冠军工厂(工厂) {
    this.冠军工厂 = 工厂;
  }

  设置喽啰池(池) {
    this.喽啰池 = 池;
  }

  设置属性注册表(注册表) {
    this.属性注册表 = 注册表;
  }

  // ─── 生育验证 ───

  验证可生育冠军(母畜) {
    const 剩余价值 = 母畜.获取属性('剩余雌性价值');
    const 消耗 = this.获取配置('冠军生育消耗', 100);

    if (剩余价值 < 消耗) {
      return {
        可生育: false,
        原因: '剩余雌性价值不足',
        当前: 剩余价值,
        需要: 消耗,
      };
    }

    return { 可生育: true };
  }

  验证可生育喽啰(母畜) {
    const 剩余价值 = 母畜.获取属性('剩余雌性价值');

    if (剩余价值 <= 0) {
      return {
        可生育: false,
        原因: '剩余雌性价值已耗尽',
        当前: 0,
      };
    }

    return { 可生育: true };
  }

  // ─── 生育冠军 ───

  生育冠军(母畜, 选项 = {}) {
    const 验证结果 = this.验证可生育冠军(母畜);
    if (!验证结果.可生育) {
      return { 成功: false, ...验证结果 };
    }

    const 冠军消耗 = this.获取配置('冠军生育消耗', 100);
    const 淫乱度增加 = this.获取配置('生育淫乱度增加', 8);

    // 消耗雌性价值
    const 消耗结果 = 母畜.消耗雌性价值(冠军消耗);
    if (!消耗结果.成功) {
      return { 成功: false, 原因: '消耗雌性价值失败' };
    }

    // 增加淫乱度
    母畜.修改属性('淫乱度', 淫乱度增加, this.属性注册表);

    // 生成冠军
    const 生育结果 = this.冠军工厂.从母畜生育(母畜, 选项);

    if (!生育结果.成功) {
      母畜.修改属性('剩余雌性价值', 冠军消耗);
      return { 成功: false, 原因: 生育结果.原因 };
    }

    const 新冠军 = 生育结果.冠军;

    母畜.记录生育冠军?.(新冠军.实体ID, 新冠军.获取属性('姓名'));

    this.记录生育历史({
      类型: '生育冠军',
      母畜ID: 母畜.实体ID,
      母畜姓名: 母畜.获取属性('姓名'),
      冠军ID: 新冠军.实体ID,
      冠军姓名: 新冠军.获取属性('姓名'),
      消耗雌性价值: 冠军消耗,
      冠军属性: {
        力量: 新冠军.获取属性('力量'),
        敏捷: 新冠军.获取属性('敏捷'),
        智力: 新冠军.获取属性('智力'),
      },
    });

    this.统计.总生育冠军数++;

    this.事件总线.发布('冠军诞生', {
      冠军: 新冠军,
      母畜ID: 母畜.实体ID,
      母畜姓名: 母畜.获取属性('姓名'),
    });

    return {
      成功: true,
      冠军: 新冠军,
      消耗雌性价值: 冠军消耗,
      淫乱度增加,
      剩余雌性价值: 母畜.获取属性('剩余雌性价值'),
    };
  }

  // ─── 生育喽啰 ───

  生育喽啰(母畜, 选项 = {}) {
    const 验证结果 = this.验证可生育喽啰(母畜);
    if (!验证结果.可生育) {
      return { 成功: false, ...验证结果 };
    }

    const 剩余价值 = 母畜.获取属性('剩余雌性价值');

    // 使用公式计算产出
    const 产出计算 = this.公式引擎?.计算('喽啰产出计算', { 剩余雌性价值: 剩余价值 }) ?? {
      实际消耗: Math.min(剩余价值, 100),
      实际产出: 剩余价值 >= 100 ? 10 : Math.floor(剩余价值 / 10),
    };

    const { 实际消耗, 实际产出 } = 产出计算;

    if (实际产出 <= 0) {
      return { 成功: false, 原因: '剩余雌性价值过低，无法产出喽啰' };
    }

    母畜.消耗雌性价值(实际消耗);

    const 淫乱度增加 = this.获取配置('生育淫乱度增加', 8);
    母畜.修改属性('淫乱度', 淫乱度增加, this.属性注册表);

    const 武装等级 = 选项.武装等级 ?? '未武装';
    this.喽啰池.增加喽啰(实际产出, 武装等级);

    母畜.记录生育喽啰?.(实际产出);

    this.记录生育历史({
      类型: '生育喽啰',
      母畜ID: 母畜.实体ID,
      母畜姓名: 母畜.获取属性('姓名'),
      产出数量: 实际产出,
      消耗雌性价值: 实际消耗,
      武装等级,
    });

    this.统计.总生育喽啰数 += 实际产出;

    this.事件总线.发布('喽啰诞生', {
      数量: 实际产出,
      母畜ID: 母畜.实体ID,
      母畜姓名: 母畜.获取属性('姓名'),
    });

    return {
      成功: true,
      产出数量: 实际产出,
      消耗雌性价值: 实际消耗,
      淫乱度增加,
      剩余雌性价值: 母畜.获取属性('剩余雌性价值'),
    };
  }

  // ─── 批量生育 ───

  批量生育喽啰(母畜列表, 选项 = {}) {
    const 结果列表 = [];
    let 总产出 = 0;

    for (const 母畜 of 母畜列表) {
      const 结果 = this.生育喽啰(母畜, 选项);
      结果列表.push({
        母畜ID: 母畜.实体ID,
        ...结果,
      });

      if (结果.成功) {
        总产出 += 结果.产出数量;
      }
    }

    return {
      结果列表,
      总产出,
      成功数: 结果列表.filter(r => r.成功).length,
    };
  }

  // ─── 生育预估 ───

  预估生育冠军(母畜) {
    const 验证 = this.验证可生育冠军(母畜);
    if (!验证.可生育) {
      return { 可生育: false, 原因: 验证.原因 };
    }

    const 属性预估 = this.冠军工厂.预估生育属性(母畜);

    return {
      可生育: true,
      消耗雌性价值: this.获取配置('冠军生育消耗', 100),
      淫乱度增加: this.获取配置('生育淫乱度增加', 8),
      属性预估,
    };
  }

  预估生育喽啰(母畜) {
    const 验证 = this.验证可生育喽啰(母畜);
    if (!验证.可生育) {
      return { 可生育: false, 原因: 验证.原因 };
    }

    const 剩余价值 = 母畜.获取属性('剩余雌性价值');
    const 产出计算 = this.公式引擎?.计算('喽啰产出计算', { 剩余雌性价值: 剩余价值 }) ?? {
      实际消耗: Math.min(剩余价值, 100),
      实际产出: 剩余价值 >= 100 ? 10 : Math.floor(剩余价值 / 10),
    };

    return {
      可生育: 产出计算.实际产出 > 0,
      消耗雌性价值: 产出计算.实际消耗,
      预估产出: 产出计算.实际产出,
      淫乱度增加: this.获取配置('生育淫乱度增加', 8),
    };
  }

  // ─── 历史记录 ───

  记录生育历史(记录) {
    this.生育历史.push({
      ...记录,
      时间戳: Date.now(),
    });

    while (this.生育历史.length > this.历史上限) {
      this.生育历史.shift();
    }
  }

  获取生育历史(过滤条件 = {}) {
    let 结果 = [...this.生育历史];

    if (过滤条件.母畜ID) {
      结果 = 结果.filter(h => h.母畜ID === 过滤条件.母畜ID);
    }

    if (过滤条件.类型) {
      结果 = 结果.filter(h => h.类型 === 过滤条件.类型);
    }

    if (过滤条件.数量) {
      结果 = 结果.slice(-过滤条件.数量);
    }

    return 结果;
  }

  获取统计() {
    return { ...this.统计 };
  }

  序列化() {
    return {
      生育历史: this.生育历史.slice(-50),
      统计: this.统计,
    };
  }

  从序列化恢复(数据) {
    this.生育历史 = 数据.生育历史 ?? [];
    this.统计 = 数据.统计 ?? {
      总生育冠军数: 0,
      总生育喽啰数: 0,
    };
  }
}

export { 繁殖系统 };
export default 繁殖系统;
```


src\systems\combat.js
```js
// ═══════════════════════════════════════════════════════════════
// systems/combat.js
// 战斗系统 - 管理军队战斗、战力计算和战斗结算
// ═══════════════════════════════════════════════════════════════

/**
 * 战斗系统
 * 管理军队编成、战力计算、战斗执行和结果处理
 */
class 战斗系统 {
  constructor(事件总线, 公式引擎, 情报系统 = null) {
    this.事件总线 = 事件总线;
    this.公式引擎 = 公式引擎;
    this.情报系统 = 情报系统;

    // 战斗结果处理器
    this.战斗结果处理器 = new Map();

    // 战斗历史
    this.战斗历史 = [];
    this.历史上限 = 50;

    // 战力修正器
    this.战力修正器 = [];
  }

  // ─── 配置获取 ───

  获取配置(配置名, 默认值) {
    return this.公式引擎?.获取常量(配置名, 默认值) ?? 默认值;
  }

  // ─── 战斗结果表（动态生成）───

  生成战斗结果表() {
    return [
      {
        类型: '溃败',
        战力比范围: [0, this.获取配置('战力比_溃败上限', 0.5)],
        存活率: this.获取配置('存活率_溃败', 0.2),
        士气变化: this.获取配置('士气变化_溃败', -50),
        俘获规则: null,
        描述: '我军遭遇惨烈失败，大量人员溃散',
      },
      {
        类型: '惨败',
        战力比范围: [this.获取配置('战力比_溃败上限', 0.5), this.获取配置('战力比_惨败上限', 0.8)],
        存活率: this.获取配置('存活率_惨败', 0.4),
        士气变化: this.获取配置('士气变化_惨败', -30),
        俘获规则: null,
        描述: '我军战败，损失惨重',
      },
      {
        类型: '惜败',
        战力比范围: [this.获取配置('战力比_惨败上限', 0.8), this.获取配置('战力比_惜败上限', 1.0)],
        存活率: this.获取配置('存活率_惜败', 0.6),
        士气变化: this.获取配置('士气变化_惜败', -10),
        俘获规则: null,
        描述: '我军略处下风，有序撤退',
      },
      {
        类型: '险胜',
        战力比范围: [this.获取配置('战力比_惜败上限', 1.0), this.获取配置('战力比_险胜上限', 1.2)],
        存活率: this.获取配置('存活率_险胜', 0.7),
        士气变化: this.获取配置('士气变化_险胜', 5),
        俘获规则: { 保底: this.获取配置('俘获保底_险胜', 1) },
        描述: '我军险胜，付出一定代价',
      },
      {
        类型: '小胜',
        战力比范围: [this.获取配置('战力比_险胜上限', 1.2), this.获取配置('战力比_小胜上限', 1.5)],
        存活率: this.获取配置('存活率_小胜', 0.85),
        士气变化: this.获取配置('士气变化_小胜', 10),
        俘获规则: { 保底: this.获取配置('俘获保底_小胜', 2) },
        描述: '我军获胜，战果可观',
      },
      {
        类型: '大胜',
        战力比范围: [this.获取配置('战力比_小胜上限', 1.5), this.获取配置('战力比_大胜上限', 2.0)],
        存活率: this.获取配置('存活率_大胜', 0.95),
        士气变化: this.获取配置('士气变化_大胜', 15),
        俘获规则: { 保底: this.获取配置('俘获保底_大胜', 3) },
        描述: '我军大获全胜',
      },
      {
        类型: '碾压',
        战力比范围: [this.获取配置('战力比_大胜上限', 2.0), Infinity],
        存活率: this.获取配置('存活率_碾压', 1.0),
        士气变化: this.获取配置('士气变化_碾压', 20),
        俘获规则: { 全部俘获: true },
        描述: '我军以压倒性优势获胜',
      },
    ];
  }

  // ─── 战力计算 ───

  计算部曲战力(冠军, 喽啰配置, 士气) {
    const 力量 = 冠军.获取属性('力量');
    const 可统帅上限 = 冠军.计算可统帅喽啰数?.() ?? 力量;

    let 总战力 = 0;
    let 已分配喽啰 = 0;

    const 排序后配置 = [...喽啰配置].sort((a, b) => b.战斗力 - a.战斗力);

    for (const 配置 of 排序后配置) {
      const 可分配数量 = Math.min(配置.数量, 可统帅上限 - 已分配喽啰);
      if (可分配数量 <= 0) continue;

      const 部曲战力 =
        this.公式引擎?.计算('部曲战力', {
          有效喽啰数: 可分配数量,
          冠军力量: 力量,
          武装战斗力: 配置.战斗力,
          士气,
        }) ?? 可分配数量 * (配置.战斗力 / 100);

      总战力 += 部曲战力;
      已分配喽啰 += 可分配数量;
    }

    const 士气系数 = this.公式引擎?.计算('士气系数', { 士气 }) ?? 1.0;

    return {
      战力: 总战力 * 士气系数,
      已分配喽啰,
      溢出喽啰: 喽啰配置.reduce((sum, c) => sum + c.数量, 0) - 已分配喽啰,
    };
  }

  计算军队总战力(出击配置) {
    const { 部曲列表, 士气 } = 出击配置;

    let 总战力 = 0;
    const 部曲详情 = [];

    for (const 部曲 of 部曲列表) {
      const 结果 = this.计算部曲战力(部曲.冠军, 部曲.喽啰配置, 士气);
      总战力 += 结果.战力;
      部曲详情.push({
        冠军ID: 部曲.冠军.实体ID,
        冠军姓名: 部曲.冠军.获取属性('姓名'),
        ...结果,
      });
    }

    let 修正后战力 = 总战力;
    for (const 修正器 of this.战力修正器) {
      修正后战力 = 修正器(修正后战力, 出击配置);
    }

    return {
      基础战力: 总战力,
      修正后战力,
      部曲详情,
      士气,
    };
  }

  // ─── 战斗执行 ───

  执行战斗(我方配置, 敌方战力, 战斗参数 = {}) {
    const 目标ID = 战斗参数.目标ID;

    this.事件总线.发布('战斗开始', {
      我方配置,
      敌方战力,
      目标ID,
    });

    const 我方战力计算 = this.计算军队总战力(我方配置);
    const 我方战力 = 我方战力计算.修正后战力;

    const 战力比 = 敌方战力 > 0 ? 我方战力 / 敌方战力 : Infinity;

    const 结果模板 = this.判定战斗结果(战力比);

    const 喽啰损失 = this.计算喽啰损失(我方配置, 结果模板.存活率);
    const 冠军损失 = this.计算冠军损失(我方配置, 结果模板, 战力比);
    const 战利品 = this.处理战利品(目标ID, 结果模板);

    const 战斗报告 = {
      时间戳: Date.now(),
      目标ID,
      我方战力,
      敌方战力,
      战力比: Math.round(战力比 * 100) / 100,
      结果类型: 结果模板.类型,
      是否胜利: 战力比 >= 1.0,
      描述: 结果模板.描述,
      喽啰损失,
      冠军损失,
      战利品,
      士气变化: 结果模板.士气变化,
      我方战力详情: 我方战力计算,
    };

    this.记录战斗历史(战斗报告);

    this.事件总线.发布('战斗结束', 战斗报告);

    return 战斗报告;
  }

  判定战斗结果(战力比) {
    const 结果表 = this.生成战斗结果表();
    for (const 结果 of 结果表) {
      const [下限, 上限] = 结果.战力比范围;
      if (战力比 >= 下限 && 战力比 < 上限) {
        return { ...结果 };
      }
    }
    return { ...结果表[结果表.length - 1] };
  }

  // ─── 损失计算 ───

  计算喽啰损失(配置, 存活率) {
    const 损失明细 = [];
    let 总损失 = 0;

    配置.部曲列表.forEach(部曲 => {
      部曲.喽啰配置.forEach(喽啰组 => {
        const 损失数 = Math.floor(喽啰组.数量 * (1 - 存活率));
        if (损失数 > 0) {
          损失明细.push({
            武装等级: 喽啰组.武装等级 ?? '未武装',
            损失数量: 损失数,
            剩余数量: 喽啰组.数量 - 损失数,
          });
          总损失 += 损失数;
        }
      });
    });

    return {
      明细: 损失明细,
      总损失,
    };
  }

  计算冠军损失(配置, 结果模板, 战力比) {
    const 损失情况 = [];

    const 惜败存活率 = this.获取配置('存活率_惜败', 0.6);
    if (结果模板.存活率 >= 惜败存活率) {
      return { 损失情况, 有损失: false };
    }

    配置.部曲列表.forEach(部曲 => {
      const 冠军 = 部曲.冠军;
      const 已负伤 = 冠军.拥有标签?.('负伤') ?? false;

      const 阵亡概率 = this.公式引擎?.计算('冠军阵亡概率', { 战力比, 已负伤 }) ?? 0;
      const 负伤概率 = this.公式引擎?.计算('冠军负伤概率', { 战力比, 已负伤 }) ?? 0;

      if (Math.random() < 阵亡概率) {
        损失情况.push({
          冠军ID: 冠军.实体ID,
          冠军姓名: 冠军.获取属性('姓名'),
          状态: '阵亡',
        });
      } else if (Math.random() < 负伤概率) {
        损失情况.push({
          冠军ID: 冠军.实体ID,
          冠军姓名: 冠军.获取属性('姓名'),
          状态: '负伤',
        });
      }
    });

    return {
      损失情况,
      有损失: 损失情况.length > 0,
    };
  }

  // ─── 战利品处理 ───

  处理战利品(目标ID, 战斗结果) {
    const 战利品 = {
      俘获目标: [],
      其他资源: {},
    };

    if (!目标ID || !this.情报系统) {
      return 战利品;
    }

    const 情报 = this.情报系统.获取目标情报(目标ID);
    if (!情报) return 战利品;

    const 已锁定 = this.情报系统.获取已锁定目标(目标ID);
    已锁定.forEach(目标 => {
      战利品.俘获目标.push(目标);
    });

    if (战斗结果.俘获规则) {
      if (战斗结果.俘获规则.全部俘获) {
        const 未锁定 = this.情报系统.获取未锁定目标(目标ID);
        未锁定.forEach(目标 => {
          if (!战利品.俘获目标.find(t => t.ID === 目标.ID)) {
            战利品.俘获目标.push(目标);
          }
        });
      } else if (战斗结果.俘获规则.保底) {
        const 未锁定 = this.情报系统.获取未锁定目标(目标ID);
        const 可俘获数 = Math.min(战斗结果.俘获规则.保底, 未锁定.length);

        for (let i = 0; i < 可俘获数; i++) {
          if (!战利品.俘获目标.find(t => t.ID === 未锁定[i].ID)) {
            战利品.俘获目标.push(未锁定[i]);
          }
        }
      }
    }

    return 战利品;
  }

  // ─── 战力修正器 ───

  添加战力修正器(修正函数, 标识 = '', 优先级 = 0) {
    const 修正器 = { 函数: 修正函数, 标识, 优先级 };
    this.战力修正器.push(修正器);
    this.战力修正器.sort((a, b) => b.优先级 - a.优先级);

    return () => {
      const 索引 = this.战力修正器.indexOf(修正器);
      if (索引 !== -1) this.战力修正器.splice(索引, 1);
    };
  }

  清空战力修正器() {
    this.战力修正器 = [];
  }

  // ─── 历史记录 ───

  记录战斗历史(报告) {
    this.战斗历史.push(报告);

    while (this.战斗历史.length > this.历史上限) {
      this.战斗历史.shift();
    }
  }

  获取战斗历史(过滤条件 = {}) {
    let 结果 = [...this.战斗历史];

    if (过滤条件.目标ID) {
      结果 = 结果.filter(h => h.目标ID === 过滤条件.目标ID);
    }

    if (过滤条件.只看胜利) {
      结果 = 结果.filter(h => h.是否胜利);
    }

    if (过滤条件.数量) {
      结果 = 结果.slice(-过滤条件.数量);
    }

    return 结果;
  }

  // ─── 战力预估 ───

  预估战斗结果(我方配置, 敌方战力估计) {
    const 我方战力 = this.计算军队总战力(我方配置).修正后战力;

    const 最优战力比 = 敌方战力估计.最小 > 0 ? 我方战力 / 敌方战力估计.最小 : Infinity;
    const 最劣战力比 = 敌方战力估计.最大 > 0 ? 我方战力 / 敌方战力估计.最大 : 0;

    const 最优结果 = this.判定战斗结果(最优战力比);
    const 最劣结果 = this.判定战斗结果(最劣战力比);

    return {
      我方战力,
      敌方战力估计,
      最优情况: {
        战力比: 最优战力比,
        结果类型: 最优结果.类型,
        存活率: 最优结果.存活率,
      },
      最劣情况: {
        战力比: 最劣战力比,
        结果类型: 最劣结果.类型,
        存活率: 最劣结果.存活率,
      },
      建议: this.生成战斗建议(最劣战力比),
    };
  }

  生成战斗建议(最劣战力比) {
    const 大胜阈值 = this.获取配置('战力比_大胜上限', 2.0);
    const 小胜阈值 = this.获取配置('战力比_小胜上限', 1.5);
    const 惜败阈值 = this.获取配置('战力比_惜败上限', 1.0);
    const 惨败阈值 = this.获取配置('战力比_惨败上限', 0.8);

    if (最劣战力比 >= 大胜阈值) return '胜券在握，可放心出击';
    if (最劣战力比 >= 小胜阈值) return '胜算较大，建议出击';
    if (最劣战力比 >= 惜败阈值) return '胜负难料，谨慎考虑';
    if (最劣战力比 >= 惨败阈值) return '风险较大，不建议出击';
    return '敌我悬殊，强烈不建议出击';
  }

  序列化() {
    return {
      战斗历史: this.战斗历史,
    };
  }

  从序列化恢复(数据) {
    this.战斗历史 = 数据.战斗历史 ?? [];
  }
}

export { 战斗系统 };
export default 战斗系统;
```


src\systems\event-bus.js
```js
// ═══════════════════════════════════════════════════════════════
// systems/event-bus.js
// 事件总线 - 全局事件发布订阅系统
// ═══════════════════════════════════════════════════════════════

/**
 * 事件总线
 * 提供发布-订阅模式的事件通信机制
 * 支持优先级、通配符订阅、事件历史记录
 */
class 事件总线 {
  constructor(配置 = {}) {
    // 订阅者映射: 事件名 -> [{ 处理器, 优先级, 一次性 }]
    this.订阅者映射 = new Map();

    // 事件历史记录
    this.事件历史 = [];
    this.历史上限 = 配置.历史上限 ?? 1000;
    this.启用历史记录 = 配置.启用历史记录 ?? true;

    // 事件拦截器
    this.拦截器列表 = [];

    // 调试模式
    this.调试模式 = 配置.调试模式 ?? false;

    // 异步事件队列
    this.异步队列 = [];
    this.正在处理异步 = false;

    // 统计信息
    this.统计 = {
      发布次数: 0,
      订阅次数: 0,
      处理次数: 0,
    };
  }

  // ─── 订阅方法 ───

  订阅(事件名, 处理器, 选项 = {}) {
    /**
     * 订阅事件
     * @param 事件名 - 事件名称，支持通配符 '*'
     * @param 处理器 - 事件处理函数 (事件对象) => void
     * @param 选项 - { 优先级: number, 一次性: boolean }
     * @returns 取消订阅函数
     */
    const 优先级 = 选项.优先级 ?? 选项.priority ?? 0;
    const 一次性 = 选项.一次性 ?? 选项.once ?? false;

    if (!this.订阅者映射.has(事件名)) {
      this.订阅者映射.set(事件名, []);
    }

    const 订阅信息 = {
      处理器,
      优先级,
      一次性,
      订阅时间: Date.now(),
    };

    const 订阅列表 = this.订阅者映射.get(事件名);
    订阅列表.push(订阅信息);

    // 按优先级排序（高优先级在前）
    订阅列表.sort((a, b) => b.优先级 - a.优先级);

    this.统计.订阅次数++;

    // 返回取消订阅函数
    return () => this.取消订阅(事件名, 处理器);
  }

  一次性订阅(事件名, 处理器, 优先级 = 0) {
    /**
     * 订阅一次性事件（触发后自动取消订阅）
     */
    return this.订阅(事件名, 处理器, { 优先级, 一次性: true });
  }

  取消订阅(事件名, 处理器) {
    /**
     * 取消订阅
     */
    const 订阅列表 = this.订阅者映射.get(事件名);
    if (!订阅列表) return false;

    const 索引 = 订阅列表.findIndex(s => s.处理器 === 处理器);
    if (索引 !== -1) {
      订阅列表.splice(索引, 1);
      return true;
    }
    return false;
  }

  取消所有订阅(事件名 = null) {
    /**
     * 取消所有订阅
     * @param 事件名 - 如果提供，只取消该事件的订阅；否则取消所有
     */
    if (事件名) {
      this.订阅者映射.delete(事件名);
    } else {
      this.订阅者映射.clear();
    }
  }

  // ─── 发布方法 ───

  发布(事件名, 数据 = {}) {
    /**
     * 同步发布事件
     * @param 事件名 - 事件名称
     * @param 数据 - 事件数据
     * @returns 事件对象
     */
    const 事件对象 = this.创建事件对象(事件名, 数据);

    // 执行拦截器
    for (const 拦截器 of this.拦截器列表) {
      const 结果 = 拦截器(事件对象);
      if (结果 === false) {
        事件对象.已拦截 = true;
        return 事件对象;
      }
    }

    // 记录历史
    if (this.启用历史记录) {
      this.记录事件历史(事件对象);
    }

    // 调试输出
    if (this.调试模式) {
      console.log(`[事件总线] 发布: ${事件名}`, 数据);
    }

    // 执行订阅者
    this.执行订阅者(事件对象, 事件名);

    // 执行通配符订阅者
    this.执行订阅者(事件对象, '*');

    this.统计.发布次数++;

    return 事件对象;
  }

  异步发布(事件名, 数据 = {}) {
    /**
     * 异步发布事件（加入队列，稍后执行）
     * @returns Promise<事件对象>
     */
    return new Promise(resolve => {
      this.异步队列.push({
        事件名,
        数据,
        回调: resolve,
      });

      this.处理异步队列();
    });
  }

  延迟发布(事件名, 数据 = {}, 延迟毫秒 = 0) {
    /**
     * 延迟发布事件
     * @returns Promise<事件对象>
     */
    return new Promise(resolve => {
      setTimeout(() => {
        const 事件对象 = this.发布(事件名, 数据);
        resolve(事件对象);
      }, 延迟毫秒);
    });
  }

  // ─── 内部方法 ───

  创建事件对象(事件名, 数据) {
    return {
      名称: 事件名,
      name: 事件名, // 英文别名
      时间戳: Date.now(),
      数据,
      data: 数据, // 英文别名
      已阻止: false,
      已拦截: false,
      阻止传播() {
        this.已阻止 = true;
      },
      stopPropagation() {
        this.已阻止 = true;
      },
    };
  }

  执行订阅者(事件对象, 事件名) {
    const 订阅列表 = this.订阅者映射.get(事件名);
    if (!订阅列表 || 订阅列表.length === 0) return;

    // 收集需要移除的一次性订阅
    const 待移除 = [];

    for (const 订阅信息 of 订阅列表) {
      if (事件对象.已阻止) break;

      try {
        订阅信息.处理器(事件对象);
        this.统计.处理次数++;
      } catch (错误) {
        console.error(`[事件总线] 处理器错误 [${事件对象.名称}]:`, 错误);
      }

      if (订阅信息.一次性) {
        待移除.push(订阅信息);
      }
    }

    // 移除一次性订阅
    待移除.forEach(订阅信息 => {
      const 索引 = 订阅列表.indexOf(订阅信息);
      if (索引 !== -1) {
        订阅列表.splice(索引, 1);
      }
    });
  }

  async 处理异步队列() {
    if (this.正在处理异步) return;
    this.正在处理异步 = true;

    while (this.异步队列.length > 0) {
      const { 事件名, 数据, 回调 } = this.异步队列.shift();

      // 使用微任务确保异步
      await Promise.resolve();

      const 事件对象 = this.发布(事件名, 数据);
      回调(事件对象);
    }

    this.正在处理异步 = false;
  }

  // ─── 拦截器 ───

  添加拦截器(拦截函数) {
    /**
     * 添加事件拦截器
     * 拦截函数返回 false 时阻止事件发布
     * @returns 移除拦截器函数
     */
    this.拦截器列表.push(拦截函数);

    return () => {
      const 索引 = this.拦截器列表.indexOf(拦截函数);
      if (索引 !== -1) {
        this.拦截器列表.splice(索引, 1);
      }
    };
  }

  // ─── 历史记录 ───

  记录事件历史(事件对象) {
    this.事件历史.push({
      名称: 事件对象.名称,
      时间戳: 事件对象.时间戳,
      数据: 事件对象.数据,
    });

    // 限制历史记录数量
    while (this.事件历史.length > this.历史上限) {
      this.事件历史.shift();
    }
  }

  获取事件历史(过滤条件 = {}) {
    /**
     * 获取事件历史
     * @param 过滤条件 - { 事件名?, 数量?, 开始时间?, 结束时间? }
     */
    let 结果 = [...this.事件历史];

    if (过滤条件.事件名) {
      结果 = 结果.filter(e => e.名称 === 过滤条件.事件名);
    }

    if (过滤条件.开始时间) {
      结果 = 结果.filter(e => e.时间戳 >= 过滤条件.开始时间);
    }

    if (过滤条件.结束时间) {
      结果 = 结果.filter(e => e.时间戳 <= 过滤条件.结束时间);
    }

    if (过滤条件.数量) {
      结果 = 结果.slice(-过滤条件.数量);
    }

    return 结果;
  }

  清空事件历史() {
    this.事件历史 = [];
  }

  // ─── 查询方法 ───

  获取订阅者数量(事件名) {
    return this.订阅者映射.get(事件名)?.length ?? 0;
  }

  获取所有事件名() {
    return Array.from(this.订阅者映射.keys());
  }

  是否有订阅者(事件名) {
    return this.获取订阅者数量(事件名) > 0;
  }

  // ─── 统计与调试 ───

  获取统计信息() {
    return {
      ...this.统计,
      事件类型数: this.订阅者映射.size,
      历史记录数: this.事件历史.length,
    };
  }

  重置统计() {
    this.统计 = {
      发布次数: 0,
      订阅次数: 0,
      处理次数: 0,
    };
  }

  设置调试模式(启用) {
    this.调试模式 = 启用;
  }

  // ─── 批量操作 ───

  批量发布(事件列表) {
    /**
     * 批量发布事件
     * @param 事件列表 - [{ 事件名, 数据 }, ...]
     * @returns 事件对象数组
     */
    return 事件列表.map(({ 事件名, 数据 }) => this.发布(事件名, 数据));
  }

  批量订阅(订阅配置) {
    /**
     * 批量订阅事件
     * @param 订阅配置 - { 事件名: 处理器 } 或 [{ 事件名, 处理器, 选项 }, ...]
     * @returns 取消订阅函数数组
     */
    if (Array.isArray(订阅配置)) {
      return 订阅配置.map(({ 事件名, 处理器, 选项 }) => this.订阅(事件名, 处理器, 选项 ?? {}));
    } else {
      return Object.entries(订阅配置).map(([事件名, 处理器]) => this.订阅(事件名, 处理器));
    }
  }

  // ─── 命名空间支持 ───

  创建命名空间(前缀) {
    /**
     * 创建带命名空间的事件总线代理
     * @param 前缀 - 事件名前缀
     * @returns 代理对象
     */
    const 总线 = this;

    return {
      订阅(事件名, 处理器, 选项) {
        return 总线.订阅(`${前缀}:${事件名}`, 处理器, 选项);
      },
      发布(事件名, 数据) {
        return 总线.发布(`${前缀}:${事件名}`, 数据);
      },
      取消订阅(事件名, 处理器) {
        return 总线.取消订阅(`${前缀}:${事件名}`, 处理器);
      },
    };
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 事件总线 };
export default 事件总线;
```


src\systems\formula.js
```js
// ═══════════════════════════════════════════════════════════════
// systems/formula.js
// 公式引擎 - 集中管理所有游戏公式
// ═══════════════════════════════════════════════════════════════

/**
 * 公式引擎
 * 集中管理所有游戏计算公式，支持动态注册和覆盖
 */
class 公式引擎 {
  constructor() {
    // 公式映射: 公式名 -> 计算函数
    this.公式映射 = new Map();

    // 公式元数据
    this.公式元数据 = new Map();

    // 常量表
    this.常量表 = new Map();

    // 公式分类索引
    this.分类索引 = new Map();

    // 计算缓存
    this.缓存 = new Map();
    this.启用缓存 = false;
  }

  // ─── 公式注册 ───

  注册公式(公式名, 计算函数, 元数据 = {}) {
    /**
     * 注册公式
     * @param 公式名 - 公式唯一标识
     * @param 计算函数 - (参数对象, 常量表) => 计算结果
     * @param 元数据 - { 描述, 参数说明, 分类 }
     */
    this.公式映射.set(公式名, 计算函数);

    this.公式元数据.set(公式名, {
      描述: 元数据.描述 ?? '',
      参数说明: 元数据.参数说明 ?? {},
      分类: 元数据.分类 ?? '通用',
      版本: 元数据.版本 ?? '1.0',
      公式文本: 元数据.公式文本 ?? null,
      注册时间: Date.now(),
    });

    // 更新分类索引
    const 分类 = 元数据.分类 ?? '通用';
    if (!this.分类索引.has(分类)) {
      this.分类索引.set(分类, new Set());
    }
    this.分类索引.get(分类).add(公式名);
  }

  批量注册(公式配置对象) {
    /**
     * 批量注册公式
     * @param 公式配置对象 - { 公式名: 计算函数 } 或 { 公式名: { 函数, 元数据 } }
     */
    Object.entries(公式配置对象).forEach(([名称, 配置]) => {
      if (typeof 配置 === 'function') {
        this.注册公式(名称, 配置);
      } else {
        this.注册公式(名称, 配置.函数 ?? 配置.fn, 配置.元数据 ?? 配置);
      }
    });
  }

  // ─── 公式计算 ───

  计算(公式名, 参数 = {}) {
    /**
     * 执行公式计算
     * @param 公式名 - 公式标识
     * @param 参数 - 计算参数对象
     * @returns 计算结果
     */
    const 计算函数 = this.公式映射.get(公式名);

    if (!计算函数) {
      throw new Error(`未注册的公式: ${公式名}`);
    }

    // 检查缓存
    if (this.启用缓存) {
      const 缓存键 = this.生成缓存键(公式名, 参数);
      if (this.缓存.has(缓存键)) {
        return this.缓存.get(缓存键);
      }
    }

    // 构建常量对象供公式访问
    const 常量对象 = Object.fromEntries(this.常量表);

    // 执行计算，传入参数和常量表
    try {
      const 结果 = 计算函数(参数, 常量对象);

      // 写入缓存
      if (this.启用缓存) {
        const 缓存键 = this.生成缓存键(公式名, 参数);
        this.缓存.set(缓存键, 结果);
      }

      return 结果;
    } catch (错误) {
      console.error(`公式计算错误 [${公式名}]:`, 错误);
      throw 错误;
    }
  }

  安全计算(公式名, 参数 = {}, 默认值 = null) {
    /**
     * 安全计算（出错时返回默认值）
     */
    try {
      return this.计算(公式名, 参数);
    } catch {
      return 默认值;
    }
  }

  批量计算(计算列表) {
    /**
     * 批量计算多个公式
     * @param 计算列表 - [{ 公式名, 参数 }, ...]
     * @returns 结果数组
     */
    return 计算列表.map(({ 公式名, 参数 }) => ({
      公式名,
      结果: this.安全计算(公式名, 参数),
    }));
  }

  // ─── 常量管理 ───

  设置常量(常量名, 值) {
    this.常量表.set(常量名, 值);
  }

  批量设置常量(常量对象) {
    Object.entries(常量对象).forEach(([名称, 值]) => {
      this.常量表.set(名称, 值);
    });
  }

  获取常量(常量名, 默认值 = undefined) {
    return this.常量表.has(常量名) ? this.常量表.get(常量名) : 默认值;
  }

  获取所有常量() {
    return Object.fromEntries(this.常量表);
  }

  // ─── 查询方法 ───

  是否已注册(公式名) {
    return this.公式映射.has(公式名);
  }

  获取公式元数据(公式名) {
    return this.公式元数据.get(公式名);
  }

  获取分类公式列表(分类) {
    const 公式名集合 = this.分类索引.get(分类);
    if (!公式名集合) return [];

    return Array.from(公式名集合).map(名称 => ({
      名称,
      ...this.公式元数据.get(名称),
    }));
  }

  获取所有分类() {
    return Array.from(this.分类索引.keys());
  }

  获取所有公式() {
    return Array.from(this.公式映射.keys()).map(名称 => ({
      名称,
      ...this.公式元数据.get(名称),
    }));
  }

  // ─── 缓存管理 ───

  生成缓存键(公式名, 参数) {
    const 排序参数 = Object.keys(参数)
      .sort()
      .reduce((obj, key) => {
        obj[key] = 参数[key];
        return obj;
      }, {});
    return `${公式名}:${JSON.stringify(排序参数)}`;
  }

  设置缓存启用(启用) {
    this.启用缓存 = 启用;
    if (!启用) {
      this.清空缓存();
    }
  }

  清空缓存() {
    this.缓存.clear();
  }

  // ─── 公式组合 ───

  创建组合公式(公式名, 子公式列表, 组合函数) {
    /**
     * 创建组合公式（由多个子公式组合而成）
     * @param 公式名 - 新公式名称
     * @param 子公式列表 - 子公式名称列表
     * @param 组合函数 - (子结果数组) => 最终结果
     */
    const 引擎 = this;

    this.注册公式(
      公式名,
      (参数, 常量) => {
        const 子结果 = 子公式列表.map(子公式名 => 引擎.计算(子公式名, 参数));
        return 组合函数(子结果, 参数, 常量);
      },
      {
        描述: `组合公式: ${子公式列表.join(' + ')}`,
        分类: '组合',
      },
    );
  }

  // ─── 公式克隆与变体 ───

  创建变体公式(原公式名, 新公式名, 参数转换器) {
    /**
     * 基于现有公式创建变体
     * @param 参数转换器 - (原参数) => 转换后参数
     */
    const 原公式 = this.公式映射.get(原公式名);
    if (!原公式) {
      throw new Error(`原公式不存在: ${原公式名}`);
    }

    this.注册公式(
      新公式名,
      (参数, 常量) => {
        const 转换后参数 = 参数转换器(参数);
        return 原公式(转换后参数, 常量);
      },
      {
        描述: `${原公式名} 的变体`,
        分类: '变体',
      },
    );
  }

  // ─── 工具方法 ───

  静态方法 = {
    限制范围: (值, 最小, 最大) => Math.max(最小, Math.min(最大, 值)),
    百分比: (值, 总量) => (总量 > 0 ? (值 / 总量) * 100 : 0),
    随机范围: (最小, 最大) => Math.floor(Math.random() * (最大 - 最小 + 1)) + 最小,
    随机浮点: (最小, 最大) => Math.random() * (最大 - 最小) + 最小,
    四舍五入: (值, 小数位 = 0) => {
      const 倍数 = Math.pow(10, 小数位);
      return Math.round(值 * 倍数) / 倍数;
    },
    向下取整: Math.floor,
    向上取整: Math.ceil,
    绝对值: Math.abs,
    幂: Math.pow,
    开方: Math.sqrt,
    对数: Math.log,
  };

  获取工具方法() {
    return this.静态方法;
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 公式引擎 };
export default 公式引擎;
```


src\systems\intel.js
```js
// ═══════════════════════════════════════════════════════════════
// systems/intel.js
// 情报系统 - 管理目标情报、侦察进度和战力估算
// ═══════════════════════════════════════════════════════════════

class 情报系统 {
  constructor(事件总线, 公式引擎) {
    this.事件总线 = 事件总线;
    this.公式引擎 = 公式引擎;

    this.目标情报 = new Map();
    this.侦察历史 = [];
    this.历史上限 = 200;
  }

  // ─── 配置获取 ───

  获取配置(配置名, 默认值) {
    return this.公式引擎?.获取常量(配置名, 默认值) ?? 默认值;
  }

  // ─── 情报衰减配置 ───

  获取衰减配置() {
    return {
      启用: true,
      每周衰减: this.获取配置('情报衰减值', 5),
      最低保留: this.获取配置('情报最低保留', 10),
    };
  }

  // ─── 目标管理 ───

  创建目标(目标ID, 初始数据 = {}) {
    const 情报数据 = {
      目标ID,
      名称: 初始数据.名称 ?? '未知目标',
      情报进度: 初始数据.情报进度 ?? 0,
      已锁定目标: new Set(),
      高价值目标列表: 初始数据.高价值目标列表 ?? [],
      战力估值: null,
      实际战力: 初始数据.实际战力 ?? null,
      最后侦察周次: null,
      发现时间: Date.now(),
      侦察次数: 0,
      备注: 初始数据.备注 ?? '',
    };

    this.目标情报.set(目标ID, 情报数据);
    this.更新战力估值(目标ID);

    this.事件总线.发布('目标创建', { 目标ID, 情报数据 });

    return 情报数据;
  }

  移除目标(目标ID) {
    const 情报 = this.目标情报.get(目标ID);
    if (情报) {
      this.目标情报.delete(目标ID);
      this.事件总线.发布('目标移除', { 目标ID, 情报 });
      return true;
    }
    return false;
  }

  获取目标情报(目标ID) {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报) return null;

    return {
      ...情报,
      已锁定目标: Array.from(情报.已锁定目标),
    };
  }

  获取所有目标() {
    return Array.from(this.目标情报.entries()).map(([目标ID, 情报]) => ({
      目标ID,
      ...情报,
      已锁定目标: Array.from(情报.已锁定目标),
    }));
  }

  // ─── 情报进度 ───

  增加情报进度(目标ID, 增量, 来源 = '侦察') {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报) {
      return { 成功: false, 原因: '目标不存在' };
    }

    const 旧进度 = 情报.情报进度;
    const 情报满值 = this.获取配置('情报满值', 100);
    const 旧阶段 = this.获取情报阶段(旧进度);

    情报.情报进度 = Math.min(情报满值, 情报.情报进度 + 增量);
    情报.侦察次数++;
    情报.最后侦察周次 = this.获取当前周次();

    const 新阶段 = this.获取情报阶段(情报.情报进度);

    this.更新战力估值(目标ID);

    this.记录侦察历史({
      目标ID,
      类型: '情报增加',
      旧进度,
      新进度: 情报.情报进度,
      增量,
      来源,
    });

    this.事件总线.发布('情报更新', {
      目标ID,
      旧进度,
      新进度: 情报.情报进度,
      增量,
    });

    if (新阶段.等级 > 旧阶段.等级) {
      this.事件总线.发布('情报阶段提升', {
        目标ID,
        旧阶段,
        新阶段,
      });
    }

    return {
      成功: true,
      新进度: 情报.情报进度,
      阶段变化: 新阶段.等级 > 旧阶段.等级 ? { 旧阶段, 新阶段 } : null,
    };
  }

  设置情报进度(目标ID, 进度) {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报) return false;

    const 情报满值 = this.获取配置('情报满值', 100);
    情报.情报进度 = Math.max(0, Math.min(情报满值, 进度));
    this.更新战力估值(目标ID);
    return true;
  }

  获取情报阶段(进度) {
    return (
      this.公式引擎?.计算('情报阶段判定', { 情报进度: 进度 }) ?? {
        名称: '模糊',
        等级: 1,
        描述: '几乎一无所知',
      }
    );
  }

  // ─── 战力估值 ───

  更新战力估值(目标ID) {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报) return;

    const 估值 = this.公式引擎?.计算('战力估值偏差', { 情报进度: 情报.情报进度 }) ?? {
      下限系数: 0.2,
      上限系数: 5.0,
    };

    情报.战力估值 = 估值;
  }

  获取战力估值(目标ID) {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报 || !情报.实际战力) return null;

    const 实际战力 = 情报.实际战力;
    const 估值 = 情报.战力估值;

    return {
      估计最小: Math.floor(实际战力 * 估值.下限系数),
      估计最大: Math.ceil(实际战力 * 估值.上限系数),
      准确度: 情报.情报进度,
      显示文本: this.生成战力显示文本(情报),
    };
  }

  生成战力显示文本(情报) {
    if (!情报.实际战力) return '未知';

    const 进度 = 情报.情报进度;
    const 实际 = 情报.实际战力;
    const 详尽阈值 = this.获取配置('情报阶段_详尽阈值', 80);
    const 充分阈值 = this.获取配置('情报阶段_充分阈值', 50);
    const 初步阈值 = this.获取配置('情报阶段_初步阈值', 25);

    if (进度 >= 详尽阈值) {
      const 误差 = Math.floor(实际 * 0.1);
      return `约 ${实际 - 误差} ~ ${实际 + 误差}`;
    } else if (进度 >= 充分阈值) {
      const 下限 = Math.floor(实际 * 0.6);
      const 上限 = Math.ceil(实际 * 1.5);
      return `${下限} ~ ${上限}`;
    } else if (进度 >= 初步阈值) {
      const 下限 = Math.floor(实际 * 0.3);
      const 上限 = Math.ceil(实际 * 3);
      return `${下限} ~ ${上限}`;
    } else {
      return '情报不足，无法估算';
    }
  }

  // ─── 高价值目标锁定 ───

  添加高价值目标(目标ID, 高价值目标信息) {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报) return false;

    情报.高价值目标列表.push({
      ...高价值目标信息,
      添加时间: Date.now(),
    });

    return true;
  }

  尝试锁定目标(目标ID, 负责人系数) {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报) return [];

    const 锁定值 =
      this.公式引擎?.计算('锁定目标值', {
        负责人系数,
        情报进度: 情报.情报进度,
      }) ?? 0;

    const 锁定解析 = this.公式引擎?.计算('锁定目标解析', { 锁定值 }) ?? {
      必定锁定数: 0,
      额外锁定概率: 0,
    };

    const 新锁定 = [];
    const 可锁定目标 = 情报.高价值目标列表.filter(t => !情报.已锁定目标.has(t.ID));

    for (let i = 0; i < Math.min(锁定解析.必定锁定数, 可锁定目标.length); i++) {
      const 目标 = 可锁定目标[i];
      情报.已锁定目标.add(目标.ID);
      新锁定.push(目标);
    }

    if (可锁定目标.length > 锁定解析.必定锁定数 && Math.random() < 锁定解析.额外锁定概率) {
      const 目标 = 可锁定目标[锁定解析.必定锁定数];
      情报.已锁定目标.add(目标.ID);
      新锁定.push(目标);
    }

    if (新锁定.length > 0) {
      this.事件总线.发布('目标锁定', {
        目标ID,
        新锁定目标: 新锁定,
      });
    }

    return 新锁定;
  }

  获取已锁定目标(目标ID) {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报) return [];

    return 情报.高价值目标列表.filter(t => 情报.已锁定目标.has(t.ID));
  }

  获取未锁定目标(目标ID) {
    const 情报 = this.目标情报.get(目标ID);
    if (!情报) return [];

    return 情报.高价值目标列表.filter(t => !情报.已锁定目标.has(t.ID));
  }

  // ─── 周结算 ───

  周结算处理(当前周次) {
    const 衰减配置 = this.获取衰减配置();
    if (!衰减配置.启用) return [];

    const 衰减记录 = [];

    this.目标情报.forEach((情报, 目标ID) => {
      if (情报.最后侦察周次 && 情报.最后侦察周次 >= 当前周次 - 1) {
        return;
      }

      const 旧进度 = 情报.情报进度;

      const 新进度 =
        this.公式引擎?.计算('情报衰减', {
          当前进度: 情报.情报进度,
          上次侦察周次: 情报.最后侦察周次,
          当前周次,
        }) ?? Math.max(衰减配置.最低保留, 情报.情报进度 - 衰减配置.每周衰减);

      情报.情报进度 = 新进度;

      if (情报.情报进度 < 旧进度) {
        this.更新战力估值(目标ID);
        衰减记录.push({
          目标ID,
          旧进度,
          新进度: 情报.情报进度,
          衰减量: 旧进度 - 情报.情报进度,
        });
      }
    });

    return 衰减记录;
  }

  // ─── 历史记录 ───

  记录侦察历史(记录) {
    this.侦察历史.push({
      ...记录,
      时间戳: Date.now(),
    });

    while (this.侦察历史.length > this.历史上限) {
      this.侦察历史.shift();
    }
  }

  获取侦察历史(目标ID = null) {
    if (目标ID) {
      return this.侦察历史.filter(h => h.目标ID === 目标ID);
    }
    return [...this.侦察历史];
  }

  获取当前周次() {
    return this._当前周次 ?? 1;
  }

  设置当前周次(周次) {
    this._当前周次 = 周次;
  }

  序列化() {
    const 情报数据 = {};

    this.目标情报.forEach((情报, 目标ID) => {
      情报数据[目标ID] = {
        ...情报,
        已锁定目标: Array.from(情报.已锁定目标),
      };
    });

    return {
      目标情报: 情报数据,
      侦察历史: this.侦察历史.slice(-50),
    };
  }

  从序列化恢复(数据) {
    this.目标情报.clear();

    if (数据.目标情报) {
      Object.entries(数据.目标情报).forEach(([目标ID, 情报]) => {
        this.目标情报.set(目标ID, {
          ...情报,
          已锁定目标: new Set(情报.已锁定目标 ?? []),
        });
      });
    }

    this.侦察历史 = 数据.侦察历史 ?? [];
  }
}

export { 情报系统 };
export default 情报系统;
```


src\systems\market.js
```js
// ═══════════════════════════════════════════════════════════════
// systems/market.js
// 黑市系统 - 管理商品交易和刷新
// ═══════════════════════════════════════════════════════════════

/**
 * 黑市系统
 * 管理黑市商品的展示、购买和刷新
 */
class 黑市系统 {
  constructor(事件总线, 商品注册表, 资源系统) {
    this.事件总线 = 事件总线;
    this.商品注册表 = 商品注册表;
    this.资源系统 = 资源系统;

    // 当前商品库存
    this.当前商品库存 = new Map();

    // 本周购买记录
    this.本周购买记录 = new Map();

    // 交易历史
    this.交易历史 = [];
    this.历史上限 = 100;

    // 当前周次
    this._当前周次 = 1;

    // 交易货币
    this.交易货币 = '母乳';

    // 折扣修正器
    this.折扣修正器 = [];

    // 购买条件检查器
    this.购买条件检查器 = [];
  }

  // ─── 配置方法 ───

  设置交易货币(货币名) {
    this.交易货币 = 货币名;
  }

  设置资源系统(系统) {
    this.资源系统 = 系统;
  }

  // ─── 商品刷新 ───

  刷新商品(周次, 上下文 = {}) {
    /**
     * 刷新黑市商品
     * @param 周次 - 当前周次
     * @param 上下文 - 额外上下文（如游戏状态）
     */
    this._当前周次 = 周次;
    this.本周购买记录.clear();
    this.当前商品库存.clear();

    const 刷新结果 = {
      固定商品: [],
      随机商品: [],
    };

    // 获取所有分类
    const 分类列表 = this.商品注册表.获取所有分类();

    for (const 分类 of 分类列表) {
      const 分类配置 = this.商品注册表.获取分类配置(分类.名称);

      if (分类配置?.随机刷新) {
        // 随机刷新商品
        const 随机商品 = this.商品注册表.执行分类刷新(
          分类.名称,
          周次,
          上下文
        );

        随机商品.forEach(商品 => {
          this.添加商品到库存(商品);
          刷新结果.随机商品.push(商品.名称);
        });
      } else {
        // 固定商品
        const 固定商品 = this.商品注册表.获取分类商品列表(分类.名称);

        固定商品.forEach(商品 => {
          this.添加商品到库存(商品);
          刷新结果.固定商品.push(商品.名称);
        });
      }
    }

    // 发布刷新事件
    this.事件总线.发布('黑市刷新', {
      周次,
      可用商品数: this.当前商品库存.size,
      刷新结果,
    });

    return 刷新结果;
  }

  添加商品到库存(商品) {
    this.当前商品库存.set(商品.名称, {
      ...商品,
      剩余限购: 商品.每周限购 ?? Infinity,
      原价: 商品.价格,
      现价: this.计算商品现价(商品),
    });
  }

  计算商品现价(商品) {
    let 价格 = 商品.价格;

    // 应用折扣修正器
    for (const 修正器 of this.折扣修正器) {
      价格 = 修正器(价格, 商品);
    }

    return Math.max(1, Math.floor(价格));
  }

  // ─── 商品查询 ───

  获取可用商品列表() {
    /**
     * 获取当前可购买的商品列表
     */
    return Array.from(this.当前商品库存.entries())
      .filter(([_, 数据]) => 数据.剩余限购 > 0)
      .map(([名称, 数据]) => ({
        名称,
        ...数据,
        本周已购: this.本周购买记录.get(名称) ?? 0,
      }));
  }

  获取商品详情(商品名) {
    const 商品 = this.当前商品库存.get(商品名);
    if (!商品) return null;

    return {
      ...商品,
      本周已购: this.本周购买记录.get(商品名) ?? 0,
      可购买: 商品.剩余限购 > 0,
    };
  }

  获取分类商品(分类名) {
    return this.获取可用商品列表().filter(商品 => 商品.分类 === 分类名);
  }

  // ─── 购买验证 ───

  验证购买(商品名, 数量 = 1) {
    /**
     * 验证是否可以购买
     */
    const 商品 = this.当前商品库存.get(商品名);

    if (!商品) {
      return { 可购买: false, 原因: '商品不存在或已下架' };
    }

    if (商品.剩余限购 < 数量) {
      return {
        可购买: false,
        原因: '超出限购数量',
        剩余限购: 商品.剩余限购,
        请求数量: 数量,
      };
    }

    const 总价 = 商品.现价 * 数量;
    const 当前货币 = this.资源系统?.获取资源(this.交易货币) ?? 0;

    if (当前货币 < 总价) {
      return {
        可购买: false,
        原因: `${this.交易货币}不足`,
        当前: 当前货币,
        需要: 总价,
      };
    }

    // 执行自定义购买条件检查
    for (const 检查器 of this.购买条件检查器) {
      const 结果 = 检查器(商品, 数量);
      if (!结果.通过) {
        return { 可购买: false, 原因: 结果.原因 };
      }
    }

    // 检查商品自身的购买条件
    if (商品.购买条件 && !商品.购买条件({ 商品, 数量 })) {
      return { 可购买: false, 原因: '不满足购买条件' };
    }

    return {
      可购买: true,
      总价,
      单价: 商品.现价,
    };
  }

  // ─── 购买执行 ───

  购买商品(商品名, 数量 = 1, 选项 = {}) {
    /**
     * 购买商品
     * @returns { 成功, 效果?, 原因? }
     */
    // 验证
    const 验证结果 = this.验证购买(商品名, 数量);
    if (!验证结果.可购买) {
      return { 成功: false, ...验证结果 };
    }

    const 商品 = this.当前商品库存.get(商品名);
    const 总价 = 验证结果.总价;

    // 扣除货币
    const 扣除结果 = this.资源系统?.消耗资源(
      this.交易货币,
      总价,
      `黑市购买:${商品名}`
    );

    if (!扣除结果?.成功) {
      return { 成功: false, 原因: '货币扣除失败' };
    }

    // 减少库存
    商品.剩余限购 -= 数量;

    // 记录购买
    const 已购数量 = this.本周购买记录.get(商品名) ?? 0;
    this.本周购买记录.set(商品名, 已购数量 + 数量);

    // 记录交易历史
    this.记录交易历史({
      类型: '购买',
      商品名,
      数量,
      单价: 商品.现价,
      总价,
      效果: 商品.效果,
      周次: this._当前周次,
    });

    // 发布购买事件
    this.事件总线.发布('商品购买', {
      商品名,
      数量,
      总价,
      效果: 商品.效果,
      剩余限购: 商品.剩余限购,
    });

    return {
      成功: true,
      商品名,
      数量,
      总价,
      效果: 商品.效果,
      剩余货币: this.资源系统?.获取资源(this.交易货币),
    };
  }

  批量购买(购买列表) {
    /**
     * 批量购买商品
     * @param 购买列表 - [{ 商品名, 数量 }, ...]
     */
    const 结果列表 = [];
    let 总花费 = 0;

    for (const { 商品名, 数量 } of 购买列表) {
      const 结果 = this.购买商品(商品名, 数量 ?? 1);
      结果列表.push({ 商品名, ...结果 });

      if (结果.成功) {
        总花费 += 结果.总价;
      }
    }

    return {
      结果列表,
      总花费,
      成功数: 结果列表.filter(r => r.成功).length,
    };
  }

  // ─── 效果应用 ───

  应用商品效果(效果, 目标上下文 = {}) {
    /**
     * 应用商品效果（由外部调用者根据效果类型处理）
     * 这里只返回效果信息，实际处理由游戏控制器完成
     */
    return {
      效果类型: 效果.类型,
      效果参数: 效果,
      目标上下文,
    };
  }

  // ─── 折扣管理 ───

  添加折扣修正器(修正函数, 描述 = '') {
    /**
     * 添加价格折扣修正器
     * @param 修正函数 - (原价, 商品) => 修正后价格
     * @returns 移除函数
     */
    const 修正器 = { 函数: 修正函数, 描述 };
    this.折扣修正器.push(修正器.函数);

    // 重新计算所有商品价格
    this.重新计算价格();

    return () => {
      const 索引 = this.折扣修正器.indexOf(修正器.函数);
      if (索引 !== -1) {
        this.折扣修正器.splice(索引, 1);
        this.重新计算价格();
      }
    };
  }

  重新计算价格() {
    this.当前商品库存.forEach((商品, 名称) => {
      商品.现价 = this.计算商品现价(商品);
    });
  }

  // ─── 购买条件检查器 ───

  添加购买条件检查器(检查函数) {
    /**
     * 添加自定义购买条件检查器
     * @param 检查函数 - (商品, 数量) => { 通过: boolean, 原因?: string }
     */
    this.购买条件检查器.push(检查函数);

    return () => {
      const 索引 = this.购买条件检查器.indexOf(检查函数);
      if (索引 !== -1) {
        this.购买条件检查器.splice(索引, 1);
      }
    };
  }

  // ─── 特殊商品操作 ───

  添加临时商品(商品配置) {
    /**
     * 添加临时商品（如事件奖励商品）
     */
    this.添加商品到库存({
      临时: true,
      ...商品配置,
    });

    this.事件总线.发布('临时商品添加', { 商品名: 商品配置.名称 });
  }

  移除商品(商品名) {
    const 商品 = this.当前商品库存.get(商品名);
    if (商品) {
      this.当前商品库存.delete(商品名);
      return true;
    }
    return false;
  }

  // ─── 历史记录 ───

  记录交易历史(记录) {
    this.交易历史.push({
      ...记录,
      时间戳: Date.now(),
    });

    while (this.交易历史.length > this.历史上限) {
      this.交易历史.shift();
    }
  }

  获取交易历史(过滤条件 = {}) {
    let 结果 = [...this.交易历史];

    if (过滤条件.商品名) {
      结果 = 结果.filter(h => h.商品名 === 过滤条件.商品名);
    }

    if (过滤条件.周次) {
      结果 = 结果.filter(h => h.周次 === 过滤条件.周次);
    }

    if (过滤条件.数量) {
      结果 = 结果.slice(-过滤条件.数量);
    }

    return 结果;
  }

  获取本周交易统计() {
    const 本周记录 = this.交易历史.filter(h => h.周次 === this._当前周次);

    return {
      交易次数: 本周记录.length,
      总花费: 本周记录.reduce((sum, h) => sum + h.总价, 0),
      购买商品: Object.fromEntries(this.本周购买记录),
    };
  }

  // ─── 状态查询 ───

  获取货币状态() {
    return {
      货币类型: this.交易货币,
      当前数量: this.资源系统?.获取资源(this.交易货币) ?? 0,
    };
  }

  获取黑市状态() {
    return {
      当前周次: this._当前周次,
      商品数量: this.当前商品库存.size,
      可购买商品数: this.获取可用商品列表().length,
      本周交易: this.获取本周交易统计(),
    };
  }

  // ─── 周结算 ───

  周结算处理(新周次) {
    // 周结算时自动刷新（如果需要的话）
    // 通常由游戏控制器在新周开始时调用刷新商品
  }

  // ─── 序列化 ───

  序列化() {
    // 将商品库存转换为可序列化格式
    const 商品库存数据 = {};
    this.当前商品库存.forEach((商品, 名称) => {
      商品库存数据[名称] = {
        ...商品,
        // 移除不可序列化的函数
        购买条件: undefined,
      };
    });

    return {
      当前商品库存: 商品库存数据,
      本周购买记录: Object.fromEntries(this.本周购买记录),
      当前周次: this._当前周次,
      交易历史: this.交易历史.slice(-30),
    };
  }

  从序列化恢复(数据) {
    this._当前周次 = 数据.当前周次 ?? 1;

    if (数据.本周购买记录) {
      this.本周购买记录 = new Map(Object.entries(数据.本周购买记录));
    }

    if (数据.当前商品库存) {
      this.当前商品库存.clear();
      Object.entries(数据.当前商品库存).forEach(([名称, 商品]) => {
        const 注册定义 = this.商品注册表.获取商品定义(名称);
        this.当前商品库存.set(名称, {
          ...商品,
          购买条件: 注册定义?.购买条件,
        });
      });
    }
    this.交易历史 = 数据.交易历史 ?? [];
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 黑市系统 };
export default 黑市系统;
```


src\systems\resource.js
```js
// ═══════════════════════════════════════════════════════════════
// systems/resource.js
// 资源系统 - 管理游戏资源的产出、消耗和存储
// ═══════════════════════════════════════════════════════════════

/**
 * 资源系统
 * 管理游戏中的各类资源
 */
class 资源系统 {
  constructor(事件总线) {
    this.事件总线 = 事件总线;

    // 资源存储
    this.资源映射 = new Map();

    // 资源配置
    this.资源配置 = new Map();

    // 产出规则: 资源名 -> [规则函数]
    this.产出规则 = new Map();

    // 消耗规则: 资源名 -> [规则函数]
    this.消耗规则 = new Map();

    // 资源变更历史
    this.变更历史 = [];
    this.历史上限 = 500;
  }

  // ─── 资源类型注册 ───

  注册资源类型(资源名, 配置 = {}) {
    /**
     * 注册资源类型
     * @param 配置 - { 初始值, 最小值, 最大值, 描述, 图标 }
     */
    this.资源配置.set(资源名, {
      最小值: 配置.最小值 ?? 0,
      最大值: 配置.最大值 ?? Infinity,
      描述: 配置.描述 ?? '',
      图标: 配置.图标 ?? null,
      可负数: 配置.可负数 ?? false,
    });

    this.资源映射.set(资源名, 配置.初始值 ?? 0);
  }

  批量注册资源类型(配置对象) {
    Object.entries(配置对象).forEach(([资源名, 配置]) => {
      this.注册资源类型(资源名, 配置);
    });
  }

  // ─── 资源操作 ───

  获取资源(资源名) {
    return this.资源映射.get(资源名) ?? 0;
  }

  设置资源(资源名, 数值) {
    const 配置 = this.资源配置.get(资源名);
    let 最终值 = 数值;

    if (配置) {
      最终值 = Math.min(配置.最大值, Math.max(配置.最小值, 数值));
    }

    const 旧值 = this.获取资源(资源名);
    this.资源映射.set(资源名, 最终值);

    this.记录变更(资源名, 旧值, 最终值, '设置');

    return 最终值;
  }

  修改资源(资源名, 增量, 来源 = '未知') {
    /**
     * 修改资源数量
     * @returns { 成功: boolean, 新值?: number, 实际变化?: number }
     */
    const 当前值 = this.获取资源(资源名);
    const 配置 = this.资源配置.get(资源名);

    let 新值 = 当前值 + 增量;

    // 应用范围限制
    if (配置) {
      if (!配置.可负数 && 新值 < 配置.最小值) {
        // 不允许负数时，检查是否足够消耗
        if (增量 < 0) {
          return {
            成功: false,
            原因: '资源不足',
            当前: 当前值,
            需要: Math.abs(增量),
          };
        }
      }
      新值 = Math.min(配置.最大值, Math.max(配置.最小值, 新值));
    }

    const 实际变化 = 新值 - 当前值;
    this.资源映射.set(资源名, 新值);

    // 记录变更
    this.记录变更(资源名, 当前值, 新值, 来源);

    // 发布事件
    this.事件总线.发布('资源变更', {
      资源名,
      旧值: 当前值,
      新值,
      增量: 实际变化,
      来源,
    });

    return {
      成功: true,
      新值,
      实际变化,
    };
  }

  消耗资源(资源名, 数量, 来源 = '消耗') {
    /**
     * 消耗资源（更语义化的方法）
     */
    return this.修改资源(资源名, -数量, 来源);
  }

  增加资源(资源名, 数量, 来源 = '获得') {
    /**
     * 增加资源（更语义化的方法）
     */
    return this.修改资源(资源名, 数量, 来源);
  }

  // ─── 批量操作 ───

  批量修改(修改列表) {
    /**
     * 批量修改资源
     * @param 修改列表 - [{ 资源名, 增量, 来源? }, ...]
     * @returns 结果列表
     */
    return 修改列表.map(({ 资源名, 增量, 来源 }) => this.修改资源(资源名, 增量, 来源));
  }

  检查资源充足(需求列表) {
    /**
     * 检查资源是否充足
     * @param 需求列表 - { 资源名: 需要数量 } 或 [{ 资源名, 数量 }]
     * @returns { 充足: boolean, 缺少?: { 资源名, 缺少数量 }[] }
     */
    const 缺少列表 = [];

    if (Array.isArray(需求列表)) {
      需求列表.forEach(({ 资源名, 数量 }) => {
        const 当前 = this.获取资源(资源名);
        if (当前 < 数量) {
          缺少列表.push({ 资源名, 缺少数量: 数量 - 当前 });
        }
      });
    } else {
      Object.entries(需求列表).forEach(([资源名, 数量]) => {
        const 当前 = this.获取资源(资源名);
        if (当前 < 数量) {
          缺少列表.push({ 资源名, 缺少数量: 数量 - 当前 });
        }
      });
    }

    return {
      充足: 缺少列表.length === 0,
      缺少: 缺少列表.length > 0 ? 缺少列表 : undefined,
    };
  }

  // ─── 产出消耗规则 ───

  注册产出规则(资源名, 规则函数, 描述 = '') {
    /**
     * 注册周结算产出规则
     * @param 规则函数 - (游戏状态) => 产出数量
     */
    if (!this.产出规则.has(资源名)) {
      this.产出规则.set(资源名, []);
    }
    this.产出规则.get(资源名).push({ 规则函数, 描述 });
  }

  注册消耗规则(资源名, 规则函数, 描述 = '') {
    /**
     * 注册周结算消耗规则
     * @param 规则函数 - (游戏状态) => 消耗数量
     */
    if (!this.消耗规则.has(资源名)) {
      this.消耗规则.set(资源名, []);
    }
    this.消耗规则.get(资源名).push({ 规则函数, 描述 });
  }

  // ─── 周结算 ───

  周结算处理(游戏状态) {
    /**
     * 执行周结算资源变化
     * @returns 结算明细
     */
    const 结算明细 = {
      产出: [],
      消耗: [],
      净变化: {},
    };

    // 处理产出
    this.产出规则.forEach((规则列表, 资源名) => {
      let 总产出 = 0;

      规则列表.forEach(({ 规则函数, 描述 }) => {
        try {
          const 产出量 = 规则函数(游戏状态);
          if (产出量 > 0) {
            总产出 += 产出量;
            结算明细.产出.push({
              资源名,
              数量: 产出量,
              来源: 描述,
            });
          }
        } catch (错误) {
          console.error(`产出规则错误 [${资源名}]:`, 错误);
        }
      });

      if (总产出 > 0) {
        this.修改资源(资源名, 总产出, '周结算产出');
        结算明细.净变化[资源名] = (结算明细.净变化[资源名] ?? 0) + 总产出;
      }
    });

    // 处理消耗
    this.消耗规则.forEach((规则列表, 资源名) => {
      let 总消耗 = 0;

      规则列表.forEach(({ 规则函数, 描述 }) => {
        try {
          const 消耗量 = 规则函数(游戏状态);
          if (消耗量 > 0) {
            总消耗 += 消耗量;
            结算明细.消耗.push({
              资源名,
              数量: 消耗量,
              来源: 描述,
            });
          }
        } catch (错误) {
          console.error(`消耗规则错误 [${资源名}]:`, 错误);
        }
      });

      if (总消耗 > 0) {
        this.修改资源(资源名, -总消耗, '周结算消耗');
        结算明细.净变化[资源名] = (结算明细.净变化[资源名] ?? 0) - 总消耗;
      }
    });

    return 结算明细;
  }

  // ─── 历史记录 ───

  记录变更(资源名, 旧值, 新值, 来源) {
    this.变更历史.push({
      资源名,
      旧值,
      新值,
      变化量: 新值 - 旧值,
      来源,
      时间戳: Date.now(),
    });

    while (this.变更历史.length > this.历史上限) {
      this.变更历史.shift();
    }
  }

  获取变更历史(过滤条件 = {}) {
    let 结果 = [...this.变更历史];

    if (过滤条件.资源名) {
      结果 = 结果.filter(h => h.资源名 === 过滤条件.资源名);
    }

    if (过滤条件.数量) {
      结果 = 结果.slice(-过滤条件.数量);
    }

    return 结果;
  }

  // ─── 查询方法 ───

  获取所有资源() {
    const 结果 = {};
    this.资源映射.forEach((数量, 资源名) => {
      结果[资源名] = {
        数量,
        ...this.资源配置.get(资源名),
      };
    });
    return 结果;
  }

  获取资源列表() {
    return Array.from(this.资源映射.keys());
  }

  // ─── 序列化 ───

  序列化() {
    return {
      资源: Object.fromEntries(this.资源映射),
      变更历史: this.变更历史.slice(-100), // 只保留最近100条
    };
  }

  从序列化恢复(数据) {
    if (数据.资源) {
      Object.entries(数据.资源).forEach(([资源名, 数量]) => {
        this.资源映射.set(资源名, 数量);
      });
    }
    this.变更历史 = 数据.变更历史 ?? [];
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 资源系统 };
export default 资源系统;
```


src\systems\spell.js
```js
// ═══════════════════════════════════════════════════════════════
// systems/spell.js
// 法术系统 - 管理领主法术的施放和效果
// ═══════════════════════════════════════════════════════════════

/**
 * 法术系统
 * 管理领主的魔力和法术施放
 */
class 法术系统 {
  constructor(事件总线, 法术注册表, 领主) {
    this.事件总线 = 事件总线;
    this.法术注册表 = 法术注册表;
    this.领主 = 领主;

    // 法术冷却记录
    this.法术冷却 = new Map();

    // 当前周次（用于冷却计算）
    this._当前周次 = 1;

    // 施放历史
    this.施放历史 = [];
    this.历史上限 = 100;

    // 法术修正器（临时增强等）
    this.效果修正器 = new Map();
  }

  // ─── 领主管理 ───

  设置领主(领主) {
    this.领主 = 领主;
  }

  获取领主() {
    return this.领主;
  }

  设置当前周次(周次) {
    this._当前周次 = 周次;
  }

  // ─── 法术验证 ───

  验证施法(法术名, 目标 = null) {
    /**
     * 验证法术是否可以施放
     */
    if (!this.领主) {
      return { 可施放: false, 原因: '领主未设置' };
    }

    const 定义 = this.法术注册表.获取法术定义(法术名);
    if (!定义) {
      return { 可施放: false, 原因: '未知法术' };
    }

    // 检查魔力
    const 当前魔力 = this.领主.获取属性('魔力');
    if (当前魔力 < 定义.魔力消耗) {
      return {
        可施放: false,
        原因: '魔力不足',
        当前魔力,
        需要魔力: 定义.魔力消耗,
      };
    }

    // 检查冷却
    if (定义.冷却周期 > 0) {
      const 上次施放周次 = this.法术冷却.get(法术名);
      if (上次施放周次) {
        const 剩余冷却 = 定义.冷却周期 - (this._当前周次 - 上次施放周次);
        if (剩余冷却 > 0) {
          return {
            可施放: false,
            原因: '法术冷却中',
            剩余冷却周次: 剩余冷却,
          };
        }
      }
    }

    // 检查目标类型
    if (定义.目标类型 !== '无') {
      if (!目标) {
        return { 可施放: false, 原因: '需要指定目标' };
      }
      if (定义.目标类型 !== 目标.实体类型) {
        return {
          可施放: false,
          原因: '目标类型不匹配',
          需要类型: 定义.目标类型,
          实际类型: 目标.实体类型,
        };
      }
    }

    // 检查施放条件
    if (!定义.施放条件({ 领主: this.领主, 目标 })) {
      return { 可施放: false, 原因: '施放条件不满足' };
    }

    return { 可施放: true, 魔力消耗: 定义.魔力消耗 };
  }

  // ─── 法术施放 ───

  施放法术(法术名, 目标 = null, 选项 = {}) {
    /**
     * 施放法术
     * @returns { 成功, 效果结果?, 原因? }
     */
    // 验证
    const 验证结果 = this.验证施法(法术名, 目标);
    if (!验证结果.可施放) {
      return { 成功: false, ...验证结果 };
    }

    const 定义 = this.法术注册表.获取法术定义(法术名);

    // 消耗魔力
    const 消耗结果 = this.领主.消耗魔力(定义.魔力消耗);
    if (!消耗结果.成功) {
      return { 成功: false, 原因: '魔力消耗失败' };
    }

    // 记录冷却
    if (定义.冷却周期 > 0) {
      this.法术冷却.set(法术名, this._当前周次);
    }

    // 构建效果上下文
    const 上下文 = {
      领主: this.领主,
      效果参数: { ...定义.效果参数 },
      选项,
    };

    // 应用效果修正器
    const 修正器 = this.效果修正器.get(法术名);
    if (修正器) {
      上下文.效果参数 = 修正器(上下文.效果参数);
    }

    // 执行效果
    let 效果结果;
    try {
      效果结果 = this.法术注册表.执行法术效果(法术名, 目标, 上下文);
    } catch (错误) {
      console.error(`法术效果执行错误 [${法术名}]:`, 错误);
      效果结果 = { 成功: false, 错误: 错误.message };
    }

    // 记录历史
    this.记录施放历史({
      法术名,
      目标ID: 目标?.实体ID,
      目标类型: 目标?.实体类型,
      魔力消耗: 定义.魔力消耗,
      效果结果,
      周次: this._当前周次,
    });

    // 发布事件
    this.事件总线.发布('法术施放', {
      法术名,
      目标ID: 目标?.实体ID,
      魔力消耗: 定义.魔力消耗,
      效果结果,
    });

    return {
      成功: true,
      法术名,
      魔力消耗: 定义.魔力消耗,
      剩余魔力: this.领主.获取属性('魔力'),
      效果结果,
    };
  }

  // ─── 特殊法术：献祭母畜 ───

  献祭母畜(母畜) {
    /**
     * 将完全淫堕的母畜献祭给领主，获得魔力
     * @returns { 成功, 魔力获得?, 需移除母畜? }
     */
    if (!this.领主) {
      return { 成功: false, 原因: '领主未设置' };
    }

    const 淫乱度 = 母畜.获取属性('淫乱度');
    if (淫乱度 < 100) {
      return {
        成功: false,
        原因: '未达到完全淫堕状态',
        当前淫乱度: 淫乱度,
        需要淫乱度: 100,
      };
    }

    const 总雌性价值 = 母畜.获取属性('总雌性价值');
    const 魔力获得 = Math.floor(总雌性价值 / 100);

    this.领主.获得魔力(魔力获得);

    // 记录历史
    this.记录施放历史({
      法术名: '献祭母畜',
      目标ID: 母畜.实体ID,
      目标姓名: 母畜.获取属性('姓名'),
      目标类型: '母畜',
      魔力获得,
      周次: this._当前周次,
    });

    // 发布事件
    this.事件总线.发布('母畜献祭', {
      母畜ID: 母畜.实体ID,
      母畜姓名: 母畜.获取属性('姓名'),
      魔力获得,
    });

    return {
      成功: true,
      魔力获得,
      当前魔力: this.领主.获取属性('魔力'),
      需移除母畜: true, // 告知调用者需要移除该母畜
    };
  }

  // ─── 法术查询 ───

  获取可用法术列表(目标类型 = null) {
    /**
     * 获取当前可施放的法术列表
     */
    const 所有法术 = this.法术注册表.获取所有法术列表();
    const 当前魔力 = this.领主?.获取属性('魔力') ?? 0;

    return 所有法术
      .map(法术 => {
        const 验证 = this.验证施法(法术.名称, { 实体类型: 法术.目标类型 });

        return {
          ...法术,
          可施放: 验证.可施放,
          不可施放原因: 验证.原因,
          冷却剩余: this.获取冷却剩余(法术.名称),
        };
      })
      .filter(法术 => {
        if (目标类型 === null) return true;
        return 法术.目标类型 === 目标类型 || 法术.目标类型 === '无';
      });
  }

  获取冷却剩余(法术名) {
    const 定义 = this.法术注册表.获取法术定义(法术名);
    if (!定义?.冷却周期) return 0;

    const 上次施放 = this.法术冷却.get(法术名);
    if (!上次施放) return 0;

    const 剩余 = 定义.冷却周期 - (this._当前周次 - 上次施放);
    return Math.max(0, 剩余);
  }

  // ─── 效果修正器 ───

  添加效果修正器(法术名, 修正函数) {
    /**
     * 添加法术效果修正器
     * @param 修正函数 - (原效果参数) => 修正后效果参数
     * @returns 移除函数
     */
    this.效果修正器.set(法术名, 修正函数);

    return () => {
      this.效果修正器.delete(法术名);
    };
  }

  // ─── 周结算 ───

  周结算处理(新周次) {
    this._当前周次 = 新周次;
    // 冷却自动减少（通过周次差计算）
  }

  // ─── 历史记录 ───

  记录施放历史(记录) {
    this.施放历史.push({
      ...记录,
      时间戳: Date.now(),
    });

    while (this.施放历史.length > this.历史上限) {
      this.施放历史.shift();
    }
  }

  获取施放历史(过滤条件 = {}) {
    let 结果 = [...this.施放历史];

    if (过滤条件.法术名) {
      结果 = 结果.filter(h => h.法术名 === 过滤条件.法术名);
    }

    if (过滤条件.周次) {
      结果 = 结果.filter(h => h.周次 === 过滤条件.周次);
    }

    if (过滤条件.数量) {
      结果 = 结果.slice(-过滤条件.数量);
    }

    return 结果;
  }

  // ─── 魔力状态 ───

  获取魔力状态() {
    if (!this.领主) return null;

    return {
      当前: this.领主.获取属性('魔力'),
      最大: this.领主.获取属性('最大魔力'),
      百分比: this.领主.获取魔力百分比?.() ?? 0,
    };
  }

  // ─── 序列化 ───

  序列化() {
    return {
      法术冷却: Object.fromEntries(this.法术冷却),
      当前周次: this._当前周次,
      施放历史: this.施放历史.slice(-30),
    };
  }

  从序列化恢复(数据) {
    if (数据.法术冷却) {
      this.法术冷却 = new Map(Object.entries(数据.法术冷却));
    }
    this._当前周次 = 数据.当前周次 ?? 1;
    this.施放历史 = 数据.施放历史 ?? [];
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 法术系统 };
export default 法术系统;
```


src\systems\task.js
```js
// ═══════════════════════════════════════════════════════════════
// systems/task.js
// 任务系统 - 管理任务的验证、执行和结果处理
// ═══════════════════════════════════════════════════════════════

/**
 * 任务系统
 * 统一管理任务的验证、执行和结果处理
 */
class 任务系统 {
  constructor(事件总线, 任务注册表, 时间系统, 公式引擎) {
    this.事件总线 = 事件总线;
    this.任务注册表 = 任务注册表;
    this.时间系统 = 时间系统;
    this.公式引擎 = 公式引擎;

    // 本周任务记录
    this.本周执行记录 = new Map();

    // 任务结果历史
    this.任务历史 = [];
    this.历史上限 = 100;

    // 任务队列（用于异步/延迟任务）
    this.待处理任务队列 = [];

    // 任务执行钩子
    this.执行前钩子 = [];
    this.执行后钩子 = [];
  }

  // ─── 钩子注册 ───

  注册执行前钩子(钩子函数) {
    /**
     * @param 钩子函数 - (上下文) => { 继续: boolean, 修改后上下文? }
     */
    this.执行前钩子.push(钩子函数);
    return () => {
      const 索引 = this.执行前钩子.indexOf(钩子函数);
      if (索引 !== -1) this.执行前钩子.splice(索引, 1);
    };
  }

  注册执行后钩子(钩子函数) {
    /**
     * @param 钩子函数 - (上下文, 结果) => 修改后结果?
     */
    this.执行后钩子.push(钩子函数);
    return () => {
      const 索引 = this.执行后钩子.indexOf(钩子函数);
      if (索引 !== -1) this.执行后钩子.splice(索引, 1);
    };
  }

  // ─── 核心执行流程 ───

  验证任务(任务名, 负责人, 游戏状态, 额外参数 = {}) {
    /**
     * 验证任务是否可执行
     */
    const 上下文 = this.任务注册表.构建执行上下文({
      任务名,
      负责人,
      游戏状态,
      时间系统: this.时间系统,
      额外参数,
    });

    return this.任务注册表.验证任务可执行性(任务名, 上下文);
  }

  执行任务(任务名, 负责人, 游戏状态, 额外参数 = {}) {
    /**
     * 执行任务
     * @returns { 成功: boolean, 结果?: any, 原因?: string }
     */

    // 构建完整上下文
    let 上下文 = this.任务注册表.构建执行上下文({
      任务名,
      负责人,
      游戏状态,
      时间系统: this.时间系统,
      公式引擎: this.公式引擎,
      事件总线: this.事件总线,
      额外参数,
    });

    // 执行前钩子
    for (const 钩子 of this.执行前钩子) {
      try {
        const 钩子结果 = 钩子(上下文);
        if (钩子结果?.继续 === false) {
          return { 成功: false, 原因: 钩子结果.原因 ?? '被钩子拦截' };
        }
        if (钩子结果?.修改后上下文) {
          上下文 = 钩子结果.修改后上下文;
        }
      } catch (错误) {
        console.error('执行前钩子错误:', 错误);
      }
    }

    // 验证
    const 验证结果 = this.任务注册表.验证任务可执行性(任务名, 上下文);
    if (!验证结果.可执行) {
      this.任务注册表.记录执行结果(任务名, false);
      return { 成功: false, 原因: 验证结果.原因 };
    }

    const 定义 = this.任务注册表.获取任务定义(任务名);

    // 消耗行动点
    const 实际消耗 = this.任务注册表.计算实际行动点(任务名, 上下文);
    if (实际消耗 > 0 && this.时间系统) {
      const 消耗结果 = this.时间系统.消耗行动点(实际消耗);
      if (!消耗结果.成功) {
        return { 成功: false, 原因: 消耗结果.原因 };
      }
    }

    // 消耗资源
    if (定义.消耗资源) {
      const 资源系统 = this.任务注册表.获取系统('资源系统');
      if (资源系统) {
        for (const [资源名, 数量] of Object.entries(定义.消耗资源)) {
          资源系统.修改资源(资源名, -数量, `任务消耗:${任务名}`);
        }
      }
    }

    // 获取并执行任务执行器
    const 执行器 = this.任务注册表.任务执行器映射.get(任务名);
    if (!执行器) {
      this.任务注册表.记录执行结果(任务名, false);
      return { 成功: false, 原因: '任务执行器未注册' };
    }

    let 执行结果;
    try {
      执行结果 = 执行器(上下文);
    } catch (错误) {
      console.error(`任务执行错误 [${任务名}]:`, 错误);
      this.任务注册表.记录执行结果(任务名, false);
      return { 成功: false, 原因: '任务执行异常', 错误: 错误.message };
    }

    // 处理副作用
    if (执行结果.成功 !== false && 定义.副作用) {
      定义.副作用.forEach(副作用处理器 => {
        try {
          副作用处理器(上下文, 执行结果);
        } catch (错误) {
          console.error(`副作用处理错误 [${任务名}]:`, 错误);
        }
      });
    }

    // 执行后钩子
    for (const 钩子 of this.执行后钩子) {
      try {
        const 修改结果 = 钩子(上下文, 执行结果);
        if (修改结果) {
          执行结果 = 修改结果;
        }
      } catch (错误) {
        console.error('执行后钩子错误:', 错误);
      }
    }

    // 记录统计
    this.任务注册表.记录执行结果(任务名, 执行结果.成功 !== false);

    // 记录本周执行
    this.记录本周执行(任务名, 负责人.实体ID);

    // 记录历史
    this.记录任务历史({
      任务名,
      负责人ID: 负责人.实体ID,
      负责人姓名: 负责人.获取属性?.('姓名') ?? '未知',
      周次: this.时间系统?.当前周次,
      行动点消耗: 实际消耗,
      结果: 执行结果,
      时间戳: Date.now(),
    });

    // 发布事件
    this.事件总线.发布('任务完成', {
      任务名,
      负责人ID: 负责人.实体ID,
      行动点消耗: 实际消耗,
      结果: 执行结果,
    });

    return { 成功: true, 结果: 执行结果, 行动点消耗: 实际消耗 };
  }

  // ─── 批量执行 ───

  批量执行任务(任务列表, 游戏状态) {
    /**
     * 批量执行任务
     * @param 任务列表 - [{ 任务名, 负责人, 额外参数?, 失败中断? }, ...]
     */
    const 结果列表 = [];

    for (const 任务配置 of 任务列表) {
      const 结果 = this.执行任务(任务配置.任务名, 任务配置.负责人, 游戏状态, 任务配置.额外参数 ?? {});

      结果列表.push({
        任务名: 任务配置.任务名,
        ...结果,
      });

      // 如果配置为失败中断
      if (!结果.成功 && 任务配置.失败中断) {
        break;
      }
    }

    return 结果列表;
  }

  // ─── 记录管理 ───

  记录本周执行(任务名, 负责人ID) {
    const 键 = `${任务名}_${负责人ID}`;
    const 当前计数 = this.本周执行记录.get(键) ?? 0;
    this.本周执行记录.set(键, 当前计数 + 1);
  }

  重置本周记录() {
    this.本周执行记录.clear();
  }

  获取本周执行次数(任务名, 负责人ID = null) {
    if (负责人ID) {
      return this.本周执行记录.get(`${任务名}_${负责人ID}`) ?? 0;
    }

    let 总次数 = 0;
    this.本周执行记录.forEach((次数, 键) => {
      if (键.startsWith(`${任务名}_`)) {
        总次数 += 次数;
      }
    });
    return 总次数;
  }

  记录任务历史(记录) {
    this.任务历史.push(记录);
    if (this.任务历史.length > this.历史上限) {
      this.任务历史.shift();
    }
  }

  获取任务历史(过滤条件 = {}) {
    let 结果 = [...this.任务历史];

    if (过滤条件.任务名) {
      结果 = 结果.filter(r => r.任务名 === 过滤条件.任务名);
    }
    if (过滤条件.负责人ID) {
      结果 = 结果.filter(r => r.负责人ID === 过滤条件.负责人ID);
    }
    if (过滤条件.周次) {
      结果 = 结果.filter(r => r.周次 === 过滤条件.周次);
    }
    if (过滤条件.数量) {
      结果 = 结果.slice(-过滤条件.数量);
    }

    return 结果;
  }

  // ─── 周结算钩子 ───

  周结算处理() {
    this.重置本周记录();
    return { 类型: '任务系统周结算' };
  }

  // ─── 查询辅助 ───

  获取可执行任务列表(负责人, 游戏状态) {
    return this.任务注册表.获取负责人可执行任务(负责人, 游戏状态);
  }

  // ─── 序列化 ───

  序列化() {
    return {
      本周执行记录: Object.fromEntries(this.本周执行记录),
      任务历史: this.任务历史.slice(-50),
    };
  }

  从序列化恢复(数据) {
    if (数据.本周执行记录) {
      this.本周执行记录 = new Map(Object.entries(数据.本周执行记录));
    }
    this.任务历史 = 数据.任务历史 ?? [];
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 任务系统 };
export default 任务系统;
```


src\systems\time.js
```js
// ═══════════════════════════════════════════════════════════════
// systems/time.js
// 时间系统 - 管理游戏回合、行动点和周结算
// ═══════════════════════════════════════════════════════════════

class 时间系统 {
  constructor(事件总线, 配置 = {}, 公式引擎 = null) {
    this.事件总线 = 事件总线;
    this.公式引擎 = 公式引擎;

    // 从公式引擎获取配置或使用传入配置
    const 获取配置值 = (名称, 默认值) => {
      return 配置[名称] ?? 公式引擎?.获取常量(名称, 默认值) ?? 默认值;
    };

    this.当前周次 = 配置.初始周次 ?? 1;
    this.周行动点上限 = 获取配置值('周行动点上限', 3);
    this.剩余行动点 = 配置.初始行动点 ?? this.周行动点上限;

    this.周结算处理器 = [];
    this.新周处理器 = [];
    this.本周事件记录 = [];
    this.周历史 = [];
    this.历史上限 = 获取配置值('历史记录上限', 100);

    this.已暂停 = false;
  }

  设置公式引擎(引擎) {
    this.公式引擎 = 引擎;
  }

  // ─── 行动点管理 ───

  消耗行动点(数量 = 1) {
    if (this.已暂停) {
      return { 成功: false, 原因: '时间已暂停' };
    }

    if (this.剩余行动点 < 数量) {
      return {
        成功: false,
        原因: '行动点不足',
        剩余: this.剩余行动点,
        需要: 数量,
      };
    }

    this.剩余行动点 -= 数量;

    this.事件总线.发布('行动点消耗', {
      消耗数量: 数量,
      剩余: this.剩余行动点,
      周次: this.当前周次,
    });

    return {
      成功: true,
      剩余: this.剩余行动点,
    };
  }

  恢复行动点(数量 = 1) {
    const 旧值 = this.剩余行动点;
    this.剩余行动点 = Math.min(this.周行动点上限, this.剩余行动点 + 数量);
    const 实际恢复 = this.剩余行动点 - 旧值;

    if (实际恢复 > 0) {
      this.事件总线.发布('行动点恢复', {
        恢复数量: 实际恢复,
        剩余: this.剩余行动点,
      });
    }

    return { 实际恢复, 剩余: this.剩余行动点 };
  }

  设置行动点上限(新上限) {
    this.周行动点上限 = 新上限;
  }

  获取行动点状态() {
    return {
      剩余: this.剩余行动点,
      上限: this.周行动点上限,
      已消耗: this.周行动点上限 - this.剩余行动点,
    };
  }

  // ─── 周结算处理器 ───

  注册周结算处理器(处理函数, 优先级 = 0) {
    const 处理器信息 = { 处理函数, 优先级 };
    this.周结算处理器.push(处理器信息);
    this.周结算处理器.sort((a, b) => b.优先级 - a.优先级);

    return () => {
      const 索引 = this.周结算处理器.indexOf(处理器信息);
      if (索引 !== -1) {
        this.周结算处理器.splice(索引, 1);
      }
    };
  }

  注册新周处理器(处理函数, 优先级 = 0) {
    const 处理器信息 = { 处理函数, 优先级 };
    this.新周处理器.push(处理器信息);
    this.新周处理器.sort((a, b) => b.优先级 - a.优先级);

    return () => {
      const 索引 = this.新周处理器.indexOf(处理器信息);
      if (索引 !== -1) {
        this.新周处理器.splice(索引, 1);
      }
    };
  }

  // ─── 周流转 ───

  结束当前周(游戏状态) {
    if (this.已暂停) {
      return { 成功: false, 原因: '时间已暂停' };
    }

    this.事件总线.发布('周结算开始', {
      周次: this.当前周次,
    });

    const 结算结果列表 = [];

    for (const { 处理函数 } of this.周结算处理器) {
      try {
        const 结果 = 处理函数(游戏状态, this.当前周次);
        if (结果) {
          结算结果列表.push(结果);
        }
      } catch (错误) {
        console.error('周结算处理器错误:', 错误);
        结算结果列表.push({
          类型: '错误',
          错误信息: 错误.message,
        });
      }
    }

    this.记录周历史({
      周次: this.当前周次,
      行动点使用: this.周行动点上限 - this.剩余行动点,
      结算结果: 结算结果列表,
      事件记录: [...this.本周事件记录],
    });

    this.事件总线.发布('周结算完成', {
      周次: this.当前周次,
      结算结果: 结算结果列表,
    });

    this.当前周次++;
    this.剩余行动点 = this.周行动点上限;
    this.本周事件记录 = [];

    for (const { 处理函数 } of this.新周处理器) {
      try {
        处理函数(游戏状态, this.当前周次);
      } catch (错误) {
        console.error('新周处理器错误:', 错误);
      }
    }

    this.事件总线.发布('新周开始', {
      周次: this.当前周次,
      行动点: this.剩余行动点,
    });

    return {
      成功: true,
      旧周次: this.当前周次 - 1,
      新周次: this.当前周次,
      结算结果: 结算结果列表,
    };
  }

  // ─── 事件记录 ───

  记录本周事件(事件) {
    this.本周事件记录.push({
      ...事件,
      时间戳: Date.now(),
    });
  }

  获取本周事件记录() {
    return [...this.本周事件记录];
  }

  // ─── 周历史 ───

  记录周历史(周数据) {
    this.周历史.push({
      ...周数据,
      记录时间: Date.now(),
    });

    while (this.周历史.length > this.历史上限) {
      this.周历史.shift();
    }
  }

  获取周历史(周次 = null) {
    if (周次 !== null) {
      return this.周历史.find(h => h.周次 === 周次);
    }
    return [...this.周历史];
  }

  // ─── 暂停控制 ───

  暂停() {
    this.已暂停 = true;
    this.事件总线.发布('时间暂停', { 周次: this.当前周次 });
  }

  恢复() {
    this.已暂停 = false;
    this.事件总线.发布('时间恢复', { 周次: this.当前周次 });
  }

  是否暂停() {
    return this.已暂停;
  }

  获取时间状态() {
    return {
      当前周次: this.当前周次,
      剩余行动点: this.剩余行动点,
      周行动点上限: this.周行动点上限,
      已暂停: this.已暂停,
      本周事件数: this.本周事件记录.length,
    };
  }

  序列化() {
    return {
      当前周次: this.当前周次,
      剩余行动点: this.剩余行动点,
      周行动点上限: this.周行动点上限,
      本周事件记录: this.本周事件记录,
      周历史: this.周历史,
    };
  }

  从序列化恢复(数据) {
    this.当前周次 = 数据.当前周次 ?? 1;
    this.剩余行动点 = 数据.剩余行动点 ?? this.周行动点上限;
    this.周行动点上限 = 数据.周行动点上限 ?? 3;
    this.本周事件记录 = 数据.本周事件记录 ?? [];
    this.周历史 = 数据.周历史 ?? [];
  }
}

export { 时间系统 };
export default 时间系统;
```

