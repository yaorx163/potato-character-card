```
// ═══════════════════════════════════════════════════════════════
// core/entities.ts
// 实体基类与所有实体类型定义
// ═══════════════════════════════════════════════════════════════

interface 属性约束配置 {
    最小值: number;
    最大值: number;
  }
  
  interface 元数据配置 {
    创建时间: number;
    [key: string]: unknown;
  }
  
  interface 实体初始数据 {
    元数据?: Partial<元数据配置>;
    属性约束?: Map<string, 属性约束配置>;
  }
  
  type 事件处理器<T = unknown> = (数据: T, 实体: 实体基类) => void;
  
  /**
   * 实体基类
   * 所有游戏实体的基础，提供属性管理和事件钩子
   */
  class 实体基类 {
    static 实体计数器: number = 0;
  
    readonly 实体ID: string;
    readonly 实体类型: string;
    protected 属性容器: Map<string, unknown>;
    protected 元数据: 元数据配置;
    protected 事件监听器: Map<string, 事件处理器[]>;
    protected 属性约束: Map<string, 属性约束配置>;
  
    constructor(实体类型: string, 初始数据: 实体初始数据 = {}) {
      this.实体类型 = 实体类型;
      this.实体ID = this.生成唯一ID();
      this.属性容器 = new Map();
      this.元数据 = {
        创建时间: Date.now(),
        ...初始数据.元数据,
      };
      this.事件监听器 = new Map();
      this.属性约束 = 初始数据.属性约束 ?? new Map();
    }
  
    // ─── ID生成 ───
  
    private 生成唯一ID(): string {
      实体基类.实体计数器++;
      return `${this.实体类型}_${Date.now()}_${Math.random().toString(36).slice(2, 9)}_${实体基类.实体计数器.toString(36)}`;
    }
  
    // ─── 属性操作 ───
  
    设置属性约束(属性名: string, 最小值: number, 最大值: number): void {
      this.属性约束.set(属性名, { 最小值, 最大值 });
    }
  
    设置属性(属性名: string, 值: unknown): void {
      const 旧值 = this.属性容器.get(属性名);
      let 处理后的值 = 值;
  
      const 约束 = this.属性约束.get(属性名);
      if (约束 && typeof 值 === 'number') {
        处理后的值 = Math.max(约束.最小值, Math.min(约束.最大值, 值));
      }
  
      this.属性容器.set(属性名, 处理后的值);
      this.触发事件('属性变更', { 属性名, 旧值, 新值: 处理后的值 });
    }
  
    获取属性<T = unknown>(属性名: string, 默认值: T | null = null): T {
      return (this.属性容器.has(属性名) ? this.属性容器.get(属性名) : 默认值) as T;
    }
  
    修改属性(属性名: string, 增量: number): number {
      const 当前值 = this.获取属性<number>(属性名, 0);
      let 新值 = 当前值 + 增量;
  
      const 约束 = this.属性约束.get(属性名);
      if (约束) {
        新值 = Math.max(约束.最小值, Math.min(约束.最大值, 新值));
      }
  
      this.设置属性(属性名, 新值);
      return 新值;
    }
  
    批量设置属性(属性对象: Record<string, unknown>): void {
      Object.entries(属性对象).forEach(([属性名, 值]) => {
        this.设置属性(属性名, 值);
      });
    }
  
    获取所有属性(): Record<string, unknown> {
      return Object.fromEntries(this.属性容器);
    }
  
    // ─── 事件系统 ───
  
    监听事件<T = unknown>(事件名: string, 处理器: 事件处理器<T>): () => void {
      if (!this.事件监听器.has(事件名)) {
        this.事件监听器.set(事件名, []);
      }
      this.事件监听器.get(事件名)!.push(处理器 as 事件处理器);
  
      return () => {
        const 列表 = this.事件监听器.get(事件名);
        const 索引 = 列表?.indexOf(处理器 as 事件处理器);
        if (索引 !== undefined && 索引 !== -1) {
          列表!.splice(索引, 1);
        }
      };
    }
  
    触发事件(事件名: string, 数据: unknown = {}): void {
      const 处理器列表 = this.事件监听器.get(事件名) ?? [];
      处理器列表.forEach(处理器 => {
        try {
          处理器(数据, this);
        } catch (错误) {
          console.error(`实体事件处理错误 [${事件名}]:`, 错误);
        }
      });
    }
  
    销毁(): void {
      this.触发事件('实体销毁');
      this.事件监听器.clear();
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 领主实体
  // ═══════════════════════════════════════════════════════════════
  
  interface 领主初始数据 extends 实体初始数据 {
    魔力?: number;
    最大魔力?: number;
    姓名?: string;
  }
  
  interface 魔力操作结果 {
    成功: boolean;
    原因?: string;
    当前?: number;
    需要?: number;
    剩余?: number;
  }
  
  interface 魔力获得结果 {
    实际获得: number;
    当前: number;
    溢出: number;
  }
  
  /**
   * 领主实体
   * 玩家控制的主角，拥有魔力资源
   */
  class 领主实体 extends 实体基类 {
    constructor(初始数据: 领主初始数据 = {}) {
      super('领主', 初始数据);
  
      this.设置属性约束('魔力', 0, Infinity);
      this.设置属性约束('最大魔力', 0, Infinity);
  
      this.设置属性('魔力', 初始数据.魔力 ?? 0);
      this.设置属性('最大魔力', 初始数据.最大魔力 ?? 100);
      this.设置属性('姓名', 初始数据.姓名 ?? '无名领主');
    }
  
    // ─── 魔力操作 ───
  
    消耗魔力(数量: number): 魔力操作结果 {
      const 当前魔力 = this.获取属性<number>('魔力');
      if (当前魔力 < 数量) {
        return { 成功: false, 原因: '魔力不足', 当前: 当前魔力, 需要: 数量 };
      }
      this.设置属性('魔力', 当前魔力 - 数量);
      return { 成功: true, 剩余: 当前魔力 - 数量 };
    }
  
    获得魔力(数量: number): 魔力获得结果 {
      const 当前魔力 = this.获取属性<number>('魔力');
      const 最大魔力 = this.获取属性<number>('最大魔力');
      const 新魔力 = Math.min(当前魔力 + 数量, 最大魔力);
      const 实际获得 = 新魔力 - 当前魔力;
  
      this.设置属性('魔力', 新魔力);
  
      return { 实际获得, 当前: 新魔力, 溢出: 数量 - 实际获得 };
    }
  
    获取魔力百分比(): number {
      const 当前 = this.获取属性<number>('魔力');
      const 最大 = this.获取属性<number>('最大魔力');
      return 最大 > 0 ? (当前 / 最大) * 100 : 0;
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 冠军实体
  // ═══════════════════════════════════════════════════════════════
  
  interface 冠军初始数据 extends 实体初始数据 {
    姓名?: string;
    外貌描述?: string;
    性别?: string;
    力量?: number;
    敏捷?: number;
    智力?: number;
    管理喽啰池?: 喽啰池 | null;
    来源信息?: Record<string, unknown>;
  }
  
  /**
   * 冠军实体
   * 部落的精英战士，拥有三维属性，可统帅喽啰
   */
  class 冠军实体 extends 实体基类 {
    管理喽啰池: 喽啰池 | null;
    来源信息: Record<string, unknown>;
  
    constructor(初始数据: 冠军初始数据 = {}) {
      super('冠军', 初始数据);
  
      this.设置属性约束('力量', 0, 100);
      this.设置属性约束('敏捷', 0, 100);
      this.设置属性约束('智力', 0, 100);
  
      this.设置属性('姓名', 初始数据.姓名 ?? '无名冠军');
      this.设置属性('外貌描述', 初始数据.外貌描述 ?? '');
      this.设置属性('性别', 初始数据.性别 ?? '男');
  
      this.设置属性('力量', 初始数据.力量 ?? 10);
      this.设置属性('敏捷', 初始数据.敏捷 ?? 10);
      this.设置属性('智力', 初始数据.智力 ?? 10);
  
      this.管理喽啰池 = 初始数据.管理喽啰池 ?? null;
      this.来源信息 = 初始数据.来源信息 ?? {};
    }
  
    绑定喽啰池(喽啰池: 喽啰池 | null): void {
      if (this.管理喽啰池 === 喽啰池) return;
  
      if (this.管理喽啰池) {
        const 旧池 = this.管理喽啰池;
        this.管理喽啰池 = null;
        if (旧池.将领 === this) 旧池.移除将领();
      }
  
      if (喽啰池) {
        this.管理喽啰池 = 喽啰池;
        if (喽啰池.将领 !== this) 喽啰池.将领 = this;
      }
    }
  
    移除喽啰池(): void {
      if (this.管理喽啰池 === null) return;
      const 喽啰池 = this.管理喽啰池;
      this.管理喽啰池 = null;
      if (喽啰池.获取将领() === this) {
        喽啰池.移除将领();
      }
    }
  
    获取喽啰池(): 喽啰池 | null {
      return this.管理喽啰池;
    }
  
    计算可统帅喽啰数(): number {
      return this.获取属性<number>('力量');
    }
  
    计算总属性值(): number {
      return this.获取属性<number>('力量') +
             this.获取属性<number>('敏捷') +
             this.获取属性<number>('智力');
    }
  
    获取主属性(): '力量' | '敏捷' | '智力' {
      const 力量 = this.获取属性<number>('力量');
      const 敏捷 = this.获取属性<number>('敏捷');
      const 智力 = this.获取属性<number>('智力');
  
      if (力量 >= 敏捷 && 力量 >= 智力) return '力量';
      if (敏捷 >= 力量 && 敏捷 >= 智力) return '敏捷';
      return '智力';
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 母畜实体
  // ═══════════════════════════════════════════════════════════════
  
  interface 母畜初始数据 extends 实体初始数据 {
    姓名?: string;
    种族?: string;
    年龄?: number;
    原身份?: string;
    来源?: string;
    描述?: string;
    总雌性价值?: number;
    剩余雌性价值?: number;
    淫乱度?: number;
    臣服度?: number;
    特性列表?: string[];
    来源地点ID?: string | null;
    冠军生育记录?: string[];
    喽啰生育记录?: number;
  }
  
  interface 消耗结果 {
    成功: boolean;
    原因?: string;
    当前?: number;
    需要?: number;
    剩余?: number;
  }
  
  /**
   * 母畜实体 - 统一表示所有女性目标（无论是否已捕获）
   */
  class 母畜实体 extends 实体基类 {
    特性列表: Set<string>;
    来源地点ID: string | null;
    冠军生育记录: string[];
    喽啰生育记录: number;
  
    constructor(配置: 母畜初始数据 = {}) {
      super('母畜');
      this.设置属性约束('臣服度', 0, 100);
      this.设置属性约束('淫乱度', 0, 100);
      this.设置属性约束('总雌性价值', 0, Infinity);
      this.设置属性约束('剩余雌性价值', 0, Infinity);
  
      this.设置属性('姓名', 配置.姓名 ?? '无名');
      this.设置属性('种族', 配置.种族 ?? '人类');
      this.设置属性('年龄', 配置.年龄 ?? 20);
      this.设置属性('原身份', 配置.原身份 ?? '平民');
      this.设置属性('来源', 配置.来源 ?? '未知');
      this.设置属性('描述', 配置.描述 ?? '');
  
      const 总值 = 配置.总雌性价值 ?? 100;
      this.设置属性('总雌性价值', 总值);
      this.设置属性('剩余雌性价值', 配置.剩余雌性价值 ?? 总值);
  
      this.设置属性('淫乱度', 配置.淫乱度 ?? 0);
      this.设置属性('臣服度', 配置.臣服度 ?? 0);
  
      this.特性列表 = new Set(配置.特性列表 || []);
      this.来源地点ID = 配置.来源地点ID || null;
      this.冠军生育记录 = 配置.冠军生育记录 || [];
      this.喽啰生育记录 = 配置.喽啰生育记录 || 0;
    }
  
    设置属性(属性名: string, 值: unknown): void {
      if (属性名 === '总雌性价值' && typeof 值 === 'number') {
        this.属性约束.set('剩余雌性价值', { 最小值: 0, 最大值: 值 });
        const 当前剩余 = (this.属性容器.get('剩余雌性价值') as number) ?? 值;
        this.属性容器.set('剩余雌性价值', Math.min(当前剩余, 值));
      }
      super.设置属性(属性名, 值);
    }
  
    消耗雌性价值(数量: number): 消耗结果 {
      const 当前 = this.获取属性<number>('剩余雌性价值');
      if (当前 < 数量) {
        return { 成功: false, 原因: '雌性价值不足', 当前, 需要: 数量 };
      }
      this.设置属性('剩余雌性价值', 当前 - 数量);
      return { 成功: true, 剩余: 当前 - 数量 };
    }
  
    添加特性(特性名: string): void {
      this.特性列表.add(特性名);
    }
  
    移除特性(特性名: string): void {
      this.特性列表.delete(特性名);
    }
  
    拥有特性(特性名: string): boolean {
      return this.特性列表.has(特性名);
    }
  
    记录生育冠军(冠军实体ID: string): void {
      this.冠军生育记录.push(冠军实体ID);
    }
  
    记录生育喽啰(实际产出: number): void {
      if (实际产出 <= 0) return;
      this.喽啰生育记录 += 实际产出;
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 喽啰池
  // ═══════════════════════════════════════════════════════════════
  
  interface 武装分组数据 {
    数量: number;
    战斗力: number;
    描述: string;
  }
  
  interface 武装等级配置 {
    战斗力?: number;
    描述?: string;
  }
  
  interface 喽啰池初始数据 extends 实体初始数据 {
    将领?: 冠军实体 | null;
  }
  
  interface 减少喽啰结果 {
    成功: boolean;
    原因?: string;
    实际减少?: number;
    剩余?: number;
  }
  
  interface 武装升级结果 {
    升级数量: number;
    溢出数量: number;
  }
  
  interface 分组详情 {
    等级: string;
    数量: number;
    战斗力: number;
    描述: string;
  }
  
  interface 分配喽啰结果 {
    成功: boolean;
    原因?: string;
    分配数量: number;
    未满足数量?: number;
    分配详情: Array<{ 等级: string; 数量: number }>;
  }
  
  /**
   * 喽啰池
   * 喽啰以数值形式存在，按武装等级分组管理
   */
  class 喽啰池 extends 实体基类 {
    武装分组: Map<string, 武装分组数据>;
    将领: 冠军实体 | null;
  
    constructor(初始数据: 喽啰池初始数据 = {}) {
      super('喽啰池', 初始数据);
      this.武装分组 = new Map();
      this.将领 = 初始数据.将领 ?? null;
  
      this.武装分组.set('未武装', {
        数量: 0,
        战斗力: 100,
        描述: '未经武装的喽啰',
      });
    }
  
    // ─── 武装等级管理 ───
  
    注册武装等级(等级名: string, 配置: 武装等级配置): void {
      if (!this.武装分组.has(等级名)) {
        this.武装分组.set(等级名, {
          数量: 0,
          战斗力: 配置.战斗力 ?? 100,
          描述: 配置.描述 ?? '',
        });
      }
    }
  
    获取武装等级配置(等级名: string): 武装分组数据 | undefined {
      return this.武装分组.get(等级名);
    }
  
    获取所有武装等级(): string[] {
      return Array.from(this.武装分组.keys());
    }
  
    // ─── 数量操作 ───
  
    移除将领(): void {
      const 将领 = this.将领;
      if (将领 === null) return;
      this.将领 = null;
      if (将领.获取喽啰池() === this) {
        将领.移除喽啰池();
      }
    }
  
    绑定将领(将领: 冠军实体): void {
      将领.绑定喽啰池(this);
    }
  
    增加喽啰(数量: number, 武装等级: string = '未武装'): void {
      const 分组 = this.武装分组.get(武装等级);
      if (!分组) {
        console.warn(`未知武装等级: ${武装等级}，添加到未武装`);
        this.武装分组.get('未武装')!.数量 += 数量;
        return;
      }
      分组.数量 += 数量;
    }
  
    减少喽啰(数量: number, 武装等级: string = '未武装'): 减少喽啰结果 {
      const 分组 = this.武装分组.get(武装等级);
      if (!分组) return { 成功: false, 原因: '未知武装等级' };
  
      const 实际减少 = Math.min(数量, 分组.数量);
      分组.数量 -= 实际减少;
  
      return {
        成功: true,
        实际减少,
        剩余: 分组.数量,
      };
    }
  
    获取分组数量(武装等级: string): number {
      return this.武装分组.get(武装等级)?.数量 ?? 0;
    }
  
    // ─── 武装升级 ───
  
    武装升级(数量: number, 目标等级: string, 优先等级列表: string[] | null = null): 武装升级结果 {
      if (!this.武装分组.has(目标等级)) {
        return { 升级数量: 0, 溢出数量: 数量 };
      }
  
      const 等级顺序 = 优先等级列表 || ['未武装'];
      const 目标索引 = 等级顺序.indexOf(目标等级);
  
      if (目标索引 <= 0) {
        return { 升级数量: 0, 溢出数量: 数量 };
      }
  
      let 剩余需求 = 数量;
      let 总升级数量 = 0;
  
      for (let i = 0; i < 目标索引 && 剩余需求 > 0; i++) {
        const 目标分组 = this.武装分组.get(目标等级);
        if (!目标分组) {
          return { 升级数量: 0, 溢出数量: 数量 };
        }
  
        const 来源等级 = 等级顺序[i];
        const 来源分组 = this.武装分组.get(来源等级);
  
        if (!来源分组 || 来源分组.数量 <= 0) continue;
  
        const 可升级数量 = Math.min(来源分组.数量, 剩余需求);
  
        来源分组.数量 -= 可升级数量;
        目标分组.数量 += 可升级数量;
  
        总升级数量 += 可升级数量;
        剩余需求 -= 可升级数量;
      }
  
      return {
        升级数量: 总升级数量,
        溢出数量: 剩余需求,
      };
    }
  
    // ─── 统计 ───
  
    获取最大数量(): number {
      if (this.将领) {
        return this.将领.计算可统帅喽啰数();
      }
      return Infinity;
    }
  
    获取总数量(): number {
      let 总数 = 0;
      this.武装分组.forEach(分组 => {
        总数 += 分组.数量;
      });
      return 总数;
    }
  
    获取分组详情(): 分组详情[] {
      return Array.from(this.武装分组.entries()).map(([等级, 数据]) => ({
        等级,
        ...数据,
      }));
    }
  
    计算总战斗力(): number {
      let 总战力 = 0;
      this.武装分组.forEach(分组 => {
        总战力 += 分组.数量 * (分组.战斗力 / 100);
      });
      return 总战力;
    }
  
    获取战斗力(): number {
      if (this.将领) {
        const 敏捷 = this.将领.获取属性<number>('敏捷');
        const 智力 = this.将领.获取属性<number>('智力');
        const 部曲战斗力 = this.计算总战斗力();
        const 加权战斗力 = 部曲战斗力 * (智力 + 150) / 150 + 敏捷 * 10;
        return 加权战斗力;
      }
      return this.计算总战斗力();
    }
  
    获取将领(): 冠军实体 | null {
      return this.将领;
    }
  
    // ─── 分配喽啰 ───
  
    分配喽啰(
      目标喽啰池: 喽啰池,
      需求数量: number,
      优先等级列表: string[] | null = null
    ): 分配喽啰结果 {
      const 等级顺序 = 优先等级列表 || this.获取所有武装等级();
      const 目标容量 = 目标喽啰池.获取最大数量();
      const 目标当前数量 = 目标喽啰池.获取总数量();
      const 可接收数量 = Math.min(需求数量, 目标容量 - 目标当前数量);
  
      if (可接收数量 <= 0) {
        return {
          成功: false,
          原因: '目标喽啰池已满或无需分配',
          分配数量: 0,
          分配详情: [],
        };
      }
  
      let 剩余分配 = 可接收数量;
      const 分配详情: Array<{ 等级: string; 数量: number }> = [];
  
      for (const 等级 of 等级顺序) {
        if (剩余分配 <= 0) break;
  
        const 来源分组 = this.武装分组.get(等级);
        if (!来源分组 || 来源分组.数量 <= 0) continue;
  
        if (目标喽啰池.武装分组.get(等级) === undefined) {
          目标喽啰池.注册武装等级(等级, {
            战斗力: 来源分组.战斗力,
            描述: 来源分组.描述,
          });
        }
  
        const 本次分配 = Math.min(来源分组.数量, 剩余分配);
  
        来源分组.数量 -= 本次分配;
        目标喽啰池.增加喽啰(本次分配, 等级);
  
        分配详情.push({
          等级,
          数量: 本次分配,
        });
  
        剩余分配 -= 本次分配;
      }
  
      const 总分配数量 = 可接收数量 - 剩余分配;
  
      return {
        成功: 总分配数量 > 0,
        分配数量: 总分配数量,
        未满足数量: 需求数量 - 总分配数量,
        分配详情,
      };
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 可袭击地点实体
  // ═══════════════════════════════════════════════════════════════
  
  interface 可袭击地点配置 {
    地点名称?: string;
    地点类型?: string;
    描述?: string;
    侦察最大值?: number;
    侦察进度?: number;
    战斗力?: number;
  }
  
  /**
   * 可袭击地点实体
   * 表示一个可被袭击的地点（村庄、商队、城市等）
   */
  class 可袭击地点实体 extends 实体基类 {
    地点名称: string;
    地点类型: string;
    描述: string;
    侦察最大值: number;
    侦察进度: number;
    潜在地点母畜池: Map<string, 母畜实体>;
    已侦察母畜: Map<string, 母畜实体>;
  
    constructor(配置: 可袭击地点配置 = {}) {
      super('可袭击地点');
  
      this.地点名称 = 配置.地点名称 || '未知地点';
      this.地点类型 = 配置.地点类型 || '村庄';
      this.描述 = 配置.描述 || '';
      this.侦察最大值 = 配置.侦察最大值 ?? 100;
      this.侦察进度 = 配置.侦察进度 ?? 0;
  
      this.设置属性('战斗力', 配置.战斗力 ?? 100);
  
      this.潜在地点母畜池 = new Map();
      this.已侦察母畜 = new Map();
    }
  
    // ===== 潜在母畜管理 =====
  
    添加潜在母畜(母畜实体: 母畜实体): void {
      母畜实体.设置属性('来源', this.地点名称);
      this.潜在地点母畜池.set(母畜实体.实体ID, 母畜实体);
    }
  
    获取随机潜在母畜(): 母畜实体 | null {
      const 母畜列表 = [...this.潜在地点母畜池.values()];
      if (母畜列表.length === 0) return null;
  
      return 母畜列表[Math.floor(Math.random() * 母畜列表.length)];
    }
  
    标记母畜已侦察(母畜输入: 母畜实体 | string): 母畜实体 | null {
      const 母畜实体ID = typeof 母畜输入 === 'string' ? 母畜输入 : 母畜输入.实体ID;
      const 目标母畜 = this.潜在地点母畜池.get(母畜实体ID);
      if (!目标母畜) return null;
  
      this.潜在地点母畜池.delete(母畜实体ID);
      this.已侦察母畜.set(母畜实体ID, 目标母畜);
      return 目标母畜;
    }
  
    移除已捕获母畜(母畜输入: 母畜实体 | string): boolean {
      const 母畜实体ID = typeof 母畜输入 === 'string' ? 母畜输入 : 母畜输入.实体ID;
      return this.已侦察母畜.delete(母畜实体ID);
    }
  
    增加侦察进度(增量: number): number {
      this.侦察进度 = Math.min(this.侦察进度 + 增量, this.侦察最大值);
      return this.侦察进度;
    }
  
    是否侦察完成(): boolean {
      if (this.潜在地点母畜池.size === 0) {
        return true;
      }
      return this.侦察进度 >= this.侦察最大值;
    }
  
    // ===== 母畜查询 =====
  
    获取所有已侦察母畜(): 母畜实体[] {
      return [...this.已侦察母畜.values()];
    }
  
    获取母畜(母畜实体ID: string): 母畜实体 | undefined {
      return this.已侦察母畜.get(母畜实体ID) || this.潜在地点母畜池.get(母畜实体ID);
    }
  
    获取潜在母畜数量(): number {
      return this.潜在地点母畜池.size;
    }
  
    获取潜在母畜列表(): 母畜实体[] {
      return [...this.潜在地点母畜池.values()];
    }
  
    获取潜在母畜(): Map<string, 母畜实体> {
      return this.潜在地点母畜池;
    }
  
    获取已侦察母畜数量(): number {
      return this.已侦察母畜.size;
    }
  
    获取侦察进度(): number {
      return this.侦察进度;
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 导出
  // ═══════════════════════════════════════════════════════════════
  
  export {
    实体基类,
    领主实体,
    冠军实体,
    母畜实体,
    喽啰池,
    可袭击地点实体
  };
  
  export type {
    属性约束配置,
    元数据配置,
    实体初始数据,
    领主初始数据,
    冠军初始数据,
    母畜初始数据,
    喽啰池初始数据,
    可袭击地点配置,
    武装分组数据,
    武装等级配置,
    分组详情,
    魔力操作结果,
    魔力获得结果,
    消耗结果,
    减少喽啰结果,
    武装升级结果,
    分配喽啰结果,
    事件处理器
  };
  
```

```
// ═══════════════════════════════════════════════════════════════
// core/factories.ts
// 工厂类 - 负责创建游戏实体
// ═══════════════════════════════════════════════════════════════

import {
    冠军实体,
    母畜实体,
    可袭击地点实体,
    领主实体
  } from './entities';
  
  // ═══════════════════════════════════════════════════════════════
  // 类型定义
  // ═══════════════════════════════════════════════════════════════
  
  interface 姓名池配置 {
    前缀: string[];
    主名: string[];
    后缀: string[];
  }
  
  interface 属性系数 {
    力量: number;
    敏捷: number;
    智力: number;
  }
  
  interface 冠军工厂配置 {
    冠军姓名池?: 姓名池配置;
    生育消耗?: number;
    属性随机浮动范围?: number;
    前缀概率?: number;
    后缀概率?: number;
    效率系数表?: Map<string, 属性系数>;
    种族系数表?: Map<string, 属性系数>;
  }
  
  interface 生育选项 {
    姓名?: string;
    性别?: string;
  }
  
  interface 生育结果 {
    成功: boolean;
    冠军?: 冠军实体;
    消耗雌性价值?: number;
    属性?: { 力量: number; 敏捷: number; 智力: number };
    原因?: string;
    当前?: number;
    需要?: number;
  }
  
  interface 属性预估范围 {
    最小: number;
    最大: number;
    期望: number;
  }
  
  interface 生育属性预估 {
    力量: 属性预估范围;
    敏捷: 属性预估范围;
    智力: 属性预估范围;
  }
  
  interface 种族配置数据 {
    姓名池?: 姓名池配置;
    前缀概率?: number;
    后缀概率?: number;
  }
  
  interface 身份配置数据 {
    最小年龄?: number;
    最大年龄?: number;
  }
  
  interface 母畜工厂配置 {
    种族配置?: Map<string, 种族配置数据>;
    身份配置?: Map<string, 身份配置数据>;
  }
  
  interface 母畜创建配置 {
    姓名?: string;
    种族?: string;
    身份?: string;
    年龄?: number;
    来源?: string;
    描述?: string;
    来源地点ID?: string;
    总雌性价值?: number;
    剩余雌性价值?: number;
    捕获回合?: number;
  }
  
  interface 领主工厂配置 {
    初始魔力?: number;
    最大魔力?: number;
    默认姓名?: string;
  }
  
  interface 领主创建配置 {
    魔力?: number;
    最大魔力?: number;
    姓名?: string;
  }
  
  interface 地点类型配置数据 {
    描述模板?: string;
    基础战斗力?: number;
    侦察最大值?: number;
    母畜数量?: number;
    身份分布?: Record<string, number>;
    前缀?: string[];
    中缀?: string[];
    后缀?: string[];
  }
  
  interface 可袭击地点工厂配置 {
    地点类型配置?: Map<string, 地点类型配置数据>;
  }
  
  interface 地点创建配置 {
    名称?: string;
    描述?: string;
    战斗力?: number;
    侦察进度?: number;
    侦察最大值?: number;
    母畜数量?: number;
  }
  
  interface 运行时配置 {
    冠军配置?: 冠军工厂配置;
    母畜配置?: 母畜工厂配置;
    领主配置?: 领主工厂配置;
    地点配置?: 可袭击地点工厂配置;
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 冠军工厂
  // ═══════════════════════════════════════════════════════════════
  
  class 冠军工厂 {
    private 姓名池: 姓名池配置;
    private 生育消耗: number;
    private 随机浮动范围: number;
    private 前缀概率: number;
    private 后缀概率: number;
    private 效率系数表: Map<string, 属性系数>;
    private 种族系数表: Map<string, 属性系数>;
  
    constructor(配置: 冠军工厂配置 = {}) {
      this.姓名池 = 配置.冠军姓名池 ?? {
        前缀: [],
        主名: [],
        后缀: [],
      };
      this.生育消耗 = 配置.生育消耗 ?? 10;
      this.随机浮动范围 = 配置.属性随机浮动范围 ?? 3;
      this.前缀概率 = 配置.前缀概率 ?? 0.3;
      this.后缀概率 = 配置.后缀概率 ?? 0.2;
      this.效率系数表 = 配置.效率系数表 ?? new Map();
      this.种族系数表 = 配置.种族系数表 ?? new Map();
    }
  
    // ─── 配置方法 ───
  
    生成随机姓名(): string {
      if (this.姓名池?.主名?.length > 0) {
        const 随机选择 = <T>(数组: T[]): T | string => {
          if (!数组 || 数组.length === 0) return '';
          return 数组[Math.floor(Math.random() * 数组.length)];
        };
  
        const 前缀 = Math.random() < this.前缀概率 ? 随机选择(this.姓名池.前缀) : '';
        const 主名 = 随机选择(this.姓名池.主名);
        const 后缀 = Math.random() < this.后缀概率 ? 随机选择(this.姓名池.后缀) : '';
  
        return `${前缀}${主名}${后缀}`.trim();
      }
  
      return `冠军_${Date.now().toString(36).slice(-4)}`;
    }
  
    // ─── 属性计算辅助 ───
  
    private 计算随机浮动(): number {
      const 范围 = this.随机浮动范围;
      return Math.floor(Math.random() * (范围 * 2 + 1)) - 范围;
    }
  
    private 计算属性值(基础值: number, 身份系数: number = 1.0, 种族系数: number = 1.0): number {
      const 浮动 = this.计算随机浮动();
      const 原始值 = (基础值 + 浮动) * 身份系数 * 种族系数;
      return Math.max(1, Math.round(原始值));
    }
  
    private 获取效率系数(身份: string): 属性系数 {
      return this.效率系数表.get(身份) ?? { 力量: 1.0, 敏捷: 1.0, 智力: 1.0 };
    }
  
    private 获取种族系数(种族: string): 属性系数 {
      return this.种族系数表.get(种族) ?? { 力量: 1.0, 敏捷: 1.0, 智力: 1.0 };
    }
  
    // ─── 创建方法 ───
  
    从母畜生育(母畜: 母畜实体, 选项: 生育选项 = {}): 生育结果 {
      const 消耗结果 = 母畜.消耗雌性价值(this.生育消耗);
      if (!消耗结果.成功) {
        return {
          成功: false,
          原因: 消耗结果.原因,
          当前: 消耗结果.当前,
          需要: 消耗结果.需要,
        };
      }
  
      const 母畜身份 = 母畜.获取属性<string>('原身份');
      const 母畜种族 = 母畜.获取属性<string>('种族');
      const 总雌性价值 = 母畜.获取属性<number>('总雌性价值');
  
      const 身份系数 = this.获取效率系数(母畜身份);
      const 种族系数 = this.获取种族系数(母畜种族);
  
      const 基础值 = 总雌性价值 / 10;
  
      const 力量 = this.计算属性值(基础值, 身份系数.力量, 种族系数.力量);
      const 敏捷 = this.计算属性值(基础值, 身份系数.敏捷, 种族系数.敏捷);
      const 智力 = this.计算属性值(基础值, 身份系数.智力, 种族系数.智力);
  
      const 姓名 = 选项.姓名 ?? this.生成随机姓名();
  
      const 冠军数据 = {
        姓名,
        性别: 选项.性别 ?? '男',
        力量,
        敏捷,
        智力,
        来源信息: {
          类型: '生育',
          母畜ID: 母畜.实体ID,
        },
      };
  
      const 新冠军 = new 冠军实体(冠军数据);
      母畜.记录生育冠军(新冠军.实体ID);
  
      return {
        成功: true,
        冠军: 新冠军,
        消耗雌性价值: this.生育消耗,
        属性: { 力量, 敏捷, 智力 },
      };
    }
  
    // ─── 预估方法 ───
  
    预估生育属性(母畜: 母畜实体): 生育属性预估 {
      const 母畜身份 = 母畜.获取属性<string>('原身份');
      const 母畜种族 = 母畜.获取属性<string>('种族');
      const 总雌性价值 = 母畜.获取属性<number>('总雌性价值');
  
      const 身份系数 = this.获取效率系数(母畜身份);
      const 种族系数 = this.获取种族系数(母畜种族);
  
      const 基础值 = 总雌性价值 / 10;
      const 范围 = this.随机浮动范围;
  
      return {
        力量: {
          最小: Math.max(1, Math.round((基础值 - 范围) * 身份系数.力量 * 种族系数.力量)),
          最大: Math.round((基础值 + 范围) * 身份系数.力量 * 种族系数.力量),
          期望: Math.round(基础值 * 身份系数.力量 * 种族系数.力量),
        },
        敏捷: {
          最小: Math.max(1, Math.round((基础值 - 范围) * 身份系数.敏捷 * 种族系数.敏捷)),
          最大: Math.round((基础值 + 范围) * 身份系数.敏捷 * 种族系数.敏捷),
          期望: Math.round(基础值 * 身份系数.敏捷 * 种族系数.敏捷),
        },
        智力: {
          最小: Math.max(1, Math.round((基础值 - 范围) * 身份系数.智力 * 种族系数.智力)),
          最大: Math.round((基础值 + 范围) * 身份系数.智力 * 种族系数.智力),
          期望: Math.round(基础值 * 身份系数.智力 * 种族系数.智力),
        },
      };
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 母畜工厂
  // ═══════════════════════════════════════════════════════════════
  
  class 母畜工厂 {
    private 种族配置: Map<string, 种族配置数据>;
    private 身份配置: Map<string, 身份配置数据>;
  
    constructor(配置: 母畜工厂配置 = {}) {
      this.种族配置 = 配置.种族配置 ?? new Map();
      this.身份配置 = 配置.身份配置 ?? new Map();
    }
  
    // ===== 创建方法 =====
  
    创建潜在母畜(配置: 母畜创建配置 = {}): 母畜实体 {
      const 种族 = 配置.种族 || this.随机选择种族();
      const 身份 = 配置.身份 || this.随机选择身份();
  
      const 母畜 = new 母畜实体({
        姓名: 配置.姓名 || this.生成随机姓名(种族),
        种族,
        年龄: 配置.年龄 ?? this.随机年龄(身份),
        原身份: 身份,
        来源: 配置.来源 || '可袭击地点',
        描述: 配置.描述 || this.生成描述(种族, 身份),
        来源地点ID: 配置.来源地点ID || null,
        总雌性价值: 配置.总雌性价值 || 100,
        剩余雌性价值: 配置.剩余雌性价值 || 配置.总雌性价值 || 100,
      });
  
      return 母畜;
    }
  
    创建已捕获(配置: 母畜创建配置 = {}): 母畜实体 {
      const 母畜 = this.创建潜在母畜({
        ...配置,
        来源: 配置.来源 || '直接获取'
      });
  
      return 母畜;
    }
  
    批量创建潜在母畜(数量: number, 基础配置: 母畜创建配置 = {}): 母畜实体[] {
      const 结果: 母畜实体[] = [];
      for (let i = 0; i < 数量; i++) {
        结果.push(this.创建潜在母畜({
          ...基础配置,
        }));
      }
      return 结果;
    }
  
    // ===== 辅助方法 =====
  
    private 随机选择种族(): string {
      const 种族列表 = [...this.种族配置.keys()];
      if (种族列表.length === 0) return '人类';
      return 种族列表[Math.floor(Math.random() * 种族列表.length)];
    }
  
    private 随机选择身份(): string {
      const 身份列表 = [...this.身份配置.keys()];
      if (身份列表.length === 0) return '平民';
      return 身份列表[Math.floor(Math.random() * 身份列表.length)];
    }
  
    private 随机年龄(身份: string): number {
      const 身份数据 = this.身份配置.get(身份);
      const 最小 = 身份数据?.最小年龄 ?? 18;
      const 最大 = 身份数据?.最大年龄 ?? 40;
      return Math.floor(最小 + Math.random() * (最大 - 最小));
    }
  
    private 生成随机姓名(种族: string): string {
      const 种族数据 = this.种族配置.get(种族);
      const 姓名池 = 种族数据?.姓名池;
      if (!姓名池) {
        return `无名哥布林冠军`;
      };
  
      if (姓名池.主名?.length > 0) {
        const 随机选择 = <T>(数组: T[]): T | string => {
          if (!数组 || 数组.length === 0) return '';
          return 数组[Math.floor(Math.random() * 数组.length)];
        };
        const 前缀概率 = 种族数据?.前缀概率 ?? 0;
        const 后缀概率 = 种族数据?.后缀概率 ?? 0;
  
        const 前缀 = Math.random() < 前缀概率 ? 随机选择(姓名池.前缀 ?? []) : '';
        const 主名 = 随机选择(姓名池.主名);
        const 后缀 = Math.random() < 后缀概率 ? 随机选择(姓名池.后缀 ?? []) : '';
  
        return `${前缀}${主名}${后缀}`.trim();
      }
  
      return `无名_${Date.now().toString(36).slice(-4)}`;
    }
  
    private 生成描述(种族: string, 身份: string): string {
      return `一位 ${种族} ${身份}`;
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 领主工厂
  // ═══════════════════════════════════════════════════════════════
  
  class 领主工厂 {
    private 默认配置: { 魔力: number; 最大魔力: number; 姓名: string };
  
    constructor(配置: 领主工厂配置 = {}) {
      this.默认配置 = {
        魔力: 配置.初始魔力 ?? 0,
        最大魔力: 配置.最大魔力 ?? 100,
        姓名: 配置.默认姓名 ?? '无名领主',
      };
    }
  
    创建领主(配置: 领主创建配置 = {}): 领主实体 {
      return new 领主实体({
        ...this.默认配置,
        ...配置,
      });
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 可袭击地点工厂
  // ═══════════════════════════════════════════════════════════════
  
  class 可袭击地点工厂 {
    private 地点类型配置: Map<string, 地点类型配置数据>;
    private 母畜工厂: 母畜工厂 | null;
  
    constructor(配置: 可袭击地点工厂配置 = {}) {
      this.地点类型配置 = 配置.地点类型配置 ?? new Map();
      this.母畜工厂 = null;
    }
  
    设置母畜工厂(工厂: 母畜工厂): void {
      this.母畜工厂 = 工厂;
    }
  
    创建地点(类型: string, 配置: 地点创建配置 = {}): 可袭击地点实体 {
      if (!this.地点类型配置.has(类型)) {
        throw new Error(`未知的地点类型: ${类型}`);
      }
      const 类型配置 = this.地点类型配置.get(类型)!;
  
      const 地点 = new 可袭击地点实体({
        地点名称: 配置.名称 || this.生成地点名称(类型),
        地点类型: 类型,
        描述: 配置.描述 || 类型配置.描述模板,
        战斗力: 配置.战斗力 ?? 类型配置.基础战斗力,
        侦察进度: 配置.侦察进度 ?? 0,
        侦察最大值: 配置.侦察最大值 ?? 类型配置.侦察最大值 ?? 100
      });
  
      if (this.母畜工厂) {
        this.填充潜在母畜(地点, 类型配置, 配置);
      }
  
      return 地点;
    }
  
    private 填充潜在母畜(
      可袭击地点: 可袭击地点实体,
      类型配置: 地点类型配置数据,
      额外配置: 地点创建配置 = {}
    ): void {
      const 数量 = 额外配置.母畜数量 ?? 类型配置.母畜数量 ?? 5;
      const 身份分布 = 类型配置.身份分布 || { '平民': 1 };
  
      for (let i = 0; i < 数量; i++) {
        const 身份 = this.按权重选择(身份分布);
        const 母畜 = this.母畜工厂!.创建潜在母畜({
          身份,
          来源地点ID: 可袭击地点.实体ID,
        });
        可袭击地点.添加潜在母畜(母畜);
      }
    }
  
    private 按权重选择(权重对象: Record<string, number>): string {
      const 条目 = Object.entries(权重对象);
      const 总权重 = 条目.reduce((sum, [, w]) => sum + w, 0);
      let 随机值 = Math.random() * 总权重;
  
      for (const [选项, 权重] of 条目) {
        随机值 -= 权重;
        if (随机值 <= 0) return 选项;
      }
      return 条目[0]?.[0] ?? '平民';
    }
  
    private 生成地点名称(类型: string): string {
      const 类型配置 = this.地点类型配置.get(类型);
      const 前缀列表 = 类型配置?.前缀 ?? ['东'];
      const 中缀列表 = 类型配置?.中缀 ?? ['德'];
      const 后缀列表 = 类型配置?.后缀 ?? ['镇'];
  
      const 随机取 = <T>(arr: T[]): T => arr[Math.floor(Math.random() * arr.length)];
      return `${随机取(前缀列表)}${随机取(中缀列表)}${随机取(后缀列表)}`;
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 工厂管理器
  // ═══════════════════════════════════════════════════════════════
  
  class 工厂管理器 {
    readonly 冠军工厂: 冠军工厂;
    readonly 母畜工厂: 母畜工厂;
    readonly 领主工厂: 领主工厂;
    readonly 可袭击地点工厂: 可袭击地点工厂;
  
    constructor(运行时配置: 运行时配置 = {}) {
      this.冠军工厂 = new 冠军工厂(运行时配置.冠军配置);
      this.母畜工厂 = new 母畜工厂(运行时配置.母畜配置);
      this.领主工厂 = new 领主工厂(运行时配置.领主配置);
      this.可袭击地点工厂 = new 可袭击地点工厂(运行时配置.地点配置);
      this.可袭击地点工厂.设置母畜工厂(this.母畜工厂);
    }
  
    // ─── 工厂访问 ───
  
    获取冠军工厂(): 冠军工厂 {
      return this.冠军工厂;
    }
  
    获取母畜工厂(): 母畜工厂 {
      return this.母畜工厂;
    }
  
    获取领主工厂(): 领主工厂 {
      return this.领主工厂;
    }
  
    获取可袭击地点工厂(): 可袭击地点工厂 {
      return this.可袭击地点工厂;
    }
  
    // ─── 快捷创建方法 ───
  
    创建潜在母畜(配置: 母畜创建配置): 母畜实体 {
      return this.母畜工厂.创建潜在母畜(配置);
    }
  
    创建已捕获母畜(配置: 母畜创建配置): 母畜实体 {
      return this.母畜工厂.创建已捕获(配置);
    }
  
    创建领主(配置: 领主创建配置): 领主实体 {
      return this.领主工厂.创建领主(配置);
    }
  
    创建可袭击地点(类型: string, 配置: 地点创建配置): 可袭击地点实体 {
      return this.可袭击地点工厂.创建地点(类型, 配置);
    }
  
    从母畜生育哥布林冠军(母畜: 母畜实体, 选项: 生育选项): 生育结果 {
      return this.冠军工厂.从母畜生育(母畜, 选项);
    }
  
    // ─── 批量操作 ───
  
    批量创建潜在母畜(数量: number, 配置: 母畜创建配置): 母畜实体[] {
      return this.母畜工厂.批量创建潜在母畜(数量, 配置);
    }
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 导出
  // ═══════════════════════════════════════════════════════════════
  
  export {
    冠军工厂,
    母畜工厂,
    领主工厂,
    可袭击地点工厂,
    工厂管理器
  };
  
  export type {
    姓名池配置,
    属性系数,
    冠军工厂配置,
    生育选项,
    生育结果,
    生育属性预估,
    母畜工厂配置,
    母畜创建配置,
    领主工厂配置,
    领主创建配置,
    可袭击地点工厂配置,
    地点创建配置,
    地点类型配置数据,
    运行时配置
  };
  
```

```
// ═══════════════════════════════════════════════════════════════
// data/rules.ts
// 游戏规则配置实现
// ═══════════════════════════════════════════════════════════════

import {
    冠军实体,
    母畜实体,
    可袭击地点实体,
    领主实体,
    喽啰池
  } from '../core/entities';
  
  import { 工厂管理器 } from '../core/factories';
  
  // ═══════════════════════════════════════════════════════════════
  // 类型定义
  // ═══════════════════════════════════════════════════════════════
  
  type 实体类型 = 冠军实体 | 母畜实体 | 可袭击地点实体 | 领主实体 | 喽啰池;
  
  interface 游戏总控接口 {
    地点管理: {
      获取地点: (地点ID: string) => 可袭击地点实体 | null;
    };
    母畜管理: {
      从劝诱获取母畜: (母畜: 母畜实体) => void;
      移除母畜: (母畜ID: string) => void;
    };
    冠军管理: {
      从生育获取冠军: (冠军: 冠军实体) => void;
    };
    喽啰池管理: {
      获取喽啰总数: () => number;
      获取无将领喽啰池: () => 喽啰池;
    };
    资源管理: {
      获取士气: () => number;
      修改士气: (增量: number) => number;
      获取催淫母乳数量: () => number;
      修改催淫母乳数量: (增量: number) => number;
    };
    获取领主: () => 领主实体;
  }
  
  interface 属性变化记录 {
    [属性名: string]: [number | string, number | string];
  }
  
  interface 任务执行结果 {
    成功: boolean;
    类型: string;
    执行人: 实体类型;
    目标: 实体类型 | null;
    变化?: 属性变化记录;
    已侦察母畜?: 母畜实体[];
    已获取母畜?: 母畜实体[];
    已获取冠军?: 冠军实体[];
    原因?: string;
  }
  
  interface 商品执行结果 {
    成功: boolean;
    类型: string;
    目标: 实体类型 | null;
    信息?: string;
    变化?: 属性变化记录;
  }
  
  interface 法术执行结果 {
    成功: boolean;
    类型: string;
    目标: 实体类型 | null;
    变化?: 属性变化记录;
  }
  
  type 任务前置条件 = (执行人: 实体类型) => boolean;
  type 行动力占用计算 = (执行人: 实体类型) => number;
  type 任务执行效果 = (
    执行人: 实体类型,
    目标: 实体类型 | null,
    游戏总控?: 游戏总控接口
  ) => 任务执行结果;
  
  interface 任务配置 {
    名称: string;
    描述: string;
    前置条件?: 任务前置条件[];
    行动力占用?: 行动力占用计算;
    执行效果: 任务执行效果;
  }
  
  type 商品执行效果 = (
    购买数量: number,
    目标: 实体类型 | null,
    游戏总控: 游戏总控接口
  ) => 商品执行结果;
  
  interface 商品配置 {
    名称: string;
    价格: number;
    描述?: string;
    每周限购: number;
    执行效果: 商品执行效果;
  }
  
  type 法术执行效果 = (
    法术倍率: number,
    目标: 实体类型 | null,
    游戏总控: 游戏总控接口
  ) => 法术执行结果;
  
  interface 法术配置 {
    名称: string;
    价格: number;
    法术倍率上限: number;
    执行效果: 法术执行效果;
  }
  
  interface 任务系统接口 {
    注册任务: (任务名: string, 配置: 任务配置) => void;
  }
  
  interface 黑市系统接口 {
    注册商品: (商品名: string, 配置: 商品配置) => void;
  }
  
  interface 法术系统接口 {
    注册法术: (法术名: string, 配置: 法术配置) => void;
  }
  
  // ═══════════════════════════════════════════════════════════════
  // 规则初始化函数
  // ═══════════════════════════════════════════════════════════════
  
  export function 初始化规则(
    工厂管理器实例: 工厂管理器,
    任务系统: 任务系统接口,
    黑市系统: 黑市系统接口,
    法术系统: 法术系统接口
  ): void {
    // ─── 辅助函数 ───
    const min = Math.min;
    const floor = Math.floor;
  
    // ─── 数组洗牌工具 ───
    const shuffleArray = <T>(array: T[]): T[] => {
      const result = [...array];
      for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
      }
      return result;
    };
  
    // ═══════════════════════════════════════════════════════════════
    // 任务配置
    // ═══════════════════════════════════════════════════════════════
  
    任务系统.注册任务('调教', {
      名称: '调教',
      描述: '冠军对母畜进行调教，提升其臣服度',
      前置条件: [(执行人) => 执行人.实体类型 === '冠军'],
      行动力占用: (_执行人) => 1,
      执行效果: (执行人, 目标母畜, _游戏总控) => {
        const 冠军 = 执行人 as 冠军实体;
        const 母畜 = 目标母畜 as 母畜实体;
  
        const 初始值 = 母畜.获取属性<number>('臣服度');
        const 智力 = 冠军.获取属性<number>('智力');
        const 增量 = floor(智力 / 10) + 5;
        const 新值 = 母畜.修改属性('臣服度', 增量);
  
        return {
          成功: true,
          类型: '调教',
          执行人: 冠军,
          目标: 母畜,
          变化: { 臣服度: [初始值, 新值] },
        };
      },
    });
  
    任务系统.注册任务('劝慰', {
      名称: '劝慰',
      描述: '母畜对其他母畜进行劝慰，提升其臣服度',
      前置条件: [
        (执行人) => 执行人.实体类型 === '母畜',
        (执行人) => (执行人 as 母畜实体).获取属性<number>('臣服度') >= 50,
      ],
      行动力占用: (_执行人) => 1,
      执行效果: (执行人, 目标母畜, _游戏总控) => {
        const 执行母畜 = 执行人 as 母畜实体;
        const 目标 = 目标母畜 as 母畜实体;
  
        const 初始值 = 目标.获取属性<number>('臣服度');
        const 基础值 = 10;
        const 种族A = 执行母畜.获取属性<string>('种族');
        const 种族B = 目标.获取属性<string>('种族');
        const 系数 = 种族A === 种族B ? 1.5 : 1;
        const 增量 = floor(基础值 * 系数);
        const 新值 = 目标.修改属性('臣服度', 增量);
  
        return {
          成功: true,
          类型: '劝慰',
          执行人: 执行母畜,
          目标: 目标,
          变化: { 臣服度: [初始值, 新值] },
        };
      },
    });
  
    任务系统.注册任务('侦察', {
      名称: '侦察',
      描述: '侦察地点，获取地点内可被侦察的母畜信息',
      前置条件: [(执行人) => 执行人.实体类型 === '冠军'],
      执行效果: (执行人, 目标地点, _游戏总控) => {
        const 冠军 = 执行人 as 冠军实体;
        const 地点 = 目标地点 as 可袭击地点实体;
  
        const 敏捷 = 冠军.获取属性<number>('敏捷');
        const 成功率 = (敏捷 + 50) / 100;
  
        if (Math.random() > 成功率) {
          return {
            成功: false,
            类型: '侦察',
            执行人: 冠军,
            目标: 地点,
          };
        }
  
        const 初始进度 = 地点.获取侦察进度();
  
        // 进度增加
        const 进度增量 = (敏捷 + 50) / 10;
        const 当前进度 = 地点.增加侦察进度(进度增量);
  
        // 侦察逻辑
        const 因子 = (敏捷 + 50) * (当前进度 + 25);
        const 必定侦察数 = floor(因子 / 7500);
        const 额外概率 = (因子 % 7500) / 7500;
  
        let 侦察母畜总数 = 必定侦察数 + (Math.random() < 额外概率 ? 1 : 0);
        const 可侦察母畜列表 = 地点.获取潜在母畜列表();
        const 随机索引数组 = shuffleArray([...Array(可侦察母畜列表.length).keys()]);
  
        // 执行地点实体内部的侦察逻辑
        const 被侦察母畜列表: 母畜实体[] = [];
        for (let i = 0; i < 侦察母畜总数 && i < 可侦察母畜列表.length; i++) {
          const 被侦察母畜 = 可侦察母畜列表[随机索引数组[i]];
          地点.标记母畜已侦察(被侦察母畜);
          被侦察母畜列表.push(被侦察母畜);
        }
  
        return {
          成功: true,
          类型: '侦察',
          执行人: 冠军,
          目标: 地点,
          变化: { 侦察进度: [初始进度, 当前进度]},
          已侦察母畜: 被侦察母畜列表,
        };
      },
    });
  
    任务系统.注册任务('潜入侦察', {
      名称: '潜入侦察',
      描述: '母畜潜入地点，获取地点内可被侦察的母畜信息',
      前置条件: [
        (执行人) => 执行人.实体类型 === '母畜',
        (执行人) => (执行人 as 母畜实体).获取属性<number>('臣服度') >= 75,
      ],
      行动力占用: (_执行人) => 1,
      执行效果: (执行人, 目标地点, _游戏总控) => {
        const 母畜 = 执行人 as 母畜实体;
        const 地点 = 目标地点 as 可袭击地点实体;
  
        const 淫乱度 = 母畜.获取属性<number>('淫乱度');
        const 成功率 = (125 - 淫乱度) / 100;
  
        if (Math.random() > 成功率) {
          return {
            成功: false,
            类型: '潜入侦察',
            执行人: 母畜,
            目标: 地点,
          };
        }
  
        const 初始进度 = 地点.获取侦察进度();
  
        // 进度增加
        const 进度增量 = (125 - 淫乱度) / 10;
        const 当前进度 = 地点.增加侦察进度(进度增量);
  
        // 侦察逻辑
        const 因子 = (125 - 淫乱度) * (当前进度 + 25);
        const 必定侦察数 = floor(因子 / 7500);
        const 额外概率 = (因子 % 7500) / 7500;
  
        let 侦察母畜总数 = 必定侦察数 + (Math.random() < 额外概率 ? 1 : 0);
        const 可侦察母畜列表 = 地点.获取潜在母畜列表();
        const 随机索引数组 = shuffleArray([...Array(可侦察母畜列表.length).keys()]);
  
        // 执行地点实体内部的侦察逻辑
        const 被侦察母畜列表: 母畜实体[] = [];
        for (let i = 0; i < 侦察母畜总数 && i < 可侦察母畜列表.length; i++) {
          const 被侦察母畜 = 可侦察母畜列表[随机索引数组[i]];
          地点.标记母畜已侦察(被侦察母畜);
          被侦察母畜列表.push(被侦察母畜);
        }
  
        return {
          成功: true,
          类型: '潜入侦察',
          执行人: 母畜,
          目标: 地点,
          变化: { 侦察进度: [初始进度, 当前进度]},
          已侦察母畜: 被侦察母畜列表,
        };
      },
    });
  
    任务系统.注册任务('潜入劝诱', {
      名称: '潜入劝诱',
      描述: '母畜潜入地点，尝试与目标母畜进行劝诱',
      前置条件: [
        (执行人) => 执行人.实体类型 === '母畜',
        (执行人) => (执行人 as 母畜实体).获取属性<number>('臣服度') >= 90,
      ],
      行动力占用: (_执行人) => 1,
      执行效果: (执行人, 目标母畜, 游戏总控) => {
        const 执行母畜 = 执行人 as 母畜实体;
        const 目标 = 目标母畜 as 母畜实体;
  
        const 淫乱度 = 执行母畜.获取属性<number>('淫乱度');
        const 自身总雌性价值 = 执行母畜.获取属性<number>('总雌性价值');
        const 目标总雌性价值 = 目标.获取属性<number>('总雌性价值');
        const 目标地点 = 游戏总控!.地点管理.获取地点(目标.来源地点ID!);
        const 成功率 = ((目标总雌性价值 - 自身总雌性价值 + 50) * (125 - 淫乱度)) / 1000;
  
        if (Math.random() > 成功率) {
          return {
            成功: false,
            类型: '潜入劝诱',
            执行人: 执行母畜,
            目标: 目标,
          };
        }
  
        目标地点!.移除已捕获母畜(目标);
        游戏总控!.母畜管理.从劝诱获取母畜(目标);
  
        return {
          成功: true,
          类型: '潜入劝诱',
          执行人: 执行母畜,
          目标: 目标,
          已获取母畜: [目标],
        };
      },
    });
  
    任务系统.注册任务('生育哥布林冠军', {
      名称: '生育哥布林冠军',
      描述: '母畜生育哥布林冠军',
      前置条件: [
        (执行人) => 执行人.实体类型 === '母畜',
        (执行人) => (执行人 as 母畜实体).获取属性<number>('剩余雌性价值') >= 100,
      ],
      行动力占用: (执行人) =>
        (执行人 as 母畜实体).获取属性<number>('臣服度') >= 25 ? 1 : 2,
      执行效果: (执行人, _无, 游戏总控) => {
        const 母畜 = 执行人 as 母畜实体;
  
        // 调用 工厂管理器.从母畜生育哥布林冠军
        const 结果 = 工厂管理器实例.从母畜生育哥布林冠军(母畜, {});
        const 初始淫乱度 = 母畜.获取属性<number>('淫乱度');
  
        // 消耗扣除由工厂处理，这里处理副作用
        if (结果.成功 && 结果.冠军) {
          母畜.修改属性('淫乱度', 6);
          // 冠军加入玩家阵营逻辑
          游戏总控!.冠军管理.从生育获取冠军(结果.冠军);
  
          return {
            成功: true,
            类型: '生育哥布林冠军',
            执行人: 母畜,
            目标: null,
            变化: {
              淫乱度: [初始淫乱度, 母畜.获取属性<number>('淫乱度')],
            },
            已获取冠军: [结果.冠军]
          };
        }
  
        return {
          成功: false,
          类型: '生育哥布林冠军',
          执行人: 母畜,
          目标: null,
        };
      },
    });
  
    任务系统.注册任务('生育喽啰', {
      名称: '生育喽啰',
      描述: '母畜生育喽啰',
      前置条件: [
        (执行人) => 执行人.实体类型 === '母畜',
        (执行人) => (执行人 as 母畜实体).获取属性<number>('剩余雌性价值') >= 10,
      ],
      行动力占用: (执行人) =>
        (执行人 as 母畜实体).获取属性<number>('臣服度') >= 25 ? 0 : 1,
      执行效果: (执行人, _无, 游戏总控) => {
        const 母畜 = 执行人 as 母畜实体;
  
        const 初始喽啰数量 = 游戏总控!.喽啰池管理.获取喽啰总数();
        const 初始淫乱度 = 母畜.获取属性<number>('淫乱度');
        const 价值 = 母畜.获取属性<number>('剩余雌性价值');
        const 数量 = min(10, floor(价值 / 10));
  
        母畜.消耗雌性价值(数量 * 10);
        母畜.修改属性('淫乱度', 6);
  
        // 增加喽啰池
        const 目标喽啰池 = 游戏总控!.喽啰池管理.获取无将领喽啰池();
        目标喽啰池.增加喽啰(数量, '未武装');
  
        return {
          成功: true,
          类型: '生育喽啰',
          执行人: 母畜,
          目标: null,
          变化: {
            喽啰数量: [初始喽啰数量, 游戏总控!.喽啰池管理.获取喽啰总数()],
            淫乱度: [初始淫乱度, 母畜.获取属性<number>('淫乱度')],
          },
        };
      },
    });
  
    任务系统.注册任务('提振士气', {
      名称: '提振士气',
      描述: '母畜提振全军士气',
      前置条件: [
        (执行人) => 执行人.实体类型 === '母畜',
        (执行人) => (执行人 as 母畜实体).获取属性<number>('臣服度') >= 75,
      ],
      行动力占用: (_执行人) => 1,
      执行效果: (执行人, _无, 游戏总控) => {
        const 母畜 = 执行人 as 母畜实体;
  
        const 初始士气 = 游戏总控!.资源管理.获取士气();
        const 初始淫乱度 = 母畜.获取属性<number>('淫乱度');
        const 价值 = 母畜.获取属性<number>('总雌性价值');
        const 增量 = (价值 + 50) / 25;
        const 当前士气 = 游戏总控!.资源管理.修改士气(增量);
        母畜.修改属性('淫乱度', 10);
  
        return {
          成功: true,
          类型: '提振士气',
          执行人: 母畜,
          目标: null,
          变化: {
            士气: [初始士气, 当前士气],
            淫乱度: [初始淫乱度, 母畜.获取属性<number>('淫乱度')],
          },
        };
      },
    });
  
    任务系统.注册任务('泌乳', {
      名称: '泌乳',
      描述: '母畜泌乳',
      前置条件: [
        (执行人) => 执行人.实体类型 === '母畜',
        (执行人) => (执行人 as 母畜实体).获取属性<number>('淫乱度') >= 25,
      ],
      行动力占用: (执行人) =>
        (执行人 as 母畜实体).获取属性<number>('臣服度') >= 50 ? 0 : 1,
      执行效果: (执行人, _无, 游戏总控) => {
        const 母畜 = 执行人 as 母畜实体;
  
        const 初始淫乱度 = 母畜.获取属性<number>('淫乱度');
        const 初始催淫母乳数量 = 游戏总控!.资源管理.获取催淫母乳数量();
        const 淫乱 = 母畜.获取属性<number>('淫乱度');
        const 产出 = floor((淫乱 + 20) / 10);
        const 当前催淫母乳数量 = 游戏总控!.资源管理.修改催淫母乳数量(产出);
        母畜.修改属性('淫乱度', 3);
  
        return {
          成功: true,
          类型: '泌乳',
          执行人: 母畜,
          目标: null,
          变化: {
            催淫母乳数量: [初始催淫母乳数量, 当前催淫母乳数量],
            淫乱度: [初始淫乱度, 母畜.获取属性<number>('淫乱度')],
          },
        };
      },
    });
  
    任务系统.注册任务('献祭', {
      名称: '献祭',
      描述: '献祭母畜以获取魔力',
      行动力占用: (_执行人) => 0,
      前置条件: [
        (执行人) => 执行人.实体类型 === '母畜',
        (执行人) => (执行人 as 母畜实体).获取属性<number>('淫乱度') >= 100,
      ],
      执行效果: (执行人, _无, 游戏总控) => {
        const 母畜 = 执行人 as 母畜实体;
  
        const 价值 = 母畜.获取属性<number>('总雌性价值');
        const 魔力增量 = floor((价值 + 50) / 50);
  
        const 领主 = 游戏总控!.获取领主();
        const 初始魔力 = 领主.获取属性<number>('魔力');
        领主.获得魔力(魔力增量);
  
        游戏总控!.母畜管理.移除母畜(母畜.实体ID);
        母畜.销毁();
  
        return {
          成功: true,
          类型: '献祭',
          执行人: 母畜,
          目标: null,
          变化: { 魔力: [初始魔力, 领主.获取属性<number>('魔力')] },
        };
      },
    });
  
    // ═══════════════════════════════════════════════════════════════
    // 黑市商品配置
    // ═══════════════════════════════════════════════════════════════
  
    const 武装升级效果 = (
      数量: number,
      等级: string,
      游戏总控: 游戏总控接口
    ) => (目标喽啰池: 喽啰池): 商品执行结果 => {
      // 优先列表定义
      const 优先 = ['未武装', '低级武装', '中级武装', '高级武装', '精英武装'];
      const 溢出数量 = 目标喽啰池.武装升级(数量, 等级, 优先).溢出数量;
      const 将领 = 目标喽啰池.获取将领();
      const 初始战斗力 = 目标喽啰池.获取战斗力();
  
      if (将领 && 溢出数量 > 0) {
        const 无将领喽啰池 = 游戏总控.喽啰池管理.获取无将领喽啰池();
        const 再次溢出数量 = 无将领喽啰池.武装升级(溢出数量, 等级, 优先).溢出数量;
  
        return {
          成功: true,
          类型: '武装升级',
          目标: 目标喽啰池,
          信息: `${数量 - 再次溢出数量} 名喽啰已升级到 ${等级} 等级，${再次溢出数量} 份武装因无喽啰可升级舍弃`,
          变化: { 战斗力: [初始战斗力, 目标喽啰池.获取战斗力()] },
        };
      }
  
      if (溢出数量 > 0) {
        return {
          成功: true,
          类型: '武装升级',
          目标: 目标喽啰池,
          信息: `${数量 - 溢出数量} 名喽啰已升级到 ${等级} 等级，${溢出数量} 份武装因无喽啰可升级舍弃`,
          变化: { 战斗力: [初始战斗力, 目标喽啰池.获取战斗力()] },
        };
      }
  
      return {
        成功: true,
        类型: '武装升级',
        目标: 目标喽啰池,
        信息: `${数量} 名喽啰已升级到 ${等级} 等级`,
        变化: { 战斗力: [初始战斗力, 目标喽啰池.获取战斗力()] },
      };
    };
  
    黑市系统.注册商品('破旧兵刃', {
      名称: '破旧兵刃',
      价格: 1,
      描述: '勉强能用的武器和护甲，聊胜于无，可以武装10名喽啰',
      每周限购: Infinity,
      执行效果: (购买数量, 目标喽啰池, 游戏总控) =>
        武装升级效果(10 * 购买数量, '低级武装', 游戏总控)(目标喽啰池 as 喽啰池),
    });
  
    黑市系统.注册商品('标准铁剑', {
      名称: '标准铁剑',
      价格: 1,
      描述: '正规军队的标准装备，可靠耐用，可以武装4名喽啰',
      每周限购: Infinity,
      执行效果: (购买数量, 目标喽啰池, 游戏总控) =>
        武装升级效果(4 * 购买数量, '中级武装', 游戏总控)(目标喽啰池 as 喽啰池),
    });
  
    黑市系统.注册商品('骑士武装', {
      名称: '骑士武装',
      价格: 1,
      描述: '通过特殊渠道走私的骑士装备，品质上乘，可以武装1名喽啰',
      每周限购: Infinity,
      执行效果: (购买数量, 目标喽啰池, 游戏总控) =>
        武装升级效果(1 * 购买数量, '高级武装', 游戏总控)(目标喽啰池 as 喽啰池),
    });
  
    黑市系统.注册商品('附魔装备', {
      名称: '附魔装备',
      价格: 4,
      描述: '非常罕见的附魔装备，极大提升喽啰战斗力，可以武装1名喽啰',
      每周限购: Infinity,
      执行效果: (购买数量, 目标喽啰池, 游戏总控) =>
        武装升级效果(1 * 购买数量, '精英武装', 游戏总控)(目标喽啰池 as 喽啰池),
    });
  
    黑市系统.注册商品('祝福水晶', {
      名称: '祝福水晶',
      价格: 50,
      每周限购: 1,
      执行效果: (购买数量, 目标母畜, _游戏总控) => {
        const 母畜 = 目标母畜 as 母畜实体;
  
        const 淫乱 = 母畜.获取属性<number>('淫乱度');
        const 增量 = (购买数量 * 2000) / (淫乱 + 20);
        const 初始总雌性价值 = 母畜.获取属性<number>('总雌性价值');
        const 初始剩余雌性价值 = 母畜.获取属性<number>('剩余雌性价值');
        母畜.修改属性('总雌性价值', 增量);
        母畜.修改属性('剩余雌性价值', 增量);
  
        return {
          成功: true,
          类型: '祝福水晶',
          目标: 母畜,
          变化: {
            总雌性价值: [初始总雌性价值, 母畜.获取属性<number>('总雌性价值')],
            剩余雌性价值: [初始剩余雌性价值, 母畜.获取属性<number>('剩余雌性价值')],
          },
        };
      },
    });
  
    黑市系统.注册商品('净化水晶', {
      名称: '净化水晶',
      价格: 25,
      每周限购: 5,
      执行效果: (购买数量, 目标母畜, _游戏总控) => {
        const 母畜 = 目标母畜 as 母畜实体;
  
        const 初始淫乱 = 母畜.获取属性<number>('淫乱度');
        const 新值 = 母畜.修改属性('淫乱度', -10 * 购买数量);
  
        return {
          成功: true,
          类型: '净化水晶',
          目标: 母畜,
          变化: { 淫乱度: [初始淫乱, 新值] },
        };
      },
    });
  
    黑市系统.注册商品('魔力水晶', {
      名称: '魔力水晶',
      价格: 15,
      每周限购: 1,
      执行效果: (购买数量, _无, 游戏总控) => {
        const 领主 = 游戏总控.获取领主();
        const 初始魔力 = 领主.获取属性<number>('魔力');
        const 结果 = 领主.获得魔力(3 * 购买数量);
  
        return {
          成功: true,
          类型: '魔力水晶',
          目标: null,
          变化: { 领主魔力: [初始魔力, 结果.当前] },
        };
      },
    });
  
    // ═══════════════════════════════════════════════════════════════
    // 法术配置
    // ═══════════════════════════════════════════════════════════════
  
    法术系统.注册法术('魔眼侦察', {
      名称: '魔眼侦察',
      价格: 1,
      法术倍率上限: 3,
      执行效果: (法术倍率, 目标地点, _游戏总控) => {
        const 地点 = 目标地点 as 可袭击地点实体;
  
        const 初始侦察进度 = 地点.获取侦察进度();
        const 新值 = 地点.增加侦察进度(20 * 法术倍率);
  
        return {
          成功: true,
          类型: '魔眼侦察',
          目标: 地点,
          变化: { 侦察进度: [初始侦察进度, 新值] },
        };
      },
    });
  
    法术系统.注册法术('意志粉碎', {
      名称: '意志粉碎',
      价格: 1,
      法术倍率上限: 3,
      执行效果: (法术倍率, 目标母畜, _游戏总控) => {
        const 母畜 = 目标母畜 as 母畜实体;
  
        const 初始臣服 = 母畜.获取属性<number>('臣服度');
        const 新值 = 母畜.修改属性('臣服度', 10 * 法术倍率);
  
        return {
          成功: true,
          类型: '意志粉碎',
          目标: 母畜,
          变化: { 臣服度: [初始臣服, 新值] },
        };
      },
    });
  
    法术系统.注册法术('孕力回复', {
      名称: '孕力回复',
      价格: 10,
      法术倍率上限: 3,
      执行效果: (法术倍率, 目标母畜, _游戏总控) => {
        const 母畜 = 目标母畜 as 母畜实体;
  
        const 初始剩余雌性价值 = 母畜.获取属性<number>('剩余雌性价值');
        const 新值 = 母畜.修改属性('剩余雌性价值', 50 * 法术倍率);
  
        return {
          成功: true,
          类型: '孕力回复',
          目标: 母畜,
          变化: { 剩余雌性价值: [初始剩余雌性价值, 新值] },
        };
      },
    });
  
    法术系统.注册法术('士气鼓舞', {
      名称: '士气鼓舞',
      价格: 5,
      法术倍率上限: 3,
      执行效果: (法术倍率, _无, 游戏总控) => {
        const 初始士气 = 游戏总控.资源管理.获取士气();
        const 新值 = 游戏总控.资源管理.修改士气(30 * 法术倍率);
  
        return {
          成功: true,
          类型: '士气鼓舞',
          目标: null,
          变化: { 士气: [初始士气, 新值] },
        };
      },
    });
  }
  
```

