// ═══════════════════════════════════════════════════════════════
// core/combat.ts
// 战斗系统 - 喽啰调配与战斗调度
// ═══════════════════════════════════════════════════════════════

import { 冠军实体, 喽啰池, 可袭击地点实体 } from './entities';
import { 任务管理器 } from './managers';

// ═══════════════════════════════════════════════════════════════
// 类型定义
// ═══════════════════════════════════════════════════════════════

type 武装等级 = '未武装' | '低级武装' | '中级武装' | '高级武装' | '精英武装';


interface 分配请求 {
    武装等级: 武装等级;
    数量: number;
}

interface 分配结果 {
    成功: boolean;
    原因?: string;
    实际分配: number;
    分配详情: Array<{ 等级: string; 数量: number }>;
}

interface 战斗部署 {
    将领ID: string;
    将领: 冠军实体;
    喽啰池: 喽啰池;
    战斗力: number;
}

interface 战斗配置 {
    目标地点: 可袭击地点实体;
    部署列表: 战斗部署[];
    是否突袭: boolean;
    总行动力消耗: number;
}

interface 战斗结果 {
    成功: boolean;
    胜利: boolean;
    原因?: string;
    我方战斗力: number;
    敌方战斗力: number;
    战损比例?: number;
    俘获母畜?: string[];
    战利品?: Record<string, number>;
}

interface 快速填充结果 {
    成功: boolean;
    原因?: string;
    填充数量: number;
    当前战斗力: number;
    填充详情: Array<{ 等级: string; 数量: number }>;
}

interface 喽啰池管理接口 {
    获取无将领喽啰池: () => 喽啰池;
    获取所有将领喽啰池: () => Map<string, 喽啰池>;
}

interface 战斗系统依赖 {
    任务管理器: 任务管理器;
    喽啰池管理: 喽啰池管理接口;
    获取将领: (将领ID: string) => 冠军实体 | null;
    获取地点: (地点ID: string) => 可袭击地点实体 | null;
}

// ═══════════════════════════════════════════════════════════════
// 喽啰调配器
// ═══════════════════════════════════════════════════════════════

class 喽啰调配器 {
    private 喽啰池管理: 喽啰池管理接口;
    private 武装优先级: 武装等级[];

    constructor(喽啰池管理: 喽啰池管理接口) {
        this.喽啰池管理 = 喽啰池管理;
        // 按战斗力从高到低排序
        this.武装优先级 = ['精英武装', '高级武装', '中级武装', '低级武装', '未武装'];
    }

    // ─── 获取喽啰池状态 ───

    获取无将领喽啰池(): 喽啰池 {
        return this.喽啰池管理.获取无将领喽啰池();
    }

    获取将领喽啰池(将领: 冠军实体): 喽啰池 | null {
        return 将领.获取喽啰池();
    }

    // ─── 基础分配操作 ───


    /**
     * 从无将领池向将领池分配喽啰
     */
    分配到将领(将领: 冠军实体, 请求列表: 分配请求[]): 分配结果 {
        const 目标池 = 将领.获取喽啰池();
        if (!目标池) {
            return { 成功: false, 原因: '将领未绑定喽啰池', 实际分配: 0, 分配详情: [] };
        }

        const 无将领池 = this.获取无将领喽啰池();
        const 可用容量 = 目标池.获取最大数量() - 目标池.获取总数量();

        if (可用容量 <= 0) {
            return { 成功: false, 原因: '将领喽啰池已满', 实际分配: 0, 分配详情: [] };
        }

        let 总分配 = 0;
        const 分配详情: Array<{ 等级: string; 数量: number }> = [];

        for (const 请求 of 请求列表) {
            const 剩余容量 = 可用容量 - 总分配;
            if (剩余容量 <= 0) break;

            const 实际需求 = Math.min(请求.数量, 剩余容量);
            const 来源数量 = 无将领池.获取分组数量(请求.武装等级);
            const 实际分配数量 = Math.min(实际需求, 来源数量);

            if (实际分配数量 > 0) {
                无将领池.减少喽啰(实际分配数量, 请求.武装等级);
                目标池.增加喽啰(实际分配数量, 请求.武装等级);
                总分配 += 实际分配数量;
                分配详情.push({ 等级: 请求.武装等级, 数量: 实际分配数量 });
            }
        }

        return {
            成功: 总分配 > 0,
            实际分配: 总分配,
            分配详情,
        };
    }

    /**
     * 从将领池向无将领池归还喽啰
     */
    归还到公共池(将领: 冠军实体, 请求列表: 分配请求[]): 分配结果 {
        const 来源池 = 将领.获取喽啰池();
        if (!来源池) {
            return { 成功: false, 原因: '将领未绑定喽啰池', 实际分配: 0, 分配详情: [] };
        }

        const 无将领池 = this.获取无将领喽啰池();
        let 总归还 = 0;
        const 分配详情: Array<{ 等级: string; 数量: number }> = [];

        for (const 请求 of 请求列表) {
            const 来源数量 = 来源池.获取分组数量(请求.武装等级);
            const 实际归还数量 = Math.min(请求.数量, 来源数量);

            if (实际归还数量 > 0) {
                来源池.减少喽啰(实际归还数量, 请求.武装等级);
                无将领池.增加喽啰(实际归还数量, 请求.武装等级);
                总归还 += 实际归还数量;
                分配详情.push({ 等级: 请求.武装等级, 数量: 实际归还数量 });
            }
        }

        return {
            成功: 总归还 > 0,
            实际分配: 总归还,
            分配详情,
        };
    }

    /**
     * 清空将领喽啰池，全部归还公共池
     */
    清空将领喽啰池(将领: 冠军实体): 分配结果 {
        const 来源池 = 将领.获取喽啰池();
        if (!来源池) {
            return { 成功: false, 原因: '将领未绑定喽啰池', 实际分配: 0, 分配详情: [] };
        }

        const 分组详情 = 来源池.获取分组详情();
        const 请求列表: 分配请求[] = 分组详情
            .filter(分组 => 分组.数量 > 0)
            .map(分组 => ({ 武装等级: 分组.等级, 数量: 分组.数量 }));

        return this.归还到公共池(将领, 请求列表);
    }

    // ─── 快速填充（最大化战斗力）───

    /**
     * 快速填充将领喽啰池至上限，优先选择高战斗力武装
     */
    快速填充到上限(将领: 冠军实体): 快速填充结果 {
        const 目标池 = 将领.获取喽啰池();
        if (!目标池) {
            return { 成功: false, 原因: '将领未绑定喽啰池', 填充数量: 0, 当前战斗力: 0, 填充详情: [] };
        }

        const 无将领池 = this.获取无将领喽啰池();
        const 最大容量 = 目标池.获取最大数量();
        const 当前数量 = 目标池.获取总数量();
        let 剩余容量 = 最大容量 - 当前数量;

        if (剩余容量 <= 0) {
            return {
                成功: true,
                原因: '喽啰池已满',
                填充数量: 0,
                当前战斗力: 目标池.获取战斗力(),
                填充详情: [],
            };
        }

        const 填充详情: Array<{ 等级: string; 数量: number }> = [];
        let 总填充 = 0;

        // 按战斗力优先级填充
        for (const 武装等级 of this.武装优先级) {
            if (剩余容量 <= 0) break;

            const 可用数量 = 无将领池.获取分组数量(武装等级);
            const 填充数量 = Math.min(可用数量, 剩余容量);

            if (填充数量 > 0) {
                无将领池.减少喽啰(填充数量, 武装等级);
                目标池.增加喽啰(填充数量, 武装等级);
                剩余容量 -= 填充数量;
                总填充 += 填充数量;
                填充详情.push({ 等级: 武装等级, 数量: 填充数量 });
            }
        }

        return {
            成功: true,
            填充数量: 总填充,
            当前战斗力: 目标池.获取战斗力(),
            填充详情,
        };
    }

    /**
     * 优化将领喽啰池配置（替换低级武装为高级武装）
     */
    优化战斗力配置(将领: 冠军实体): 快速填充结果 {
        // 先清空再重新填充，确保最优配置
        this.清空将领喽啰池(将领);
        return this.快速填充到上限(将领);
    }

    // ─── 查询方法 ───

    获取分配预览(将领: 冠军实体): {
        当前数量: number;
        最大数量: number;
        当前战斗力: number;
        分组详情: Array<{ 等级: string; 数量: number; 战斗力: number }>;
    } | null {
        const 目标池 = 将领.获取喽啰池();
        if (!目标池) return null;

        return {
            当前数量: 目标池.获取总数量(),
            最大数量: 目标池.获取最大数量(),
            当前战斗力: 目标池.获取战斗力(),
            分组详情: 目标池.获取分组详情().map(分组 => ({
                等级: 分组.等级,
                数量: 分组.数量,
                战斗力: 分组.战斗力,
            })),
        };
    }

    获取公共池状态(): {
        总数量: number;
        分组详情: Array<{ 等级: string; 数量: number; 战斗力: number }>;
    } {
        const 无将领池 = this.获取无将领喽啰池();
        return {
            总数量: 无将领池.获取总数量(),
            分组详情: 无将领池.获取分组详情().map(分组 => ({
                等级: 分组.等级,
                数量: 分组.数量,
                战斗力: 分组.战斗力,
            })),
        };
    }
}

// ═══════════════════════════════════════════════════════════════
// 战斗管理器
// ═══════════════════════════════════════════════════════════════

class 战斗管理器 {
    private 依赖: 战斗系统依赖;
    private 喽啰调配器实例: 喽啰调配器;
    private 当前部署: Map<string, 战斗部署>;
    private 选定目标: 可袭击地点实体 | null;
    private 突袭模式: boolean;

    // 常量配置
    private static readonly 普通出战行动力 = 3;
    private static readonly 突袭出战行动力 = 2;
    private static readonly 突袭战力系数 = 0.8;

    constructor(依赖: 战斗系统依赖) {
        this.依赖 = 依赖;
        this.喽啰调配器实例 = new 喽啰调配器(依赖.喽啰池管理);
        this.当前部署 = new Map();
        this.选定目标 = null;
        this.突袭模式 = false;
    }

    // ─── 喽啰调配器访问 ───

    获取喽啰调配器(): 喽啰调配器 {
        return this.喽啰调配器实例;
    }

    // ─── 目标选择 ───

    选择目标(地点输入: 可袭击地点实体 | string): { 成功: boolean; 原因?: string } {
        let 地点: 可袭击地点实体 | null = null;
        if (typeof 地点输入 === 'string') { 
            地点 = this.依赖.获取地点(地点输入);
        } else { 
            地点 = 地点输入;
        }

        if (!地点) {
            return { 成功: false, 原因: '地点不存在' };
        }

        this.选定目标 = 地点;
        return { 成功: true };
    }

    取消目标选择(): void {
        this.选定目标 = null;
    }

    获取选定目标(): 可袭击地点实体 | null {
        return this.选定目标;
    }

    // ─── 突袭模式 ───

    设置突袭模式(启用: boolean): void {
        this.突袭模式 = 启用;
    }

    获取突袭模式(): boolean {
        return this.突袭模式;
    }

    // ─── 将领部署 ───

    /**
     * 添加将领到出战列表
     */
    添加出战将领(将领输入: 冠军实体 | string): { 成功: boolean; 原因?: string } {
        let 将领: 冠军实体 | null;
        try {
            将领 = typeof 将领输入 == 'string' ? this.依赖.获取将领(将领输入) : 将领输入;
        } catch (error) {
            return { 成功: false, 原因: '获取将领时发生错误' };
        }

        if (!将领) {
            return { 成功: false, 原因: '将领不存在' };
        }


        // 检查是否已部署
        if (this.当前部署.has(将领.实体ID)) {
            return { 成功: false, 原因: '将领已在出战列表中' };
        }

        // 检查任务系统占用
        if (this.依赖.任务管理器.执行人是否被占用(将领.实体ID)) {
            return { 成功: false, 原因: '将领在任务系统中被占用' };
        }

        // 检查是否有喽啰池
        const 喽啰池 = 将领.获取喽啰池();
        if (!喽啰池) {
            return { 成功: false, 原因: '将领未绑定喽啰池' };
        }

        this.依赖.任务管理器.占用实体(将领);

        // 计算战斗力
        const 基础战斗力 = 喽啰池.获取战斗力();
        const 实际战斗力 = this.突袭模式 ? 基础战斗力 * 战斗管理器.突袭战力系数 : 基础战斗力;

        this.当前部署.set(将领.实体ID, {
            将领ID: 将领.实体ID,
            将领,
            喽啰池,
            战斗力: 实际战斗力,
        });

        return { 成功: true };
    }

    /**
     * 从出战列表移除将领
     */
    移除出战将领(将领输入: 冠军实体 | string): { 成功: boolean; 原因?: string } {
        let 将领: 冠军实体 | null;
        try {
            将领 = typeof 将领输入 == 'string' ? this.依赖.获取将领(将领输入) : 将领输入;
        } catch (error) {
            return { 成功: false, 原因: '获取将领时发生错误' };
        }
        if (!将领) {
            return { 成功: false, 原因: '将领不存在' };
        }
        const 将领ID = 将领.实体ID;
        if (!this.当前部署.has(将领ID)) {
            return { 成功: false, 原因: '将领不在出战列表中' };
        }

        this.当前部署.delete(将领ID);
        if (将领) {
            this.依赖.任务管理器.释放实体(将领);
        }
        return { 成功: true };
    }

    /**
     * 清空出战列表
     */
    清空出战列表(): void {
        this.当前部署.forEach(战斗部署 => {
            this.移除出战将领(战斗部署.将领ID);
        });
    }

    // ─── 查询方法 ───

    获取当前部署列表(): 战斗部署[] {
        return Array.from(this.当前部署.values());
    }

    获取可出战将领(所有将领: 冠军实体[]): 冠军实体[] {
        return 所有将领.filter(将领 => {
            // 未被任务占用
            if (this.依赖.任务管理器.执行人是否被占用(将领.实体ID)) return false;
            // 未在当前部署中
            if (this.当前部署.has(将领.实体ID)) return false;
            // 有喽啰池
            if (!将领.获取喽啰池()) return false;
            return true;
        });
    }

    计算总战斗力(): number {
        let 总战力 = 0;
        for (const 部署 of this.当前部署.values()) {
            总战力 += 部署.战斗力;
        }
        return 总战力;
    }

    计算行动力消耗(): number {
        if (this.当前部署.size === 0) return 0;
        return this.突袭模式 ? 战斗管理器.突袭出战行动力 : 战斗管理器.普通出战行动力;
    }

    计算胜率(我方战斗力: number, 敌方战斗力: number, 目标: 可袭击地点实体){
        const 战力比 = 我方战斗力 / (敌方战斗力 + 1);
        const 侦察修正 = Math.min(Math.log(Math.E - 1 + 目标.获取侦察进度()/目标.获取侦查最大值()), 1);
        const 基础胜率 = 0.5 + Math.log(战力比);
        const 胜率 = Math.min(1, Math.max(0, 基础胜率 * 侦察修正));
        return 胜率;
    }

    // ─── 战斗预览 ───

    获取战斗预览(): {
        可执行: boolean;
        原因?: string;
        目标?: {
            名称: string;
            战斗力: number;
        };
        我方?: {
            总战斗力: number;
            将领数量: number;
            行动力消耗: number;
            突袭模式: boolean;
        };
        胜率预估?: number;
    } {
        if (!this.选定目标) {
            return { 可执行: false, 原因: '未选择目标地点' };
        }

        if (this.当前部署.size === 0) {
            return { 可执行: false, 原因: '未部署任何将领' };
        }

        const 敌方战斗力估值 = this.选定目标.获取战斗力估值();
        if (敌方战斗力估值 === null) {
            return { 可执行: false, 原因: '目标地点未侦查' };
        }
        const 我方战斗力 = this.计算总战斗力();

        // 简单胜率计算
        const 胜率 = this.计算胜率(我方战斗力, 敌方战斗力估值, this.选定目标);

        return {
            可执行: true,
            目标: {
                名称: this.选定目标.地点名称,
                战斗力: 敌方战斗力估值,
            },
            我方: {
                总战斗力: 我方战斗力,
                将领数量: this.当前部署.size,
                行动力消耗: this.计算行动力消耗(),
                突袭模式: this.突袭模式,
            },
            胜率预估: 胜率,
        };
    }

    // ─── 执行战斗 ───

    执行战斗(): 战斗结果 {
        // 预检
        const 预览 = this.获取战斗预览();
        if (!预览.可执行) {
            return {
                成功: false,
                胜利: false,
                原因: 预览.原因,
                我方战斗力: 0,
                敌方战斗力: 0,
            };
        }

        const 目标 = this.选定目标!;
        const 敌方战斗力 = 目标.获取属性('战斗力') as number;
        const 我方战斗力 = this.计算总战斗力();

        // 战斗判定
        const 战力比 = 我方战斗力 / (敌方战斗力 + 1);
        const 胜率 = this.计算胜率(我方战斗力, 敌方战斗力, 目标); // 计算胜率

        const 胜利 = Math.random() < 胜率;

        // 战损计算
        let 战损比例 = 0;
        if (胜利) {
            战损比例 = Math.max(0, Math.min(0.6, (2 - 战力比) * 0.4));
        } else {
            战损比例 = Math.min(0.8, (1 / 战力比) * 0.4);
        }

        // 应用战损到各喽啰池
        for (const 部署 of this.当前部署.values()) {
            const 池 = 部署.喽啰池;
            const 分组列表 = 池.获取分组详情();

            for (const 分组 of 分组列表) {
                const 损失 = Math.floor(分组.数量 * 战损比例);
                if (损失 > 0) {
                    池.减少喽啰(损失, 分组.等级);
                }
            }
        }

        // 胜利奖励
        const 俘获母畜: string[] = [];
        if (胜利) {
            // 获取已侦察的母畜
            const 已侦察母畜 = 目标.获取所有已侦察母畜();
            for (const 母畜 of 已侦察母畜) {
                俘获母畜.push(母畜.实体ID);
                目标.移除已捕获母畜(母畜);
            }
        }

        // 清理状态
        this.清空出战列表();

        return {
            成功: true,
            胜利,
            我方战斗力,
            敌方战斗力,
            战损比例,
            俘获母畜: 胜利 ? 俘获母畜 : undefined,
        };
    }

    // ─── 重置 ───

    重置(): void {
        this.清空出战列表();
        this.选定目标 = null;
        this.突袭模式 = false;
    }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 喽啰调配器, 战斗管理器 };

export type {
    分配请求,
    分配结果,
    战斗部署,
    战斗配置,
    战斗结果,
    快速填充结果,
    喽啰池管理接口,
    战斗系统依赖,
};
