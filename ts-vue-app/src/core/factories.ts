// ═══════════════════════════════════════════════════════════════
// core/factories.ts
// 工厂类 - 负责创建游戏实体
// ═══════════════════════════════════════════════════════════════

import { 冠军实体, 可袭击地点实体, 母畜实体, 领主实体 } from './entities';
import type { 冠军初始数据, 姓名池配置, 属性系数, 冠军工厂配置, 生育选项, 属性预估范围, 数值范围, 地点名称池, 地点类型配置数据, 地点创建配置, 可袭击地点工厂配置, 运行时配置接口, 
   生育属性预估, 种族配置数据, 身份配置数据, 母畜工厂配置, 母畜创建配置, 领主工厂配置, 领主创建配置, 身份分布权重, 种族分布权重} from '../types/index';

// ═══════════════════════════════════════════════════════════════
// 冠军工厂
// ═══════════════════════════════════════════════════════════════

class 冠军工厂 {
  private 姓名池: 姓名池配置;
  private 生育消耗: number;
  private 随机浮动范围: number;
  private 前缀概率: number;
  private 后缀概率: number;
  private 母畜种族配置: Map<string, 种族配置数据>;
  private 母畜身份配置: Map<string, 身份配置数据>;

  constructor(
    配置: 冠军工厂配置 = {
      冠军姓名池: {
        前缀: [],
        主名: [],
        后缀: [],
      },
      生育消耗: 100,
      属性随机浮动范围: 3,
      前缀概率: 0.3,
      后缀概率: 0.2,
      母畜种族配置: new Map(),
      母畜身份配置: new Map(),
    },
  ) {
    this.姓名池 = 配置.冠军姓名池;
    this.生育消耗 = 配置.生育消耗;
    this.随机浮动范围 = 配置.属性随机浮动范围;
    this.前缀概率 = 配置.前缀概率;
    this.后缀概率 = 配置.后缀概率;
    this.母畜种族配置 = 配置.母畜种族配置;
    this.母畜身份配置 = 配置.母畜身份配置;
  }

  // ─── 配置方法 ───

  生成随机姓名(): string {
    if (this.姓名池?.主名?.length > 0) {
      const 随机选择 = <T>(数组: T[]): T | string => {
        if (!数组 || 数组.length === 0) return '';
        const result = 数组[Math.floor(Math.random() * 数组.length)]!;
        return result;
      };

      const 前缀 = Math.random() < this.前缀概率 ? 随机选择(this.姓名池.前缀) : '';
      const 主名 = 随机选择(this.姓名池.主名);
      const 后缀 = Math.random() < this.后缀概率 ? 随机选择(this.姓名池.后缀) : '';

      return `${前缀}${主名}${后缀}`.trim();
    }

    return `冠军_${Date.now().toString(36).slice(-4)}`;
  }

  // ─── 属性计算辅助 ───

  private 计算随机浮动(): number {
    const 范围 = this.随机浮动范围;
    return Math.floor(Math.random() * (范围 * 2 + 1)) - 范围;
  }

  private 计算属性值(基础值: number, 身份系数: number = 1.0, 种族系数: number = 1.0): number {
    const 浮动 = this.计算随机浮动();
    const 原始值 = (基础值 + 浮动) * 身份系数 * 种族系数;
    return Math.max(1, Math.round(原始值));
  }

  // ─── 创建方法 ───

  从母畜生育(母畜: 母畜实体, 选项: 生育选项 = {}): 冠军实体 {

    const 母畜身份 = 母畜.获取属性('原身份');
    const 母畜种族 = 母畜.获取属性('种族');
    const 总生育力 = 母畜.获取属性('总生育力');

    const 身份系数 = this.母畜身份配置.get(母畜身份)?.生育系数 ?? { 力量: 1.0, 敏捷: 1.0, 智力: 1.0 };
    const 种族系数 = this.母畜种族配置.get(母畜种族)?.生育系数 ?? { 力量: 1.0, 敏捷: 1.0, 智力: 1.0 };

    const 基础值 = 总生育力 / 5;

    const 力量 = this.计算属性值(基础值, 身份系数.力量, 种族系数.力量);
    const 敏捷 = this.计算属性值(基础值, 身份系数.敏捷, 种族系数.敏捷);
    const 智力 = this.计算属性值(基础值, 身份系数.智力, 种族系数.智力);

    const 姓名 = 选项.姓名 ?? this.生成随机姓名();

    const 冠军数据: 冠军初始数据 = {
      姓名,
      力量,
      敏捷,
      智力,
      来源: '生育',
      生母: 母畜.实体ID,
    };

    const 新冠军 = new 冠军实体(冠军数据);
    母畜.记录生育冠军(新冠军);

    return 新冠军;
  }

}

// ═══════════════════════════════════════════════════════════════
// 母畜工厂
// ═══════════════════════════════════════════════════════════════

class 母畜工厂 {
  private 种族配置: Map<string, 种族配置数据>;
  private 身份配置: Map<string, 身份配置数据>;

  //     种族配置: Map<string, 种族配置数据>;
    // 身份配置: Map<string, 身份配置数据>;

  constructor(
    配置: 母畜工厂配置 = {
      种族配置: new Map(),
      身份配置: new Map(),
    },
  ) {
    this.种族配置 = 配置.种族配置;
    this.身份配置 = 配置.身份配置;
  }

  // ===== 创建方法 =====

  创建母畜(配置: 母畜创建配置 = {}): 母畜实体 {
    const 种族 = 配置.种族 || this.随机选择种族();
    const 身份 = 配置.身份 || this.随机选择身份();

    const 母畜 = new 母畜实体({
      姓名: 配置.姓名 || this.生成随机姓名(种族),
      种族,
      年龄: 配置.年龄 ?? this.随机年龄(身份),
      原身份: 身份,
      魅力: 配置.魅力 ?? 10,
      来源: 配置.来源 || '未知',
      臣服度: 配置.臣服度 ?? 0,
      淫乱度: 配置.淫乱度 ?? 0,
      描述: 配置.描述 || this.生成描述(种族, 身份),
      来源地点ID: 配置.来源地点ID || null,
      总生育力: 配置.总生育力 || 100,
      剩余生育力: 配置.剩余生育力 || 配置.总生育力 || 100,
    });


    return 母畜;
  }

  批量创建母畜(数量: number, 基础配置: 母畜创建配置 = {}): 母畜实体[] {
    const 结果: 母畜实体[] = [];
    for (let i = 0; i < 数量; i++) {
      结果.push(
        this.创建母畜({
          ...基础配置,
        }),
      );
    }
    return 结果;
  }

  // ===== 辅助方法 =====

  private 随机选择种族(): string {
    const 种族列表 = [...this.种族配置.keys()];
    if (种族列表.length === 0) return '人类';
    return 种族列表[Math.floor(Math.random() * 种族列表.length)]!;
  }

  private 随机选择身份(): string {
    const 身份列表 = [...this.身份配置.keys()];
    if (身份列表.length === 0) return '平民';
    return 身份列表[Math.floor(Math.random() * 身份列表.length)]!;
  }

  private 随机年龄(身份: string): number {
    const 身份数据 = this.身份配置.get(身份);
    const 最小 = 身份数据?.最小年龄 ?? 18;
    const 最大 = 身份数据?.最大年龄 ?? 40;
    return Math.floor(最小 + Math.random() * (最大 - 最小));
  }

  private 生成随机姓名(种族: string): string {
    const 种族数据 = this.种族配置.get(种族);
    const 姓名池 = 种族数据?.姓名池;
    if (!姓名池) {
      return `无名女`;
    }

    if (姓名池.主名?.length > 0) {
      const 随机选择 = <T>(数组: T[]): T | string => {
        if (!数组 || 数组.length === 0) return '';
        return 数组[Math.floor(Math.random() * 数组.length)]!;
      };
      const 前缀概率 = 种族数据?.前缀概率 ?? 0;
      const 后缀概率 = 种族数据?.后缀概率 ?? 0;

      const 前缀 = Math.random() < 前缀概率 ? 随机选择(姓名池.前缀 ?? []) : '';
      const 主名 = 随机选择(姓名池.主名);
      const 后缀 = Math.random() < 后缀概率 ? 随机选择(姓名池.后缀 ?? []) : '';

      return `${前缀}${主名}${后缀}`.trim();
    }

    return `无名女`;
  }

  private 生成描述(种族: string, 身份: string): string {
    return `一位 ${种族} ${身份}`;
  }
}

// ═══════════════════════════════════════════════════════════════
// 领主工厂
// ═══════════════════════════════════════════════════════════════

class 领主工厂 {
  private 默认配置: { 魔力: number; 最大魔力: number; 姓名: string };

  constructor(
    配置: 领主工厂配置 = {
      初始魔力: 0,
      最大魔力: 100,
      默认姓名: '无名领主',
    },
  ) {
    this.默认配置 = {
      魔力: 配置.初始魔力,
      最大魔力: 配置.最大魔力,
      姓名: 配置.默认姓名,
    };
  }

  创建领主(配置: 领主创建配置 = {}): 领主实体 {
    return new 领主实体({
      ...this.默认配置,
      ...配置,
    });
  }
}

// ═══════════════════════════════════════════════════════════════
// 可袭击地点工厂
// ═══════════════════════════════════════════════════════════════

class 可袭击地点工厂 {
  private 地点类型配置: Map<string, 地点类型配置数据>;
  private 母畜工厂: 母畜工厂 | null;

  constructor(配置: 可袭击地点工厂配置 = {}) {
    this.地点类型配置 = 配置.地点类型配置 ?? new Map();
    this.母畜工厂 = null;
  }

  设置母畜工厂(工厂: 母畜工厂): void {
    this.母畜工厂 = 工厂;
  }

  创建地点(类型: string, 配置: 地点创建配置 = {}): 可袭击地点实体 {
    if (!this.地点类型配置.has(类型)) {
      throw new Error(`未知的地点类型: ${类型}`);
    }
    const 类型配置 = this.地点类型配置.get(类型)!;

    const 战斗力范围 = 类型配置.战斗力范围;
    const 战斗力 = 战斗力范围
      ? Math.floor(Math.random() * (战斗力范围.最大 - 战斗力范围.最小 + 1)) + 战斗力范围.最小
      : 0;

    const 地点 = new 可袭击地点实体({
      地点名称: 配置.名称 || this.生成地点名称(类型),
      地点类型: 类型,
      描述: 配置.描述 || 类型配置.地点名称池.描述 || '一个神秘的地点',
      战斗力: 配置.战斗力 ?? 战斗力,
      侦察进度: 配置.侦察进度 ?? 0,
      侦察最大值: 配置.侦察最大值 ?? 类型配置.侦察最大值 ?? 100,
    });

    if (this.母畜工厂) {
      this.填充潜在母畜(地点, 类型配置, 配置);
    }

    return 地点;
  }

  private 填充潜在母畜(可袭击地点: 可袭击地点实体, 类型配置: 地点类型配置数据, 额外配置: 地点创建配置 = {}): void {
    const 母畜数量范围 = 类型配置.母畜数量范围;
    const 数量 =
      额外配置.母畜数量 ?? 母畜数量范围
        ? Math.floor(Math.random() * (母畜数量范围.最大 - 母畜数量范围.最小 + 1)) + 母畜数量范围.最小
        : 5;
    const 身份分布 = 类型配置.身份分布 || { 平民: 1 };
    const 种族分布 = 类型配置.种族分布 || { 人类: 1 };

    for (let i = 0; i < 数量; i++) {
      const 身份 = this.按权重选择(身份分布) ?? '平民';
      const 种族 = this.按权重选择(种族分布) ?? '人类';
      const 母畜 = this.母畜工厂!.创建母畜({
        身份: 身份,
        种族: 种族,
        来源地点ID: 可袭击地点.实体ID,
      });
      可袭击地点.添加潜在母畜(母畜);
    }
  }

  private 按权重选择(权重对象: Record<string, number>): string | null {
    const 条目 = Object.entries(权重对象);
    const 总权重 = 条目.reduce((sum, [, w]) => sum + w, 0);
    let 随机值 = Math.random() * 总权重;

    for (const [选项, 权重] of 条目) {
      随机值 -= 权重;
      if (随机值 <= 0) return 选项;
    }
    return 条目[0]?.[0] ?? null;
  }

  private 生成地点名称(类型: string): string {
    const 地点名称池 = this.地点类型配置.get(类型)?.地点名称池;
    const 前缀列表 = 地点名称池?.前缀 ?? ['东'];
    const 中缀列表 = 地点名称池?.中缀 ?? ['德'];
    const 后缀列表 = 地点名称池?.后缀 ?? ['镇'];

    const 随机取 = <T>(arr: T[]): T => arr[Math.floor(Math.random() * arr.length)]!;
    return `${随机取(前缀列表)}${随机取(中缀列表)}${随机取(后缀列表)}`;
  }
}

// ═══════════════════════════════════════════════════════════════
// 工厂管理器
// ═══════════════════════════════════════════════════════════════

class 工厂管理器 {
  readonly 冠军工厂: 冠军工厂;
  readonly 母畜工厂: 母畜工厂;
  readonly 领主工厂: 领主工厂;
  readonly 可袭击地点工厂: 可袭击地点工厂;

  constructor(运行时配置: 运行时配置接口 = {}) {
    this.冠军工厂 = new 冠军工厂(运行时配置.冠军配置);
    this.母畜工厂 = new 母畜工厂(运行时配置.母畜配置);
    this.领主工厂 = new 领主工厂(运行时配置.领主配置);
    this.可袭击地点工厂 = new 可袭击地点工厂(运行时配置.地点配置);
    this.可袭击地点工厂.设置母畜工厂(this.母畜工厂);
  }

  // ─── 工厂访问 ───

  获取冠军工厂(): 冠军工厂 {
    return this.冠军工厂;
  }

  获取母畜工厂(): 母畜工厂 {
    return this.母畜工厂;
  }

  获取领主工厂(): 领主工厂 {
    return this.领主工厂;
  }

  获取可袭击地点工厂(): 可袭击地点工厂 {
    return this.可袭击地点工厂;
  }

  // ─── 快捷创建方法 ───

  创建母畜(配置: 母畜创建配置): 母畜实体 {
    return this.母畜工厂.创建母畜(配置);
  }

  创建领主(配置: 领主创建配置): 领主实体 {
    return this.领主工厂.创建领主(配置);
  }

  创建可袭击地点(类型: string, 配置: 地点创建配置): 可袭击地点实体 {
    return this.可袭击地点工厂.创建地点(类型, 配置);
  }

  从母畜生育哥布林冠军(母畜: 母畜实体, 选项: 生育选项): 冠军实体 {
    return this.冠军工厂.从母畜生育(母畜, 选项);
  }

  // ─── 批量操作 ───

  批量创建母畜(数量: number, 配置: 母畜创建配置): 母畜实体[] {
    return this.母畜工厂.批量创建母畜(数量, 配置);
  }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export { 冠军工厂, 可袭击地点工厂, 工厂管理器, 母畜工厂, 领主工厂 };

export type {
  冠军工厂配置,
  可袭击地点工厂配置,
  地点创建配置,
  地点类型配置数据,
  姓名池配置,
  属性系数,
  母畜创建配置,
  母畜工厂配置,
  生育属性预估,
  生育选项,
  运行时配置接口,
  领主创建配置,
  领主工厂配置,
};
