
// ═══════════════════════════════════════════════════════════════
// core/persistence.ts
// 存读档系统 - 游戏状态的序列化与反序列化
// ═══════════════════════════════════════════════════════════════

import {
    冠军实体,
    可袭击地点实体,
    喽啰池实体,
    母畜实体,
    领主实体
} from './entities';
import { 工厂管理器 } from './factories';
import { 游戏总控 } from '../game/controller';
import type { 武装等级 } from '../types/common';

// ═══════════════════════════════════════════════════════════════
// 序列化数据结构定义
// ═══════════════════════════════════════════════════════════════

/** 领主序列化数据 */
interface 领主存档数据 {
    实体ID: string;
    姓名: string;
    魔力: number;
    最大魔力: number;
}

/** 冠军序列化数据 */
interface 冠军存档数据 {
    实体ID: string;
    姓名: string;
    性别: string;
    力量: number;
    敏捷: number;
    智力: number;
    来源: string;
    生母: string | null;
    喽啰池数据: 喽啰池存档数据 | null;
}

/** 喽啰池序列化数据 */
interface 喽啰池存档数据 {
    实体ID: string;
    将领ID: string | null;
    武装分组: Array<{
        等级: 武装等级;
        数量: number;
    }>;
}

/** 母畜序列化数据 */
interface 母畜存档数据 {
    实体ID: string;
    姓名: string;
    种族: string;
    年龄: number;
    原身份: string;
    来源: string;
    描述: string;
    总生育力: number;
    剩余生育力: number;
    淫乱度: number;
    臣服度: number;
    魅力: number;
    特性列表: string[];
    来源地点ID: string | null;
    冠军生育记录: string[];
    喽啰生育记录: number;
}

/** 可袭击地点序列化数据 */
interface 地点存档数据 {
    实体ID: string;
    地点名称: string;
    地点类型: string;
    描述: string;
    侦察最大值: number;
    侦察进度: number;
    战斗力: number;
    战斗力估值: number | null;
    潜在母畜列表: 母畜存档数据[];
    已侦察母畜列表: 母畜存档数据[];
}

/** 资源状态存档数据 */
interface 资源存档数据 {
    士气: number;
    最大士气: number;
    催淫母乳: number;
}

/** 完整游戏存档数据 */
interface 游戏存档数据 {
    版本号: string;
    存档时间: number;
    存档名称: string;
    回合数: number;
    领主: 领主存档数据;
    冠军列表: 冠军存档数据[];
    母畜列表: 母畜存档数据[];
    地点列表: 地点存档数据[];
    无将领喽啰池: 喽啰池存档数据;
    资源状态: 资源存档数据;
}

/** 存档槽位信息 */
interface 存档槽位 {
    槽位索引: number;
    存档名称: string;
    存档时间: number;
    回合数: number;
    领主姓名: string;
    冠军数量: number;
    母畜数量: number;
}

// ═══════════════════════════════════════════════════════════════
// 序列化器 - 将游戏实体转换为可存储的数据
// ═══════════════════════════════════════════════════════════════

class 游戏序列化器 {
    private static readonly 当前版本 = '1.0.0';

    // ─── 实体序列化 ───

    static 序列化领主(领主: 领主实体): 领主存档数据 {
        return {
            实体ID: 领主.实体ID,
            姓名: 领主.获取属性('姓名'),
            魔力: 领主.获取属性('魔力'),
            最大魔力: 领主.获取属性('最大魔力'),
        };
    }

    static 序列化喽啰池(喽啰池: 喽啰池实体): 喽啰池存档数据 {
        const 分组数据: Array<{ 等级: 武装等级; 数量: number }> = [];

        喽啰池.武装分组.forEach((数据, 等级) => {
            if (数据.数量 > 0) {
                分组数据.push({ 等级, 数量: 数据.数量 });
            }
        });

        return {
            实体ID: 喽啰池.实体ID,
            将领ID: 喽啰池.获取将领()?.实体ID ?? null,
            武装分组: 分组数据,
        };
    }

    static 序列化冠军(冠军: 冠军实体): 冠军存档数据 {
        const 喽啰池 = 冠军.获取喽啰池();

        return {
            实体ID: 冠军.实体ID,
            姓名: 冠军.获取属性('姓名'),
            性别: 冠军.获取属性('性别'),
            力量: 冠军.获取属性('力量'),
            敏捷: 冠军.获取属性('敏捷'),
            智力: 冠军.获取属性('智力'),
            来源: 冠军.获取属性('来源'),
            生母: 冠军.生母,
            喽啰池数据: 喽啰池 ? this.序列化喽啰池(喽啰池) : null,
        };
    }

    static 序列化母畜(母畜: 母畜实体): 母畜存档数据 {
        return {
            实体ID: 母畜.实体ID,
            姓名: 母畜.获取属性('姓名'),
            种族: 母畜.获取属性('种族'),
            年龄: 母畜.获取属性('年龄'),
            原身份: 母畜.获取属性('原身份'),
            来源: 母畜.获取属性('来源'),
            描述: 母畜.获取属性('描述'),
            总生育力: 母畜.获取属性('总生育力'),
            剩余生育力: 母畜.获取属性('剩余生育力'),
            淫乱度: 母畜.获取属性('淫乱度'),
            臣服度: 母畜.获取属性('臣服度'),
            魅力: 母畜.获取属性('魅力'),
            特性列表: Array.from(母畜.特性列表),
            来源地点ID: 母畜.来源地点ID,
            冠军生育记录: 母畜.冠军生育记录,
            喽啰生育记录: 母畜.喽啰生育记录,
        };
    }

    static 序列化地点(地点: 可袭击地点实体): 地点存档数据 {
        const 潜在母畜: 母畜存档数据[] = [];
        const 已侦察母畜: 母畜存档数据[] = [];

        地点.获取潜在母畜().forEach(母畜 => {
            潜在母畜.push(this.序列化母畜(母畜));
        });

        地点.获取所有已侦察母畜().forEach(母畜 => {
            已侦察母畜.push(this.序列化母畜(母畜));
        });

        return {
            实体ID: 地点.实体ID,
            地点名称: 地点.地点名称,
            地点类型: 地点.地点类型,
            描述: 地点.描述,
            侦察最大值: 地点.侦察最大值,
            侦察进度: 地点.侦察进度,
            战斗力: 地点.获取属性('战斗力'),
            战斗力估值: 地点.获取战斗力估值(),
            潜在母畜列表: 潜在母畜,
            已侦察母畜列表: 已侦察母畜,
        };
    }

    // ─── 完整游戏状态序列化 ───

    static 序列化游戏(游戏: 游戏总控, 存档名称: string = '快速存档'): 游戏存档数据 {
        const 实体管理器 = 游戏.系统管理.获取实体管理器();
        const 资源管理器 = 游戏.系统管理.获取资源管理器();
        const 回合管理器 = 游戏.系统管理.获取回合管理器();

        // 序列化所有冠军
        const 冠军列表: 冠军存档数据[] = [];
        实体管理器.获取所有冠军().forEach(冠军 => {
            冠军列表.push(this.序列化冠军(冠军));
        });

        // 序列化玩家拥有的母畜
        const 母畜列表: 母畜存档数据[] = [];
        实体管理器.获取所有母畜().forEach(母畜 => {
            母畜列表.push(this.序列化母畜(母畜));
        });

        // 序列化地点（包含地点内的潜在母畜和已侦察母畜）
        const 地点列表: 地点存档数据[] = [];
        实体管理器.获取所有地点().forEach(地点 => {
            地点列表.push(this.序列化地点(地点));
        });

        return {
            版本号: this.当前版本,
            存档时间: Date.now(),
            存档名称,
            回合数: 回合管理器.获取当前回合(),
            领主: this.序列化领主(游戏.领主管理.获取领主()),
            冠军列表,
            母畜列表,
            地点列表,
            无将领喽啰池: this.序列化喽啰池(实体管理器.获取无将领喽啰池()),
            资源状态: 资源管理器.获取资源状态(),
        };
    }
}

// ═══════════════════════════════════════════════════════════════
// 反序列化器 - 从存档数据重建游戏实体
// ═══════════════════════════════════════════════════════════════

class 游戏反序列化器 {
    private 工厂管理器: 工厂管理器;
    private 实体ID映射: Map<string, string>; // 旧ID -> 新ID

    constructor(工厂管理器: 工厂管理器) {
        this.工厂管理器 = 工厂管理器;
        this.实体ID映射 = new Map();
    }

    // ─── 实体重建 ───

    重建母畜(数据: 母畜存档数据, 保持原ID: boolean = false): 母畜实体 {
        const 母畜 = new 母畜实体({
            实体ID: 数据.实体ID,
            姓名: 数据.姓名,
            种族: 数据.种族,
            年龄: 数据.年龄,
            原身份: 数据.原身份,
            来源: 数据.来源,
            描述: 数据.描述,
            总生育力: 数据.总生育力,
            剩余生育力: 数据.剩余生育力,
            淫乱度: 数据.淫乱度,
            臣服度: 数据.臣服度,
            魅力: 数据.魅力,
            特性列表: 数据.特性列表,
            来源地点ID: 数据.来源地点ID,
            冠军生育记录: 数据.冠军生育记录,
            喽啰生育记录: 数据.喽啰生育记录,
        });

        // 记录ID映射（用于后续引用修复）
        this.实体ID映射.set(数据.实体ID, 母畜.实体ID);

        return 母畜;
    }

    重建冠军(数据: 冠军存档数据): 冠军实体 {
        const 冠军 = new 冠军实体({
            姓名: 数据.姓名,
            性别: 数据.性别,
            力量: 数据.力量,
            敏捷: 数据.敏捷,
            智力: 数据.智力,
            来源: 数据.来源,
            生母: 数据.生母,
        });

        // 重建喽啰池数据
        if (数据.喽啰池数据) {
            const 喽啰池 = 冠军.获取喽啰池();
            数据.喽啰池数据.武装分组.forEach(分组 => {
                喽啰池.增加喽啰(分组.数量, 分组.等级);
            });
        }

        this.实体ID映射.set(数据.实体ID, 冠军.实体ID);

        return 冠军;
    }

    重建地点(数据: 地点存档数据): 可袭击地点实体 {
        const 地点 = new 可袭击地点实体({
            地点名称: 数据.地点名称,
            地点类型: 数据.地点类型,
            描述: 数据.描述,
            侦察最大值: 数据.侦察最大值,
            侦察进度: 数据.侦察进度,
            战斗力: 数据.战斗力,
        });

        // 重建潜在母畜
        数据.潜在母畜列表.forEach(母畜数据 => {
            const 母畜 = this.重建母畜(母畜数据);
            地点.添加潜在母畜(母畜);
        });

        // 重建已侦察母畜（需要先添加到潜在池再标记为已侦察）
        数据.已侦察母畜列表.forEach(母畜数据 => {
            const 母畜 = this.重建母畜(母畜数据);
            地点.添加潜在母畜(母畜);
            地点.标记母畜已侦察(母畜);
        });

        // 恢复战斗力估值
        if (数据.战斗力估值 !== null) {
            地点.增加侦察进度(0); // 触发估值计算
            // 直接设置估值（需要在实体类中添加setter或这里用类型断言）
            (地点 as any).战斗力估值 = 数据.战斗力估值;
        }

        this.实体ID映射.set(数据.实体ID, 地点.实体ID);

        return 地点;
    }

    重建领主(数据: 领主存档数据): 领主实体 {
        const 领主 = new 领主实体({
            姓名: 数据.姓名,
            魔力: 数据.魔力,
            最大魔力: 数据.最大魔力,
        });

        this.实体ID映射.set(数据.实体ID, 领主.实体ID);

        return 领主;
    }

    // ─── 完整游戏重建 ───

    重建游戏(存档数据: 游戏存档数据, 游戏实例: 游戏总控): void {
        this.实体ID映射.clear();

        const 实体管理器 = 游戏实例.系统管理.获取实体管理器();
        const 资源管理器 = 游戏实例.系统管理.获取资源管理器();

        // 1. 重建领主
        const 领主 = this.重建领主(存档数据.领主);
        游戏实例.领主管理.设置领主(领主);

        // 2. 重建无将领喽啰池
        const 无将领池 = 实体管理器.获取无将领喽啰池();
        存档数据.无将领喽啰池.武装分组.forEach(分组 => {
            无将领池.增加喽啰(分组.数量, 分组.等级);
        });

        // 3. 重建冠军
        存档数据.冠军列表.forEach(冠军数据 => {
            const 冠军 = this.重建冠军(冠军数据);
            实体管理器.添加冠军(冠军);
        });

        // 4. 重建玩家拥有的母畜
        存档数据.母畜列表.forEach(母畜数据 => {
            const 母畜 = this.重建母畜(母畜数据);
            实体管理器.添加母畜(母畜);
        });

        // 5. 重建地点
        存档数据.地点列表.forEach(地点数据 => {
            const 地点 = this.重建地点(地点数据);
            实体管理器.添加地点(地点);
        });

        // 6. 恢复资源状态
        资源管理器.设置士气(存档数据.资源状态.士气);
        资源管理器.设置最大士气(存档数据.资源状态.最大士气);
        资源管理器.设置催淫母乳数量(存档数据.资源状态.催淫母乳);

        // 7. 恢复回合数（需要在回合管理器中添加setter）
        const 回合管理器 = 游戏实例.系统管理.获取回合管理器();
        (回合管理器 as any).当前回合 = 存档数据.回合数;
    }

    // ─── 获取ID映射 ───

    获取新实体ID(旧ID: string): string | undefined {
        return this.实体ID映射.get(旧ID);
    }
}

// ═══════════════════════════════════════════════════════════════
// 存档管理器 - 处理存档的存储、读取、管理
// ═══════════════════════════════════════════════════════════════

class 存档管理器 {
    private static readonly 存档前缀 = 'goblin_game_save_';
    private static readonly 最大槽位数 = 10;
    private static readonly 自动存档槽位 = 0;

    private 工厂管理器: 工厂管理器;

    constructor(工厂管理器: 工厂管理器) {
        this.工厂管理器 = 工厂管理器;
    }

    // ─── 存档操作 ───

    获取存档数据(游戏: 游戏总控, 存档名称?: string): 游戏存档数据 | null{        
    try {
        const 存档数据 = 游戏序列化器.序列化游戏(
            游戏,
            存档名称 ?? `快速存档`
        );

        return 存档数据;
    } catch (错误) {
        console.error('保存游戏失败:', 错误);
        return null;
    }

    }

    加载存档数据(游戏存档数据:游戏存档数据, 游戏: 游戏总控): boolean{
        try {
            // 清空当前游戏状态
            this.清空游戏状态(游戏);

            // 重建游戏
            const 反序列化器 = new 游戏反序列化器(this.工厂管理器);
            反序列化器.重建游戏(游戏存档数据, 游戏);

            return true;
        } catch (错误) {
            console.error('加载存档失败:', 错误);
            return false;
        }
    }

    /**
     * 保存游戏到指定槽位
     */
    保存游戏(游戏: 游戏总控, 槽位: number, 存档名称?: string): { 成功: boolean; 原因?: string } {
        if (槽位 < 0 || 槽位 >= 存档管理器.最大槽位数) {
            return { 成功: false, 原因: '无效的存档槽位' };
        }

        try {
            const 存档数据 = 游戏序列化器.序列化游戏(
                游戏,
                存档名称 ?? `存档 ${槽位}`
            );

            const 存档JSON = JSON.stringify(存档数据);
            const 存档键 = this.获取存档键(槽位);

            localStorage.setItem(存档键, 存档JSON);

            return { 成功: true };
        } catch (错误) {
            console.error('保存游戏失败:', 错误);
            return { 成功: false, 原因: `保存失败: ${错误}` };
        }
    }

    /**
     * 自动存档
     */
    自动存档(游戏: 游戏总控): { 成功: boolean; 原因?: string } {
        return this.保存游戏(游戏, 存档管理器.自动存档槽位, '自动存档');
    }

    /**
     * 从指定槽位读取存档
     */
    读取存档(槽位: number): { 成功: boolean; 数据?: 游戏存档数据; 原因?: string } {
        if (槽位 < 0 || 槽位 >= 存档管理器.最大槽位数) {
            return { 成功: false, 原因: '无效的存档槽位' };
        }

        try {
            const 存档键 = this.获取存档键(槽位);
            const 存档JSON = localStorage.getItem(存档键);

            if (!存档JSON) {
                return { 成功: false, 原因: '存档不存在' };
            }

            const 存档数据: 游戏存档数据 = JSON.parse(存档JSON);

            // 版本兼容性检查
            if (!this.检查版本兼容性(存档数据.版本号)) {
                return { 成功: false, 原因: '存档版本不兼容' };
            }

            return { 成功: true, 数据: 存档数据 };
        } catch (错误) {
            console.error('读取存档失败:', 错误);
            return { 成功: false, 原因: `读取失败: ${错误}` };
        }
    }

    /**
     * 加载存档到游戏实例
     */
    加载存档(槽位: number, 游戏: 游戏总控): { 成功: boolean; 原因?: string } {
        const 读取结果 = this.读取存档(槽位);

        if (!读取结果.成功 || !读取结果.数据) {
            return { 成功: false, 原因: 读取结果.原因 };
        }

        try {
            // 清空当前游戏状态
            this.清空游戏状态(游戏);

            // 重建游戏
            const 反序列化器 = new 游戏反序列化器(this.工厂管理器);
            反序列化器.重建游戏(读取结果.数据, 游戏);

            return { 成功: true };
        } catch (错误) {
            console.error('加载存档失败:', 错误);
            return { 成功: false, 原因: `加载失败: ${错误}` };
        }
    }

    /**
     * 删除存档
     */
    删除存档(槽位: number): { 成功: boolean; 原因?: string } {
        if (槽位 < 0 || 槽位 >= 存档管理器.最大槽位数) {
            return { 成功: false, 原因: '无效的存档槽位' };
        }

        try {
            const 存档键 = this.获取存档键(槽位);
            localStorage.removeItem(存档键);
            return { 成功: true };
        } catch (错误) {
            return { 成功: false, 原因: `删除失败: ${错误}` };
        }
    }

    // ─── 存档信息查询 ───

    /**
     * 获取所有存档槽位信息
     */
    获取所有存档信息(): 存档槽位[] {
        const 槽位列表: 存档槽位[] = [];

        for (let i = 0; i < 存档管理器.最大槽位数; i++) {
            const 槽位信息 = this.获取存档槽位信息(i);
            if (槽位信息) {
                槽位列表.push(槽位信息);
            }
        }

        return 槽位列表;
    }

    /**
     * 获取指定槽位的存档信息（不加载完整数据）
     */
    获取存档槽位信息(槽位: number): 存档槽位 | null {
        try {
            const 存档键 = this.获取存档键(槽位);
            const 存档JSON = localStorage.getItem(存档键);

            if (!存档JSON) {
                return null;
            }

            const 存档数据: 游戏存档数据 = JSON.parse(存档JSON);

            return {
                槽位索引: 槽位,
                存档名称: 存档数据.存档名称,
                存档时间: 存档数据.存档时间,
                回合数: 存档数据.回合数,
                领主姓名: 存档数据.领主.姓名,
                冠军数量: 存档数据.冠军列表.length,
                母畜数量: 存档数据.母畜列表.length,
            };
        } catch {
            return null;
        }
    }

    /**
     * 检查槽位是否有存档
     */
    存档存在(槽位: number): boolean {
        const 存档键 = this.获取存档键(槽位);
        return localStorage.getItem(存档键) !== null;
    }

    // ─── 导入导出 ───

    /**
     * 导出存档为JSON字符串（用于备份或分享）
     */
    导出存档(游戏: 游戏总控): string {
        const 存档数据 = 游戏序列化器.序列化游戏(游戏, '导出存档');
        return JSON.stringify(存档数据, null, 2);
    }

    /**
     * 导出存档并下载为文件
     */
    导出存档为文件(游戏: 游戏总控, 文件名?: string): void {
        const 存档JSON = this.导出存档(游戏);
        const blob = new Blob([存档JSON], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const 链接 = document.createElement('a');
        链接.href = url;
        链接.download = 文件名 ?? `goblin_save_${Date.now()}.json`;
        链接.click();

        URL.revokeObjectURL(url);
    }

    /**
     * 从JSON字符串导入存档
     */
    导入存档(存档JSON: string): { 成功: boolean; 数据?: 游戏存档数据; 原因?: string } {
        try {
            const 存档数据: 游戏存档数据 = JSON.parse(存档JSON);

            // 验证存档结构
            if (!this.验证存档结构(存档数据)) {
                return { 成功: false, 原因: '存档结构无效' };
            }

            // 版本兼容性检查
            if (!this.检查版本兼容性(存档数据.版本号)) {
                return { 成功: false, 原因: '存档版本不兼容' };
            }

            return { 成功: true, 数据: 存档数据 };
        } catch (错误) {
            return { 成功: false, 原因: `解析失败: ${错误}` };
        }
    }

    /**
     * 从文件导入存档
     */
    async 从文件导入存档(文件: File): Promise<{ 成功: boolean; 数据?: 游戏存档数据; 原因?: string }> {
        return new Promise((resolve) => {
            const reader = new FileReader();

            reader.onload = (事件) => {
                const 内容 = 事件.target?.result as string;
                resolve(this.导入存档(内容));
            };

            reader.onerror = () => {
                resolve({ 成功: false, 原因: '文件读取失败' });
            };

            reader.readAsText(文件);
        });
    }

    /**
     * 导入并加载存档到游戏
     */
    导入并加载存档(存档JSON: string, 游戏: 游戏总控): { 成功: boolean; 原因?: string } {
        const 导入结果 = this.导入存档(存档JSON);

        if (!导入结果.成功 || !导入结果.数据) {
            return { 成功: false, 原因: 导入结果.原因 };
        }

        try {
            this.清空游戏状态(游戏);

            const 反序列化器 = new 游戏反序列化器(this.工厂管理器);
            反序列化器.重建游戏(导入结果.数据, 游戏);

            return { 成功: true };
        } catch (错误) {
            return { 成功: false, 原因: `加载失败: ${错误}` };
        }
    }

    // ─── 辅助方法 ───

    private 获取存档键(槽位: number): string {
        return `${存档管理器.存档前缀}${槽位}`;
    }

    private 检查版本兼容性(版本号: string): boolean {
        // 简单的版本兼容性检查，未来可扩展为语义化版本比较
        const 当前主版本 = '1';
        const 存档主版本 = 版本号.split('.')[0];
        return 当前主版本 === 存档主版本;
    }

    private 验证存档结构(数据: any): 数据 is 游戏存档数据 {
        return (
            typeof 数据 === 'object' &&
            typeof 数据.版本号 === 'string' &&
            typeof 数据.存档时间 === 'number' &&
            typeof 数据.回合数 === 'number' &&
            typeof 数据.领主 === 'object' &&
            Array.isArray(数据.冠军列表) &&
            Array.isArray(数据.母畜列表) &&
            Array.isArray(数据.地点列表) &&
            typeof 数据.无将领喽啰池 === 'object' &&
            typeof 数据.资源状态 === 'object'
        );
    }

    private 清空游戏状态(游戏: 游戏总控): void {
        const 实体管理器 = 游戏.系统管理.获取实体管理器();

        // 清空所有实体
        // 注意：这需要在实体管理器中添加清空方法
        // 这里假设实体管理器有对应的清空方法
        (实体管理器 as any).清空所有实体?.();
    }
}

// ═══════════════════════════════════════════════════════════════
// 导出
// ═══════════════════════════════════════════════════════════════

export {
    游戏序列化器,
    游戏反序列化器,
    存档管理器,
};

export type {
    游戏存档数据,
    存档槽位,
    领主存档数据,
    冠军存档数据,
    母畜存档数据,
    地点存档数据,
    喽啰池存档数据,
    资源存档数据,
};
